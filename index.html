<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Johnny Wicked Survivors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            user-select: none; /* Prevent text selection on touch */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Remove tap highlight on iOS */
            flex-direction: column; /* For better mobile layout */
        }
        
        #gameContainer {
            position: relative;
            width: 900px; /* Base width */
            height: 700px; /* Base height */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;

            /* Responsive adjustments for gameContainer */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 95vh; /* Max height relative to viewport */
            aspect-ratio: 9 / 7; /* Maintain aspect ratio */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Make canvas fill its container */
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
        }
        
        /* Top Left Controls: Score and Pause Button */
        #top-left-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: all; /* Allow interaction */
        }

        /* Bottom Left Controls: Time, Menu, and Level */
        #bottom-left-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: all; /* Allow interaction */
        }

        #score-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between score and pause button */
        }
        
        /* Time display now part of bottom-left-controls */
        #time-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between time and menu button */
            display: block; /* Ensure it's visible */
        }
        
        #level-display {
            position: static; /* Remove absolute positioning from here */
            /* No margin-bottom needed as it's the last item */
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box, .menu, #level-select-menu { /* Apply menu styles to message-box, game-menu, and level-select-menu */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
            z-index: 11; /* Ensure menus are on top */
        }
        
        #power-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .power-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 200px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
        }
        
        .power-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
        .power-card p {
            font-size: 0.9em;
            margin-bottom: 0;
        }

        /* General menu button styles */
        .menu button, .control-button, #level-select-menu button { 
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }
        
        .menu button:hover, .control-button:hover, #level-select-menu button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        /* Specific styles for the new control buttons */
        #pauseButton, #menuButton, #muteMusicButton, #resumeFromMenuButton { 
            padding: 8px 15px; /* Smaller padding for control buttons */
            font-size: 1em; /* Smaller font size */
            margin-top: 0; /* Remove top margin */
            background: linear-gradient(45deg, #007bff, #0056b3); /* Blue gradient */
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #pauseButton:hover, #menuButton:hover, #muteMusicButton:hover, #resumeFromMenuButton:hover {
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Particle effect styles */
        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8); /* White with some transparency */
            border-radius: 50%; /* Make them circular */
            pointer-events: none; /* Do not block mouse events */
            animation: fadeOutAndShrink 0.8s forwards; /* Animation for fading and shrinking */
        }

        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            width: 80%;
            max-width: 250px;
            font-family: 'Chakra Petch', monospace;
            font-size: 1em;
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        #high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #high-scores-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #high-scores-list li:last-child {
            border-bottom: none;
        }
        #high-scores-list li span {
            color: #00ffff;
            font-weight: bold;
        }

        /* Mini-map styles */
        #miniMapContainer {
            position: absolute;
            top: 10px; /* Adjust as needed */
            right: 10px; /* Adjust as needed */
            width: 150px; /* Fixed width */
            height: 150px; /* Fixed height */
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            border-radius: 5px;
            overflow: hidden; /* Ensure content stays within bounds */
            pointer-events: none; /* Do not block clicks on game elements */
            z-index: 10; /* Above game canvas, below menus */
        }

        #miniMapCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Level Select Menu Styles */
        .level-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 250px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            pointer-events: all;
            margin-bottom: 15px; /* Space between cards */
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card.locked:hover {
            transform: none;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card h3 {
            margin-top: 0;
            color: #00ffff;
            font-size: 1.5em;
        }

        .level-card p {
            font-size: 1em;
            margin-bottom: 5px;
        }

        .level-card .unlock-info {
            color: #ffdd00;
            font-size: 0.9em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <!-- Top Left Controls: Score and Pause Button -->
            <div id="top-left-controls">
                <div id="score-display" class="hud-item">Score: 0</div>
                <button id="pauseButton" class="control-button">Pause</button>
            </div>

            <!-- Bottom Left Controls: Time, Menu, and Level -->
            <div id="bottom-left-controls">
                <div id="time-display" class="hud-item">Time: 0s</div>
                <button id="menuButton" class="control-button">Menu</button>
                <div id="level-display" class="hud-item">Level: 1</div>
            </div>

            <!-- Mini-map container -->
            <div id="miniMapContainer">
                <canvas id="miniMapCanvas"></canvas>
            </div>

            <div id="xp-bar-container"><div id="xp-bar"></div></div>
            <div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
            <button id="ultimate-button">Wicked Mode</button>
        </div>
        
        <div id="start-menu" class="menu">
            <h1>JOHNNY WICKED SURVIVORS</h1>
            <p>Click or tap anywhere to move. Your character will fire automatically.</p>
            <p>New: Enemies can now shoot back! Be careful of the gunmen.</p>
            <button id="startButton">Start Game</button>
            <button id="levelSelectButton">Level Select</button>
        </div>

        <div id="game-over-menu" class="menu" style="display: none;">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Score: 0</h2>
            <h2 id="final-time">Time Survived: 0s</h2>
            <h2 id="final-level">Level Reached: 1</h2>
            <h3>High Scores</h3>
            <ul id="high-scores-list">
                <!-- High scores will be loaded here -->
            </ul>
            <button id="restartButton">Restart Game</button>
        </div>

        <div id="message-box" class="menu" style="display: none;">
            <h3 id="message-title">Level Up!</h3>
            <p id="message-text">Choose your power-up:</p>
            <div id="power-selection"></div>
        </div>

        <!-- Game Menu -->
        <div id="game-menu" class="menu" style="display: none;">
            <h1>Game Menu</h1>
            <button id="muteMusicButton" class="control-button">Mute Music</button>
            <button id="resumeFromMenuButton" class="control-button">Resume Game</button>
        </div>

        <div id="high-score-modal" style="display: none;">
            <h3>New High Score!</h3>
            <p>Enter your name:</p>
            <input type="text" id="playerNameInput" maxlength="15" placeholder="Your Name">
            <button id="saveScoreButton">Save Score</button>
        </div>

        <!-- Level Select Menu -->
        <div id="level-select-menu" class="menu" style="display: none;">
            <h1>Select Level</h1>
            <div id="level-options">
                <!-- Levels will be dynamically loaded here -->
            </div>
            <button id="backToMainMenuButton">Back</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in init function)
        window.fb = {};

        window.initFirebase = async function() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing. High score system will not function.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            window.fb.db = getFirestore(app);
            window.fb.auth = getAuth(app);
            window.fb.appId = appId; // Store appId for later use

            // Sign in anonymously if no custom token is provided
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(window.fb.auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await signInAnonymously(window.fb.auth);
                    console.log("Signed in anonymously instead.");
                }
            } else {
                await signInAnonymously(window.fb.auth);
                console.log("Signed in anonymously.");
            }

            // Listen for auth state changes to ensure user is ready
            onAuthStateChanged(window.fb.auth, (user) => {
                if (user) {
                    window.fb.userId = user.uid;
                    console.log("Firebase user ready:", window.fb.userId);
                    // Load user's level scores once authenticated
                    window.loadUserLevelScore('hotel_lobby').then(score => {
                        window.highestHotelLobbyScore = score;
                        console.log("Loaded highest Hotel Lobby score:", window.highestHotelLobbyScore);
                    });
                } else {
                    console.log("Firebase user not signed in.");
                    window.fb.userId = null; // Ensure userId is null if not authenticated
                }
            });
        };

        window.saveHighScoreFirebase = async function(name, score, time, level, levelId) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated.");
                return;
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.fb.appId}/public/data/highScores`);
            try {
                await addDoc(highScoresCollection, {
                    name: name,
                    score: score,
                    survivalTime: time,
                    level: level,
                    levelId: levelId, // Save the level ID
                    timestamp: Date.now(),
                    userId: window.fb.userId
                });
                console.log("High score saved successfully to public high scores!");
            } catch (e) {
                console.error("Error adding document to public high scores: ", e);
            }
        };

        window.getHighScoresFirebase = async function() {
            if (!window.fb.db) {
                console.error("Firestore not initialized.");
                return [];
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.fb.appId}/public/data/highScores`);
            const q = query(highScoresCollection, orderBy("score", "desc"), limit(10));
            
            try {
                const querySnapshot = await getDocs(q);
                const highScores = [];
                querySnapshot.forEach((doc) => {
                    highScores.push(doc.data());
                });
                highScores.sort((a, b) => b.score - a.score); // Client-side sort just in case
                return highScores;
            } catch (e) {
                console.error("Error getting documents from public high scores: ", e);
                return [];
            }
        };

        window.saveUserLevelScore = async function(levelId, score) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated for private data.");
                return;
            }

            const userLevelScoreRef = doc(window.fb.db, `artifacts/${window.fb.appId}/users/${window.fb.userId}/levelScores`, levelId);
            try {
                const docSnap = await getDoc(userLevelScoreRef);
                let currentBestScore = 0;
                if (docSnap.exists()) {
                    currentBestScore = docSnap.data().highestScore || 0;
                }

                if (score > currentBestScore) {
                    await setDoc(userLevelScoreRef, { highestScore: score, timestamp: Date.now() });
                    console.log(`User's highest score for ${levelId} updated to ${score}.`);
                    // Update the global variable if it's for hotel lobby
                    if (levelId === 'hotel_lobby') {
                        window.highestHotelLobbyScore = score;
                    }
                } else {
                    console.log(`Current score ${score} is not higher than existing best ${currentBestScore} for ${levelId}.`);
                }
            } catch (e) {
                console.error(`Error saving user level score for ${levelId}: `, e);
            }
        };

        window.loadUserLevelScore = async function(levelId) {
            if (!window.fb.db || !window.fb.userId) {
                console.warn("Firestore not initialized or user not authenticated for private data. Returning 0 for level score.");
                return 0;
            }

            const userLevelScoreRef = doc(window.fb.db, `artifacts/${window.fb.appId}/users/${window.fb.userId}/levelScores`, levelId);
            try {
                const docSnap = await getDoc(userLevelScoreRef);
                if (docSnap.exists()) {
                    return docSnap.data().highestScore || 0;
                }
                return 0;
            } catch (e) {
                console.error(`Error loading user level score for ${levelId}: `, e);
                return 0;
            }
        };
    </script>

    <script>
        // Get canvas and UI elements from the DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const messageBox = document.getElementById('message-box');
        const powerSelectionDiv = document.getElementById('power-selection');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoreModal = document.getElementById('high-score-modal');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const highScoresList = document.getElementById('high-scores-list');
        const pauseButton = document.getElementById('pauseButton'); 
        const menuButton = document.getElementById('menuButton');     
        const gameMenu = document.getElementById('game-menu');       
        const muteMusicButton = document.getElementById('muteMusicButton'); 
        const resumeFromMenuButton = document.getElementById('resumeFromMenuButton'); 
        const levelSelectButton = document.getElementById('levelSelectButton'); // New
        const levelSelectMenu = document.getElementById('level-select-menu'); // New
        const levelOptionsDiv = document.getElementById('level-options'); // New
        const backToMainMenuButton = document.getElementById('backToMainMenuButton'); // New
        
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');

        // Mini-map elements
        const miniMapCanvas = document.getElementById('miniMapCanvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        let miniMapScale = 1; // Will be calculated in init

        // Game state variables
        let gameRunning = false;
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let particles = []; 
        let gameWorld = {
            width: 3000, 
            height: 3000 
        };
        let gameSpeedMultiplier = 1; 
        let playerSpeedModifier = 1; 
        let projectileSpeedModifier = 1; 
        let bulletTimeActive = false; 
        let bulletTimeDuration = 0; 
        let spinningKnives = []; 
        let femaleAlly = null; 
        let allyDogs = []; 
        let temporaryPowerupActive = false; 
        let temporaryPowerupDuration = 0;
        let temporaryPowerupType = '';
        
        let randomChestSpawnTimer = 0; 
        const RANDOM_CHEST_SPAWN_INTERVAL = 5; 
        const RANDOM_CHEST_SPAWN_CHANCE = 0.011; // Increased by 10% from 0.01
        
        let chests = []; 
        let drones = []; 
        let boomerangs = []; 

        // Camera for a larger game world
        let camera = {
            x: 0,
            y: 0,
            width: 900,
            height: 700,
            zoom: 0.8 
        };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#6A808C', 
            speed: 300, 
            health: 100,
            maxHealth: 100,
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10, 
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 50,
                damageReduction: 0, 
                spinningKnivesDamage: 0, 
                spinningKnivesCount: 0, 
                burstDamage: 0,
                burstProjectileCount: 0,
                droneCount: 0, 
                droneDamage: 0, 
                droneAttackSpeed: 0, 
                shotgunPellets: 0, 
                shotgunDamage: 0, 
                shotgunSpread: 0, 
                dualUziActive: false, 
                dualUziFireRate: 0, 
                dualUziDamage: 0, 
                boomerangDamage: 0, 
                boomerangCount: 0, 
                boomerangCooldown: 4, 
                boomerangRange: 150, 
                boomerangSpeed: 400, 
                burstChargeDamage: 0, 
                burstChargeProjectileCount: 0,
            },
            upgrades: {
                damage: 0,
                attackSpeed: 0,
                health: 0,
                speed: 0,
                pierce: 0,
                multiShot: 0,
                healthRegen: 0,
                magnet: 0,
                bulletproofSuit: 0, 
                ultimateRecharge: 0,
                burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, 
                shotgun: 0, 
                dualUzi: 0,
                boomerang: 0, 
                burstCharge: 0, 
            },
            burstChargeCooldown: 5, 
            burstChargeTimer: 0, 
            burstCooldown: 1,
            burstTimer: 0,
            shotgunTimer: 0, 
            dualUziTimer: 0, 
            boomerangTimer: 0, 
            lastX: initialPlayerX,
            lastY: initialPlayerY,
            animationFrame: 0,
            isMoving: false,
            vx: 0, 
            vy: 0, 
            currentShootAngle: 0, 
        };

        // Game control states
        let isPaused = false; 
        let isMenuOpen = false; 
        let isMusicMuted = false; 
        let lastUziSoundTime = 0; 
        const UZI_SOUND_COOLDOWN = 0.05; 
        let levelUpQueue = []; 

        // Level management
        let currentLevelId = 'hotel_lobby'; // Default starting level
        let highestHotelLobbyScore = 0; // User's highest score for hotel lobby, loaded from Firebase

        // Enemy and power-up configuration
        const ENEMY_TYPES = ['basic', 'fast', 'tank', 'elite', 'gunner', 'drone', 'car', 'ninja', 'enemyDog', 'enemyDrone', 'cobra', 'robotDrone', 'yellowSkull']; 
        const MAX_UPGRADE_LEVEL = 8;
        const POWER_OPTIONS = [
            { id: 'damage', name: 'Increase Damage', description: 'Increases projectile damage.',
              level: () => player.upgrades.damage,
              effect: () => player.stats.damage += 10,
              next: () => `Increase projectile damage by 10. (Lvl ${player.upgrades.damage + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'attackSpeed', name: 'Increase Attack Speed', description: 'Increases the number of projectiles fired per second.',
              level: () => player.upgrades.attackSpeed,
              effect: () => player.stats.attackSpeed += 2,
              next: () => `Increase fire rate by 2. (Lvl ${player.upgrades.attackSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'health', name: 'Increase Health', description: 'Increases max health and heals you.', 
              level: () => player.upgrades.health,
              effect: () => { player.maxHealth += 25; player.health = Math.min(player.health + 25, player.maxHealth); },
              next: () => `Increase max health by 25 and heal. (Lvl ${player.upgrades.health + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'speed', name: 'Increase Speed', description: 'Increases player movement speed.',
              level: () => player.upgrades.speed,
              effect: () => player.speed += 50,
              next: () => `Increase speed by 50. (Lvl ${player.upgrades.speed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'pierce', name: 'Pierce Shot', description: 'Your projectiles can hit multiple enemies.',
              level: () => player.upgrades.pierce,
              effect: () => player.stats.pierce++,
              next: () => `Projectiles can hit one more enemy. (Lvl ${player.upgrades.pierce + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'multiShot', name: 'Multi-shot', description: 'Fire multiple projectiles at once.', 
              level: () => player.upgrades.multiShot,
              effect: () => player.stats.multiShot++,
              next: () => `Fire one more projectile per shot. (Lvl ${player.upgrades.multiShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'healthRegen', name: 'Health Regen', description: 'Gain passive health regeneration.', 
              level: () => player.upgrades.healthRegen,
              effect: () => player.stats.healthRegen += 0.5,
              next: () => `Increase health regen by 0.5/s. (Lvl ${player.upgrades.healthRegen + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'magnet', name: 'Magnet Range', description: 'Increases the range for collecting XP.',
              level: () => player.upgrades.magnet,
              effect: () => player.stats.magnet += 20,
              next: () => `Increase magnet range by 20. (Lvl ${player.upgrades.magnet + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'bulletproofSuit', name: 'Bulletproof Suit', description: 'Reduces damage taken from all sources.',
              level: () => player.upgrades.bulletproofSuit,
              effect: () => {
                player.upgrades.bulletproofSuit++;
                player.stats.damageReduction = Math.min(0.8, player.upgrades.bulletproofSuit * 0.05); 
              },
              next: () => `Reduce damage taken by ${((player.upgrades.bulletproofSuit + 1) * 5).toFixed(0)}%. (Lvl ${player.upgrades.bulletproofSuit + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'burstCharge', name: 'Burst Charge', description: 'Unleashes a slow, wide arc of projectiles automatically.', 
              level: () => player.upgrades.burstCharge,
              effect: () => { 
                player.upgrades.burstCharge++;
                player.stats.burstChargeDamage = 50 + player.upgrades.burstCharge * 25; 
                player.stats.burstChargeProjectileCount = 5 + player.upgrades.burstCharge * 2;
                player.burstChargeCooldown = Math.max(1, 5 - player.upgrades.burstCharge * 0.5); 
                player.burstChargeTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.burstCharge + 1) * 2} projectiles in a wide arc. Cooldown: ${(Math.max(1, 5 - (player.upgrades.burstCharge + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.burstCharge + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'ultimateRecharge', name: 'Ultimate Recharge Speed', description: 'The ultimate ability recharges faster.',
              level: () => player.upgrades.ultimateRecharge,
              effect: () => ultimateChargePerHit += 0.2,
              next: () => `Ultimate charges faster per hit. (Lvl ${player.upgrades.ultimateRecharge + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'burstShot', name: 'Multi-shot Burst', description: 'Fires a burst of projectiles in a circle.',
              level: () => player.upgrades.burstShot,
              effect: () => {
                player.stats.burstDamage = 10 + player.upgrades.burstShot * 5;
                player.stats.burstProjectileCount = 8 + player.upgrades.burstShot * 2;
                player.burstCooldown = 1 - (player.upgrades.burstShot * 0.1);
              },
              next: () => `Fires a circle of projectiles. (Lvl ${player.upgrades.burstShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'spinningKnives', name: 'Spinning Knives', description: 'Summon knives that orbit you, damaging enemies.',
              level: () => player.upgrades.spinningKnives,
              effect: () => {
                player.upgrades.spinningKnives++;
                player.stats.spinningKnivesCount++;
                player.stats.spinningKnivesDamage = 15 + player.upgrades.spinningKnives * 5;
                updateSpinningKnivesEffect();
              },
              next: () => `Summon ${player.upgrades.spinningKnives + 1} spinning knives. (Lvl ${player.upgrades.spinningKnives + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'combatDrone', name: 'Combat Drone', description: 'Summon a drone that fires at enemies. Stacks.',
              level: () => player.upgrades.combatDrone,
              effect: () => {
                player.upgrades.combatDrone++;
                player.stats.droneCount = player.upgrades.combatDrone; 
                player.stats.droneDamage = 10 + player.upgrades.combatDrone * 5; 
                player.stats.droneAttackSpeed = 1 + player.upgrades.combatDrone * 0.2; 
                updateDronesEffect(); 
              },
              next: () => `Summon ${player.upgrades.combatDrone + 1} combat drone(s). (Lvl ${player.upgrades.combatDrone + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'shotgun', name: 'Shotgun', description: 'Fires a spray of powerful, short-range pellets.', 
              level: () => player.upgrades.shotgun,
              effect: () => {
                player.upgrades.shotgun++;
                player.stats.shotgunPellets = 5 + player.upgrades.shotgun * 2;
                player.stats.shotgunDamage = 15 + player.upgrades.shotgun * 5;
                player.stats.shotgunSpread = 0.4; 
                player.shotgunTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.shotgun + 1) * 2} pellets with a short range. (Lvl ${player.upgrades.shotgun + 1}/${MAX_UPGRADE_LEVEL})`, 
            },
            { id: 'dualUzi', name: 'Dual Uzis', description: 'Fires two continuous streams of bullets.',
              level: () => player.upgrades.dualUzi,
              effect: () => {
                player.upgrades.dualUzi++;
                player.stats.dualUziActive = true;
                player.stats.dualUziFireRate = 8 + player.upgrades.dualUzi * 4; 
                player.stats.dualUziDamage = 2 + player.upgrades.dualUzi * 1.5; 
                player.dualUziTimer = 0; 
              },
              next: () => `Fires two streams at ${8 + (player.upgrades.dualUzi + 1) * 4} bullets/s. (Lvl ${player.upgrades.dualUzi + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'boomerang', name: 'Boomerang', description: 'Launches a spinning boomerang that hits enemies and returns.',
              level: () => player.upgrades.boomerang,
              effect: () => {
                player.upgrades.boomerang++;
                player.stats.boomerangCount = 1 + Math.floor(player.upgrades.boomerang / 2); 
                player.stats.boomerangDamage = 25 + player.upgrades.boomerang * 10;
                player.stats.boomerangCooldown = Math.max(1, 4 - player.upgrades.boomerang * 0.5); 
              },
              next: () => `Launch ${1 + Math.floor((player.upgrades.boomerang + 1) / 2)} boomerangs. Cooldown: ${(Math.max(1, 4 - (player.upgrades.boomerang + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.boomerang + 1}/${MAX_UPGRADE_LEVEL})`,
            }
        ];
        
        let shootTimer = 0;
        let spawnTimer = 0;
        let ultimateChargePerHit = 0.5; 
        let lastShotSoundTime = 0;
        let lastEnemyHitSoundTime = 0;
        const enemyHitSoundCooldown = 0.05;


        // Tone.js audio setup
        let playerSynth;
        let enemyHitSynth;
        let levelUpSynth;
        let ultimateSynth;
        let gameOverSynth;
        let backgroundMusicSynth;
        let backgroundMusicSequence;
        let bassSynth;
        let bassSequence;
        let explosionSound;

        // Music pattern variables
        const BACKGROUND_MUSIC_PATTERNS = [
            [["C3", "G3"], ["A#3", "F3"], ["C4", "G3"], ["D#4", "A#3"]],
            [["D3", "A3"], ["C4", "G3"], ["D4", "A3"], ["F4", "C4"]],
            [["E3", "B3"], ["D3", "A3"], ["E4", "B3"], ["G4", "D4"]]
        ];
        const BASS_MUSIC_PATTERNS = [
            ["C1", "G0", "C1", "F0"],
            ["D1", "A0", "D1", "G0"],
            ["E1", "B0", "E1", "A0"]
        ];
        let currentMusicPatternIndex = 0;
        let musicPatternTimer = 0;
        const MUSIC_PATTERN_CHANGE_INTERVAL = 20;

        // Helper function to calculate distance
        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // --- New Collision Resolution Functions ---

        // Resolves collision between two circles (e.g., player/enemy and pillar)
        function circleCircleCollideAndResolve(c1, c2) {
            let dx = c1.x - c2.x;
            let dy = c1.y - c2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = c1.size / 2 + c2.size / 2; // c2.size is diameter for pillar, so c2.size/2 is radius

            if (distance < minDistance) {
                if (distance === 0) { // Objects are exactly on top of each other, push randomly to prevent infinite loop
                    c1.x += Math.random() * 0.1 - 0.05;
                    c1.y += Math.random() * 0.1 - 0.05;
                    return true;
                }
                let overlap = minDistance - distance;
                let normalX = dx / distance;
                let normalY = dy / distance;

                // Push c1 out of c2
                c1.x += normalX * overlap;
                c1.y += normalY * overlap;

                // Slide along the surface (project velocity onto tangent)
                let dotProduct = c1.vx * normalX + c1.vy * normalY;
                if (dotProduct < 0) { // Only if moving towards the obstacle
                    c1.vx -= dotProduct * normalX;
                    c1.vy -= dotProduct * normalY;
                }
                return true;
            }
            return false;
        }

        // Resolves collision between a circle and a rectangle (e.g., player/enemy and desk/chair)
        function circleRectCollideAndResolve(circle, rect) {
            // Find the closest point on the rectangle to the center of the circle
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let dx = circle.x - closestX;
            let dy = circle.y - closestY;
            let distanceSquared = (dx * dx) + (dy * dy);
            let radius = circle.size / 2;

            if (distanceSquared < radius * radius) {
                let distance = Math.sqrt(distanceSquared);
                if (distance === 0) { // Circle center is inside rectangle
                    // Push out along the axis with least penetration
                    let overlapX = Math.min(Math.abs(circle.x - rect.x), Math.abs((rect.x + rect.width) - circle.x));
                    let overlapY = Math.min(Math.abs(circle.y - rect.y), Math.abs((rect.y + rect.height) - circle.y));

                    if (overlapX < overlapY) {
                        circle.x += (circle.x > rect.x + rect.width / 2 ? 1 : -1) * (radius - Math.abs(dx));
                    } else {
                        circle.y += (circle.y > rect.y + rect.height / 2 ? 1 : -1) * (radius - Math.abs(dy));
                    }
                } else {
                    let overlap = radius - distance;
                    let normalX = dx / distance;
                    let normalY = dy / distance;

                    // Push circle out of rectangle
                    circle.x += normalX * overlap;
                    circle.y += normalY * overlap;

                    // Slide along the surface
                    let dotProduct = circle.vx * normalX + circle.vy * normalY;
                    if (dotProduct < 0) { // Only if moving into the obstacle
                        circle.vx -= dotProduct * normalX;
                        circle.vy -= dotProduct * normalY;
                    }
                }
                return true;
            }
            return false;
        }

        // --- End Collision Resolution Functions ---

        // Function to play sound effects
        function playSound(type) {
            // Do not play sounds if music is muted
            if (isMusicMuted && (type === 'playerShot' || type === 'enemyHit' || type === 'levelUp' || type === 'ultimateActivate' || type === 'gameOver' || type === 'explosion')) {
                return;
            }

            switch(type) {
                case 'playerShot':
                    playerSynth.triggerAttackRelease("C4", "8n");
                    break;
                case 'enemyHit':
                    enemyHitSynth.triggerAttackRelease("16n");
                    break;
                case 'levelUp':
                    levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5
                }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.1, decay: 0.5, sustain: 0.3, release: 1
                }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            backgroundMusicSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
                envelope: {
                    attack: 2, decay: 1, sustain: 0.8, release: 3
                },
                volume: -25.5 
            }).toDestination();

            bassSynth = new Tone.Synth({
                oscillator: { type: "fatsawtooth", count: 4, spread: 40 },
                envelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.8, release: 1.0
                },
                filter: {
                    type: 'lowpass', frequency: 300, Q: 1.5
                },
                filterEnvelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5, baseFrequency: 200, octaves: 1
                },
                volume: -18.5 
            }).toDestination();

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001, decay: 0.4, release: 0.2
                },
                harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;

            updateMusicPatterns(0);
        }

        function updateMusicPatterns(patternIndex) {
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); 
                backgroundMusicSequence.dispose();
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); 
                bassSequence.dispose();
            }

            backgroundMusicSequence = new Tone.Sequence((time, note) => {
                backgroundMusicSynth.triggerAttackRelease(note, "2n", time);
            }, BACKGROUND_MUSIC_PATTERNS[patternIndex], "4n");
            backgroundMusicSequence.loop = true;
            backgroundMusicSequence.playbackRate = 1;
            backgroundMusicSequence.humanize = true;

            bassSequence = new Tone.Sequence((time, note) => {
                bassSynth.triggerAttackRelease(note, "2n", time);
            }, BASS_MUSIC_PATTERNS[patternIndex], "2n");
            bassSequence.loop = true;
            bassSequence.playbackRate = 1;
            bassSequence.humanize = true;

            if (gameRunning && !isPaused && !isMenuOpen && !isMusicMuted) {
                backgroundMusicSequence.start(0);
                bassSequence.start(0);
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Apply camera zoom to the context
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            
            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); 
            drawEnemies();
            drawPlayer();
            drawSpinningKnives(); 
            drawFemaleAllyAndDogs(); 
            drawDrones(); 
            drawBoomerangs(); 
            if (ultimateActive) {
                drawUltimateEffect();
            }
            drawDamageNumbers();
            drawParticles(); 

            ctx.restore(); 
            drawUI();
            drawMiniMap(); 
        }
        
        function drawBackground() {
            let bgColor;
            if (currentLevelId === 'hotel_lobby') {
                bgColor = '#101010'; // Dark grey for hotel lobby
            } else if (currentLevelId === 'the_park') {
                bgColor = '#225522'; // Green for park
            } else {
                bgColor = '#101010'; // Default
            }

            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); 

            const patternSize = 50;
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 1;

            const startX = -camera.x % patternSize;
            const startY = -camera.y % patternSize;

            for (let x = startX; x < camera.width / camera.zoom; x += patternSize) {
                for (let y = startY; y < camera.height / camera.zoom; y += patternSize) {
                    ctx.beginPath();
                    ctx.rect(x, y, patternSize, patternSize);
                    ctx.stroke();
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree') { // 'tree' is also circular
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair' || obstacle.type === 'bush' || obstacle.type === 'bench') { // 'bush' and 'bench' are rectangular
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                }
            });
        }
        
        function drawPixelArt(ctx, x, y, spriteName, frame, size, isMoving) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;

            if (spriteName === 'player') {
                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                // Body
                ctx.fillStyle = player.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Legs
                if (isMoving) {
                    const legOffset = Math.sin(frame * 0.5) * s/4; 
                    ctx.fillStyle = player.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    ctx.fillStyle = player.color; 
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                }

                // Arms - dynamic, facing shoot direction
                const armLength = s * 0.8;
                const armWidth = s * 0.3;
                const shoulderXOffset = s * 0.4; 
                const shoulderYOffset = s * 0.5; 

                ctx.fillStyle = player.color; 

                // Left Arm
                ctx.save();
                ctx.translate(screenX - shoulderXOffset, screenY - shoulderYOffset);
                ctx.rotate(player.currentShootAngle);
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

                // Right Arm
                ctx.save();
                ctx.translate(screenX + shoulderXOffset, screenY - shoulderYOffset);
                ctx.rotate(player.currentShootAngle);
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;

            // Draw glowing green aura for allied characters
            if (enemy.controlled) {
                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 
            }

            if (enemy.type === 'robotDrone') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(screenX - s * 0.4, screenY - s * 0.1, s * 0.8, s * 0.2); 
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.4, s * 0.2, s * 0.8); 
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'yellowSkull') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY - s * 0.5, s * 0.4, 0, Math.PI * 2); 
                ctx.fill();

                ctx.fillStyle = '#000000'; 
                ctx.beginPath();
                ctx.arc(screenX - s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(screenX + s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.3, s * 0.2, s * 0.1); 
                ctx.fillRect(screenX - s * 0.2, screenY - s * 0.1, s * 0.4, s * 0.05); 
            }
            else {
                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);
                
                // Body
                ctx.fillStyle = enemy.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Arms (simplified, similar to player)
                ctx.fillRect(screenX - s/2 - s/4, screenY - s, s/4, s); 
                ctx.fillRect(screenX + s/2, screenY - s, s/4, s); 
                
                // Legs (animated, similar to player)
                const isEnemyMoving = Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0;
                if (isEnemyMoving) {
                    const legOffset = Math.sin(enemy.animationFrame * 0.5) * s/4; 
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                }

                if (enemy.type === 'tank') {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                } else if (enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone') { 
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
                } else if (enemy.type === 'elite') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (enemy.type === 'car') {
                    ctx.fillStyle = '#663300'; 
                    ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                } else if (enemy.type === 'ninja') {
                    ctx.fillStyle = '#333333'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                    ctx.fillStyle = '#1a1a1a'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
                } else if (enemy.type === 'enemyDog') {
                    ctx.fillStyle = enemy.color; 
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (enemy.type === 'enemyDrone') {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    ctx.fillStyle = '#666666'; 
                    ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                    ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
                } else if (enemy.type === 'cobra') {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    if (enemy.segmentIndex === 0) {
                        ctx.fillStyle = '#FFD700'; 
                        ctx.beginPath();
                        ctx.arc(screenX + s/2, screenY, s/4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw "A" above allied characters
            if (enemy.controlled) {
                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            }
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size, player.isMoving);

            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;

            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                
                drawEnemyPixelArt(ctx, enemy);
            });
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();

                if (p.isAoE) {
                    const opacity = 0.5 * (1 - (p.lifetime / p.maxLifetime)); 
                    ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.aoeRadius * (1 - opacity), 0, Math.PI * 2); 
                    ctx.stroke();
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FFD700'; 
                ctx.shadowColor = '#FFA500'; 
                ctx.shadowBlur = 8; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); 
                ctx.fill();
                ctx.shadowBlur = 0; 
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; 
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; 
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);
            });
        }

        function drawSpinningKnives() {
            spinningKnives.forEach(knife => {
                const screenX = knife.x - camera.x;
                const screenY = knife.y - camera.y;
                ctx.fillStyle = '#AAAAAA'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, knife.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawFemaleAllyAndDogs() {
            if (femaleAlly) {
                const s = femaleAlly.size;
                const screenX = femaleAlly.x - camera.x;
                const screenY = femaleAlly.y - camera.y;

                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 

                // Female character pixel art
                ctx.fillStyle = '#f0c8a0'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                ctx.fillStyle = '#5C4033'; 
                ctx.fillRect(screenX - s/2, screenY - s*1.7, s, s*0.5); 
                ctx.fillRect(screenX + s/4, screenY - s*1.5, s/4, s*0.8); 

                ctx.fillStyle = '#8B0000'; 
                ctx.fillRect(screenX - s/3, screenY - s, s*2/3, s*1.8); 

                const armLength = s * 0.6;
                const armWidth = s * 0.2;
                const shoulderXOffset = s * 0.3;
                const shoulderYOffset = s * 0.5;

                ctx.fillStyle = '#8B0000'; 

                ctx.save();
                ctx.translate(screenX - shoulderXOffset, screenY - shoulderYOffset);
                ctx.rotate(femaleAlly.currentShootAngle);
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

                ctx.save();
                ctx.translate(screenX + shoulderXOffset, screenY - shoulderYOffset);
                ctx.rotate(femaleAlly.currentShootAngle);
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            }

            allyDogs.forEach(dog => {
                const s = dog.size;
                const screenX = dog.x - camera.x;
                const screenY = dog.y - camera.y;

                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 

                ctx.fillStyle = '#8B4513'; 
                ctx.beginPath();
                ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(screenX + s * 0.3, screenY - s * 0.4);
                ctx.lineTo(screenX + s * 0.5, screenY - s * 0.6);
                ctx.lineTo(screenX + s * 0.6, screenY - s * 0.3);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(screenX - s * 0.6, screenY + s * 0.1);
                ctx.lineTo(screenX - s * 0.8, screenY - s * 0.1);
                ctx.lineTo(screenX - s * 0.7, screenY + s * 0.2);
                ctx.fill();

                ctx.fillRect(screenX - s * 0.4, screenY + s * 0.4, s * 0.15, s * 0.3);
                ctx.fillRect(screenX + s * 0.2, screenY + s * 0.4, s * 0.15, s * 0.3);

                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            });
        }

        function drawDrones() {
            drones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;

                ctx.fillStyle = '#00FFFF'; 
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                ctx.fillStyle = '#666666'; 
                ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
            });
        }

        function drawBoomerangs() {
            boomerangs.forEach(b => {
                const screenX = b.x - camera.x;
                const screenY = b.y - camera.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 8); 
                
                ctx.fillStyle = b.color; 
                const bananaWidth = b.size * 0.6; 
                const bananaLength = b.size * 2; 

                ctx.beginPath();
                ctx.moveTo(0, -bananaWidth / 2);
                ctx.bezierCurveTo(
                    bananaLength * 0.5, -bananaWidth * 1.5, 
                    bananaLength * 0.5, bananaWidth * 1.5,  
                    0, bananaWidth / 2                      
                );
                ctx.bezierCurveTo(
                    -bananaLength * 0.5, bananaWidth * 1.5, 
                    -bananaLength * 0.5, -bananaWidth * 1.5, 
                    0, -bananaWidth / 2                     
                );
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }
        
        function drawUltimateEffect() {
            ctx.beginPath();
            const pulseSize = player.size * (1 + 0.5 * Math.sin(survivalTime * 10));
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.arc(screenX, screenY, pulseSize * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.5 * (ultimateDuration/3)})`; 
            ctx.lineWidth = 10;
            ctx.stroke();

            ctx.fillStyle = `rgba(255, 102, 0, ${0.1 * (ultimateDuration/3)})`; 
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); 
        }

        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `Time: ${minutes}:${seconds}`;
            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
            ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;

            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateButton.classList.add('ready');
            } else {
                ultimateButton.classList.remove('ready');
            }

            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }
        
        function showDamageNumber(damage, x, y) {
            damageNumbers.push({
                x: x,
                y: y,
                text: Math.round(damage),
                lifetime: 1
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const screenX = d.x - camera.x;
                const screenY = d.y - camera.y;
                ctx.fillStyle = `rgba(255, 50, 50, ${d.lifetime})`;
                ctx.font = `14px 'Chakra Petch'`;
                ctx.textAlign = 'center';
                ctx.fillText(d.text, screenX, screenY);
            });
        }

        function drawParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }

        function drawMiniMap() {
            miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#1a1a1a';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#444444'; 
            obstacles.forEach(obstacle => {
                const miniX = obstacle.x * miniMapScale;
                const miniY = obstacle.y * miniMapScale;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree') {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(miniX, miniY, obstacle.width / 2 * miniMapScale, 0, Math.PI * 2);
                    miniMapCtx.fill();
                } else {
                    miniMapCtx.fillRect(miniX, miniY, obstacle.width * miniMapScale, obstacle.height * miniMapScale);
                }
            });

            miniMapCtx.fillStyle = '#ff0000'; 
            enemies.forEach(enemy => {
                const miniX = enemy.x * miniMapScale;
                const miniY = enemy.y * miniMapScale;
                miniMapCtx.fillStyle = enemy.controlled ? '#00ff66' : '#ff0000'; 
                miniMapCtx.beginPath();
                miniMapCtx.arc(miniX, miniY, enemy.size / 2 * miniMapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            const miniPlayerX = player.x * miniMapScale;
            const miniPlayerY = player.y * miniMapScale;
            miniMapCtx.fillStyle = '#00ffff'; 
            miniMapCtx.beginPath();
            miniMapCtx.arc(miniPlayerX, miniPlayerY, player.size / 2 * miniMapScale, 0, Math.PI * 2);
            miniMapCtx.fill();

            // Draw chests as larger icons on the mini-map
            chests.forEach(chest => {
                const miniX = chest.x * miniMapScale;
                const miniY = chest.y * miniMapScale;
                const chestMiniSize = chest.size * miniMapScale * 1.5; // Make chest icon larger
                miniMapCtx.fillStyle = '#FFD700'; 
                miniMapCtx.fillRect(miniX - chestMiniSize / 2, miniY - chestMiniSize / 2, chestMiniSize, chestMiniSize);
            });
        }

        function showStartMenu() {
            startMenu.style.display = 'block';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; // Ensure level select is hidden
        }
        
        function showGameOverMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'block';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; // Ensure level select is hidden
        }

        function showLevelSelectMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none';
            messageBox.style.display = 'none';
            levelSelectMenu.style.display = 'block';
            populateLevelOptions();
        }

        function populateLevelOptions() {
            levelOptionsDiv.innerHTML = ''; // Clear existing options

            const levels = [
                { id: 'hotel_lobby', name: 'Hotel Lobby', unlockScore: 0, description: 'The classic battleground.' },
                { id: 'the_park', name: 'The Park', unlockScore: 6000, description: 'A green oasis, full of danger.' }
            ];

            levels.forEach(level => {
                const card = document.createElement('div');
                card.className = 'level-card';
                card.innerHTML = `<h3>${level.name}</h3><p>${level.description}</p>`;

                let isLocked = false;
                if (level.id === 'the_park' && highestHotelLobbyScore < level.unlockScore) {
                    isLocked = true;
                    card.classList.add('locked');
                    const unlockInfo = document.createElement('p');
                    unlockInfo.className = 'unlock-info';
                    unlockInfo.textContent = `Unlock: ${level.unlockScore} Score in Hotel Lobby (Your Best: ${highestHotelLobbyScore})`;
                    card.appendChild(unlockInfo);
                }

                if (!isLocked) {
                    card.addEventListener('click', () => {
                        currentLevelId = level.id;
                        startGame();
                    });
                }
                levelOptionsDiv.appendChild(card);
            });
        }
        
        function updatePlayer(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            player.isMoving = distance > 5;
            if (player.isMoving) {
                const angle = Math.atan2(dy, dx);
                const currentSpeed = player.speed * (ultimateActive ? playerSpeedModifier : 1);
                player.vx = Math.cos(angle) * currentSpeed;
                player.vy = Math.sin(angle) * currentSpeed;
            } else {
                player.vx = 0; 
                player.vy = 0; 
            }

            let newX = player.x + player.vx * effectiveDt;
            let newY = player.y + player.vy * effectiveDt;

            let tempPlayer = {
                x: newX,
                y: newY,
                size: player.size,
                vx: player.vx,
                vy: player.vy
            };
            
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'pillar' || obstacle.type === 'tree') {
                    let obstacleCircle = {
                        x: obstacle.x,
                        y: obstacle.y,
                        size: obstacle.width 
                    };
                    circleCircleCollideAndResolve(tempPlayer, obstacleCircle);
                } else { 
                    circleRectCollideAndResolve(tempPlayer, obstacle);
                }
            });

            player.x = tempPlayer.x;
            player.y = tempPlayer.y;
            player.vx = tempPlayer.vx; 
            player.vy = tempPlayer.vy;

            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
            
            if (player.isMoving) {
                player.animationFrame = (player.animationFrame + effectiveDt * 10) % 4;
            } else {
                player.animationFrame = 0;
            }
        
            player.health += player.stats.healthRegen * effectiveDt;
            player.health = Math.min(player.health + player.stats.healthRegen * effectiveDt, player.maxHealth);
        
            if (player.upgrades.burstCharge > 0 && player.burstChargeTimer <= 0) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; 
                    const numProjectiles = player.stats.burstChargeProjectileCount;
                    const arcSpread = 0.8; 
                    const angleStep = arcSpread / (numProjectiles > 1 ? (numProjectiles - 1) : 1);
                    const startAngle = angle - arcSpread / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const projectileAngle = startAngle + i * angleStep;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            vy: Math.sin(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            size: 5, 
                            damage: ultimateActive ? player.stats.burstChargeDamage * 3 : player.stats.burstChargeDamage,
                            color: ultimateActive ? '#ff9933' : '#00ffff', 
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    player.burstChargeTimer = player.burstChargeCooldown;
                    playSound('playerShot'); 
                }
            }
        
            if (shootTimer >= 1 / player.stats.attackSpeed) {
                const closestEnemy = findClosestEnemy();
                
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; 
                    
                    let currentMultiShot = player.stats.multiShot;
                    let currentProjectileSpeed = player.stats.projectileSpeed;
                    let currentDamage = player.stats.damage;

                    if (temporaryPowerupType === 'spreadGun') {
                        currentMultiShot = 5; 
                        currentProjectileSpeed = 300; 
                        currentDamage = player.stats.damage * 0.75; 
                    }

                    for (let i = 0; i < currentMultiShot; i++) {
                        const spread = (i - (currentMultiShot - 1) / 2) * 0.1; 
                        const projectileAngle = angle + spread;
                        
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            vy: Math.sin(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            size: 3,
                            damage: ultimateActive ? currentDamage * 3 : currentDamage,
                            color: ultimateActive ? '#ff6600' : '#d1d1d1',
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    if (survivalTime - lastShotSoundTime >= 5) {
                        playSound('playerShot'); 
                        lastShotSoundTime = survivalTime;
                    }
                }
                
                shootTimer = 0;
            }

            if (player.stats.burstDamage > 0 && player.burstTimer >= player.burstCooldown) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); 
                }
                const numProjectiles = player.stats.burstProjectileCount;
                const angleStep = (Math.PI * 2) / numProjectiles;
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = i * angleStep;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        vy: Math.sin(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        size: 3,
                        damage: player.stats.burstDamage,
                        color: ultimateActive ? '#ff6600' : '#d1d1d1',
                        pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                        hits: 0
                    });
                }
                player.burstTimer = 0;
                if (survivalTime - lastShotSoundTime >= 5) {
                    playSound('playerShot'); 
                    lastShotSoundTime = survivalTime;
                }
            }

            if (player.upgrades.shotgun > 0) {
                player.shotgunTimer += effectiveDt;
                const shotgunCooldown = 0.8 / (1 + player.upgrades.shotgun * 0.1); 
                if (player.shotgunTimer >= shotgunCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy && dist(player, closestEnemy) < 200) { 
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; 
                        for (let i = 0; i < player.stats.shotgunPellets; i++) {
                            const spread = (i - (player.stats.shotgunPellets - 1) / 2) * player.stats.shotgunSpread;
                            const projectileAngle = angle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 300, 
                                vy: Math.sin(projectileAngle) * 300,
                                size: 5,
                                damage: player.stats.shotgunDamage,
                                color: '#FFA500', 
                                pierce: 0, 
                                hits: 0,
                                lifetime: 0.3, 
                                maxLifetime: 0.3 
                            });
                        }
                        playSound('playerShot'); 
                        player.shotgunTimer = 0;
                    }
                }
            }

            if (player.stats.dualUziActive) {
                player.dualUziTimer += effectiveDt;
                const uziCooldown = 1 / player.stats.dualUziFireRate;
                if (player.dualUziTimer >= uziCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; 
                        const offset = 10; 
                        
                        projectiles.push({
                            x: player.x + Math.cos(angle - Math.PI/2) * offset,
                            y: player.y + Math.sin(angle - Math.PI/2) * offset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        projectiles.push({
                            x: player.x + Math.cos(angle + Math.PI/2) * offset,
                            y: player.y + Math.sin(angle + Math.PI/2) * offset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        if (survivalTime - lastUziSoundTime >= UZI_SOUND_COOLDOWN) {
                            playSound('playerShot'); 
                            lastUziSoundTime = survivalTime;
                        }
                    }
                    player.dualUziTimer = 0;
                }
            }

            if (player.stats.boomerangCount > 0) {
                player.boomerangTimer += effectiveDt;
                if (player.boomerangTimer >= player.stats.boomerangCooldown) {
                    const closestEnemy = findClosestEnemy(); 
                    if (closestEnemy) {
                        player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); 
                    }
                    const numBoomerangs = player.stats.boomerangCount;
                    const angleStep = (Math.PI * 2) / numBoomerangs; 
                    for (let i = 0; i < numBoomerangs; i++) {
                        const initialAngle = Math.random() * Math.PI * 2; 
                        boomerangs.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(initialAngle) * player.stats.boomerangSpeed,
                            vy: Math.sin(initialAngle) * player.stats.boomerangSpeed,
                            size: 15, 
                            damage: player.stats.boomerangDamage,
                            color: '#FFFF00', 
                            distanceTraveled: 0,
                            returning: false,
                            hitEnemies: new Set(), 
                            maxOutwardDistance: player.stats.boomerangRange,
                            speed: player.stats.boomerangSpeed
                        });
                    }
                    player.boomerangTimer = 0;
                }
            }
        }

        function findClosestEnemy() {
            let closest = null;
            let minDistance = Infinity;

            enemies.forEach(enemy => {
                const distance = dist(player, enemy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function activateUltimate() {
            ultimateActive = true;
            ultimateDuration = 1.5; 
            player.color = '#ff6600'; 
            ultimateCharge = 0;
            playSound('ultimateActivate');

            gameSpeedMultiplier = 0.25; 
            playerSpeedModifier = 3; 
            projectileSpeedModifier = 3;
            if (!isMusicMuted) Tone.Transport.playbackRate = 0.5; 
        }
        
        function updateEnemies(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        
            enemies = enemies.filter(enemy => {
                let angle;

                const prevX = enemy.x;
                const prevY = enemy.y;

                if (enemy.controlled) {
                    const closestEnemy = enemies
                        .filter(e => !e.controlled)
                        .sort((a, b) => dist(enemy, a) - dist(enemy, b))[0];
                    if (closestEnemy) {
                        angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - closestEnemy.x);
                    } else {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    }
                } else if (enemy.type === 'cobra') {
                    if (enemy.segmentIndex === 0) { 
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed; 
                    } else { 
                        const prevSegment = enemies.find(e => e.snakeId === enemy.snakeId && e.segmentIndex === enemy.segmentIndex - 1);
                        if (prevSegment) {
                            const dx = prevSegment.x - enemy.x;
                            const dy = prevSegment.y - enemy.y;
                            const segmentDistance = Math.sqrt(dx*dx + dy*dy);
                            const minSegmentDistance = enemy.size * 1.2; 
                            
                            if (segmentDistance > minSegmentDistance) {
                                angle = Math.atan2(dy, dx);
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0;
                                enemy.vy = 0;
                            }
                        } else {
                            enemy.vx = 0;
                            enemy.vy = 0;
                        }
                    }
                } else if (enemy.type === 'robotDrone') {
                    angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2 + 10)) { 
                        explodeRobotDrone(enemy);
                        return false; 
                    }
                } else { 
                    const distance = dist(player, enemy);
                    if ((enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone' || enemy.type === 'enemyDrone') && distance < enemy.attackRange) {
                        angle = Math.atan2(player.y - enemy.y, player.x - player.x);
                        enemy.shootTimer += effectiveDt; 
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            const isBazooka = survivalTime > 300 || player.level > 5; 
                            
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * enemy.projectileSpeed,
                                vy: Math.sin(angle) * enemy.projectileSpeed,
                                size: isBazooka ? 15 : enemy.projectileSize, 
                                damage: isBazooka ? enemy.projectileDamage * 2 : enemy.projectileDamage, 
                                color: '#FF0000', 
                                hits: 0,
                                isAoE: isBazooka, 
                                aoeRadius: isBazooka ? 70 : 0, 
                                lifetime: isBazooka ? 1 : 0, 
                                maxLifetime: isBazooka ? 1 : 0 
                            });
                            enemy.shootTimer = 0;
                        }
                        enemy.vx = 0; 
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        
                        if (enemy.type !== 'gunner' && Math.random() < 0.01) { 
                            enemy.flankAngle = (Math.random() - 0.5) * Math.PI / 2;
                        }
                        if (enemy.flankAngle !== undefined) {
                            angle += enemy.flankAngle;
                        }
                    }
                }

                if (enemy.type !== 'cobra' || enemy.segmentIndex === 0) { 
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                }
                

                let tempEnemy = {
                    x: enemy.x + enemy.vx * effectiveDt, 
                    y: enemy.y + enemy.vy * effectiveDt, 
                    size: enemy.size,
                    vx: enemy.vx,
                    vy: enemy.vy
                };

                if (!enemy.ghostModeActive) {
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar' || obstacle.type === 'tree') {
                            let obstacleCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempEnemy, obstacleCircle);
                        } else {
                            circleRectCollideAndResolve(tempEnemy, obstacle);
                        }
                    });
                }


                enemy.x = tempEnemy.x;
                enemy.y = tempEnemy.y;
                enemy.vx = tempEnemy.vx; 
                enemy.vy = tempEnemy.vy;

                const movedDistance = dist({x: prevX, y: prevY}, {x: enemy.x, y: enemy.y});
                const stuckThreshold = 1; 

                if (movedDistance < stuckThreshold) {
                    enemy.stuckTimer += effectiveDt;
                    if (enemy.stuckTimer >= 2 && !enemy.ghostModeActive) { 
                        enemy.ghostModeActive = true;
                        enemy.ghostModeTimer = 1; 
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} entered ghost mode!`);
                    }
                } else {
                    enemy.stuckTimer = 0; 
                }

                if (enemy.ghostModeActive) {
                    enemy.ghostModeTimer -= effectiveDt;
                    if (enemy.ghostModeTimer <= 0) {
                        enemy.ghostModeActive = false;
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} exited ghost mode.`);
                    }
                }

                if (Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0) {
                    enemy.animationFrame = (enemy.animationFrame + effectiveDt * 10) % 4;
                } else {
                    enemy.animationFrame = 0;
                }

                enemy.x = Math.max(-100, Math.min(gameWorld.width + 100, enemy.x)); 
                enemy.y = Math.max(-100, Math.min(gameWorld.height + 100, enemy.y));
        
                return enemy.x > -150 && enemy.x < gameWorld.width + 150 && 
                       enemy.y > -150 && enemy.y < gameWorld.height + 150;
            });

            const cobraIds = new Set(enemies.filter(e => e.type === 'cobra').map(e => e.snakeId));
            cobraIds.forEach(id => {
                let segments = enemies.filter(e => e.snakeId === id).sort((a, b) => a.segmentIndex - b.segmentIndex);
                segments.forEach((segment, index) => {
                    segment.segmentIndex = index; 
                });
            });
        }
        
        function updateProjectiles(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            projectiles = projectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.lifetime !== undefined) {
                    p.lifetime -= effectiveDt;
                }
                
                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && p.hits <= p.pierce && (p.lifetime === undefined || p.lifetime > 0); 
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.isAoE) {
                    p.lifetime -= effectiveDt;
                }

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && (!p.isAoE || p.lifetime > 0);
            });
        }
        
        function updatePowerups(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            powerups = powerups.filter(p => {
                const distance = dist(player, p);
                if (distance < player.stats.magnet) {
                    const angle = Math.atan2(player.y - p.y, player.x - p.x);
                    p.x += Math.cos(angle) * p.speed * effectiveDt; 
                    p.y += Math.sin(angle) * p.speed * effectiveDt; 
                }
                return true;
            });
        }

        function updateChests(dt) {
            chests = chests.filter(chest => {
                return true;
            });
        }
        
        function updateDamageNumbers(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            damageNumbers = damageNumbers.filter(d => {
                d.y -= 20 * effectiveDt; 
                d.lifetime -= effectiveDt; 
                return d.lifetime > 0;
            });
        }

        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha -= dt * 2; 
                p.size -= dt * 5; 
                return p.alpha > 0 && p.size > 0;
            });
        }

        function updateSpinningKnivesEffect() {
            spinningKnives = [];
            const numKnives = player.stats.spinningKnivesCount;
            const radius = player.size * 2; 
            const knifeSize = 5;
            const knifeDamage = player.stats.spinningKnivesDamage;
            const rotationSpeed = 5; 

            for (let i = 0; i < numKnives; i++) {
                spinningKnives.push({
                    angle: (Math.PI * 2 / numKnives) * i, 
                    radius: radius,
                    size: knifeSize,
                    damage: knifeDamage,
                    rotationSpeed: rotationSpeed,
                    hitEnemies: new Set() 
                });
            }
        }

        function updateFemaleAllyAndDogs(dt) {
            if (femaleAlly) {
                const effectiveDt = dt * gameSpeedMultiplier;
                const closestEnemy = enemies.find(e => !e.controlled); 

                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - femaleAlly.y, closestEnemy.x - femaleAlly.x);
                    femaleAlly.currentShootAngle = angle; 

                    const distanceToEnemy = dist(femaleAlly, closestEnemy);
                    const desiredDistance = 150; 
                    if (distanceToEnemy > desiredDistance) {
                        femaleAlly.x += Math.cos(angle) * femaleAlly.speed * effectiveDt;
                        femaleAlly.y += Math.sin(angle) * femaleAlly.speed * effectiveDt;
                    } else if (distanceToEnemy < desiredDistance * 0.8) { 
                        femaleAlly.x -= Math.cos(angle) * femaleAlly.speed * effectiveDt;
                        femaleAlly.y -= Math.sin(angle) * femaleAlly.speed * effectiveDt;
                    }

                    femaleAlly.shootTimer += effectiveDt;
                    if (femaleAlly.shootTimer >= 1 / femaleAlly.attackSpeed) {
                        const offset = 5; 
                        projectiles.push({
                            x: femaleAlly.x + Math.cos(angle - Math.PI/2) * offset,
                            y: femaleAlly.y + Math.sin(angle - Math.PI/2) * offset,
                            vx: Math.cos(angle) * femaleAlly.projectileSpeed,
                            vy: Math.sin(angle) * femaleAlly.projectileSpeed,
                            size: femaleAlly.projectileSize,
                            damage: femaleAlly.damage,
                            color: '#FFC0CB', 
                            pierce: femaleAlly.pierce,
                            hits: 0
                        });
                        projectiles.push({
                            x: femaleAlly.x + Math.cos(angle + Math.PI/2) * offset,
                            y: femaleAlly.y + Math.sin(angle + Math.PI/2) * offset,
                            vx: Math.cos(angle) * femaleAlly.projectileSpeed,
                            vy: Math.sin(angle) * femaleAlly.projectileSpeed,
                            size: femaleAlly.projectileSize,
                            damage: femaleAlly.damage,
                            color: '#FFC0CB', 
                            pierce: femaleAlly.pierce,
                            hits: 0
                        });
                        playSound('playerShot'); 
                        femaleAlly.shootTimer = 0;
                    }
                } else {
                    const angle = Math.atan2(player.y - femaleAlly.y, player.x - femaleAlly.x);
                    femaleAlly.x += Math.cos(angle) * femaleAlly.speed * effectiveDt;
                    femaleAlly.y += Math.sin(angle) * femaleAlly.speed * effectiveDt;
                }
            }

            allyDogs.forEach(dog => {
                const effectiveDt = dt * gameSpeedMultiplier;
                const closestEnemy = enemies.find(e => !e.controlled); 

                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - dog.y, closestEnemy.x - dog.x);
                    dog.x += Math.cos(angle) * dog.speed * effectiveDt;
                    dog.y += Math.sin(angle) * dog.speed * effectiveDt;

                    if (dist(dog, closestEnemy) < (dog.size / 2 + closestEnemy.size / 2) && (survivalTime - dog.lastAttackTime >= dog.attackCooldown)) {
                        closestEnemy.health -= dog.damage;
                        showDamageNumber(dog.damage, closestEnemy.x, closestEnemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        dog.lastAttackTime = survivalTime; 
                    }
                } else {
                    const angle = Math.atan2(player.y - dog.y, player.x - dog.x);
                    dog.x += Math.cos(angle) * dog.speed * effectiveDt;
                    dog.y += Math.sin(angle) * dog.speed * effectiveDt;
                }
            });
        }

        function updateDrones(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            drones.forEach(drone => {
                const closestEnemy = enemies.find(e => !e.controlled); 
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                    if (dist(drone, player) > 150) { 
                        drone.x += Math.cos(angle) * drone.speed * effectiveDt;
                        drone.y += Math.sin(angle) * drone.speed * effectiveDt;
                    } else {
                        drone.orbitAngle += effectiveDt * 2; 
                        drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                        drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                    }

                    drone.shootTimer += effectiveDt;
                    if (drone.shootTimer >= 1 / drone.attackSpeed) {
                        projectiles.push({
                            x: drone.x,
                            y: drone.y,
                            vx: Math.cos(angle) * 500, 
                            vy: Math.sin(angle) * 500,
                            size: 4,
                            damage: drone.damage,
                            color: '#00FFFF', 
                            pierce: 0,
                            hits: 0
                        });
                        drone.shootTimer = 0;
                    }
                } else {
                    drone.orbitAngle += effectiveDt * 2; 
                    drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                    drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                }
            });
        }

        function updateDronesEffect() {
            while (drones.length < player.stats.droneCount) {
                const newDrone = {
                    x: player.x,
                    y: player.y,
                    size: 10,
                    speed: 200, 
                    damage: player.stats.droneDamage,
                    attackSpeed: player.stats.droneAttackSpeed,
                    shootTimer: 0,
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitRadius: 50 + drones.length * 10 
                };
                drones.push(newDrone);
            }
            drones.forEach(drone => {
                drone.damage = player.stats.droneDamage;
                drone.attackSpeed = player.stats.droneAttackSpeed;
            });
        }

        function updateBoomerangs(dt) {
            boomerangs = boomerangs.filter(b => {
                if (!b.returning) {
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.distanceTraveled += b.speed * dt;

                    if (b.distanceTraveled >= b.maxOutwardDistance) {
                        b.returning = true;
                    }
                } else {
                    const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                    b.vx = Math.cos(angleToPlayer) * b.speed;
                    b.vy = Math.sin(angleToPlayer) * b.speed;
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;

                    if (dist(player, b) < player.size / 2 + b.size / 2) {
                        return false; 
                    }
                }
                return b.x > -100 && b.x < gameWorld.width + 100 && b.y > -100 && b.y < gameWorld.height + 100;
            });
        }
        
        function checkCollisions() {
            enemies.forEach(enemy => {
                if (!enemy.controlled) {
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2) && 
                        (enemy.type === 'basic' || enemy.type === 'tank' || enemy.type === 'car' || enemy.type === 'ninja' || enemy.type === 'enemyDog' || enemy.type === 'cobra' || enemy.type === 'yellowSkull')) {
                        let damageTaken = enemy.damage;
                        damageTaken = damageTaken * (1 - player.stats.damageReduction);
                        
                        if (ultimateActive) {
                            damageTaken *= 0.5;
                        }
                        damageTaken = Math.max(0, damageTaken); 
                        player.health -= damageTaken;
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
        
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    if (!enemy.controlled && dist(p, enemy) < (p.size + enemy.size / 2)) {
                        if (enemy.type === 'robotDrone') {
                            explodeRobotDrone(enemy);
                            enemies.splice(j, 1); 
                            j--; 
                            projectileRemoved = true; 
                            break;
                        }
                        
                        const damageDealt = p.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit'); 
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        p.hits++;
        
                        if (p.hits > p.pierce) {
                            projectiles.splice(i, 1);
                            projectileRemoved = true;
                            break; 
                        }
                    }
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    let damageTaken = p.damage;
                    damageTaken = damageTaken * (1 - player.stats.damageReduction);

                    if (ultimateActive) {
                        damageTaken *= 0.5;
                    }
                    damageTaken = Math.max(0, damageTaken); 
                    player.health -= damageTaken;
                    if (player.health <= 0) {
                        gameOver();
                    }

                    if (p.isAoE) {
                        enemies.forEach(otherEnemy => {
                            if (otherEnemy !== p.sourceEnemy && !otherEnemy.controlled && dist(player, otherEnemy) < p.aoeRadius) {
                                otherEnemy.health -= p.damage * 0.5; 
                                showDamageNumber(p.damage * 0.5, otherEnemy.x, otherEnemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                            }
                        });
                        playSound('explosion'); 
                        spawnParticles(p.x, p.y, {r: 255, g: 100, b: 0}); 
                    }
                    enemyProjectiles.splice(i, 1); 
                    i--; 
                }
            }

            spinningKnives.forEach(knife => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !knife.hitEnemies.has(enemy) && dist(knife, enemy) < (knife.size + enemy.size / 2)) {
                        const damageDealt = knife.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        knife.hitEnemies.add(enemy); 
                    }
                });
                knife.hitEnemies.clear();
            });

            boomerangs.forEach(b => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !b.hitEnemies.has(enemy) && dist(b, enemy) < (b.size + enemy.size / 2)) {
                        const damageDealt = b.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        b.hitEnemies.add(enemy); 
                    }
                });
            });
        
            allyDogs.forEach(dog => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && dist(dog, enemy) < (dog.size / 2 + enemy.size / 2)) {
                        if (survivalTime - dog.lastAttackTime >= dog.attackCooldown) {
                            enemy.health -= dog.damage;
                            showDamageNumber(dog.damage, enemy.x, enemy.y);
                            if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                playSound('enemyHit');
                                lastEnemyHitSoundTime = survivalTime;
                            }
                            dog.lastAttackTime = survivalTime; 
                        }
                    }
                });
            });
        
            powerups.forEach(p => {
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    gainXp(p.xpValue);
                    powerups = powerups.filter(item => item !== p);
                }
            });

            for (let i = chests.length - 1; i >= 0; i--) {
                const chest = chests[i];
                if (dist(player, chest) < (player.size / 2 + chest.size / 2)) {
                    activateTemporaryPowerup();
                    chests.splice(i, 1);
                }
            }
        
            enemies = enemies.filter(enemy => {
                if (enemy.health <= 0) {
                    gainXp(enemy.xp);
                    score += 10;
                    spawnParticles(enemy.x, enemy.y, enemy.color);
                    if (Math.random() < 0.1) {
                        spawnPowerup(enemy.x, enemy.y);
                    }
                    return false; 
                }
                return true; 
            });
        }
        
        function spawnEnemy() {
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra'; 
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        }

        function spawnCobra(x, y) {
            const numSegments = 5 + Math.floor(Math.random() * 3); 
            const segmentSize = 25;
            const snakeId = Date.now(); 

            for (let i = 0; i < numSegments; i++) {
                const segmentX = x - i * segmentSize * 1.5; 
                const segmentY = y;
                enemies.push({
                    x: segmentX,
                    y: segmentY,
                    type: 'cobra',
                    controlled: false, 
                    snakeId: snakeId,
                    segmentIndex: i,
                    stuckTimer: 0, 
                    ghostModeActive: false, 
                    ghostModeTimer: 0, 
                    lastX: segmentX, 
                    lastY: segmentY, 
                    ...getEnemyStats('cobra')
                });
            }
        }
        
        function getEnemyStats(type) {
            const base = {
                size: 25, speed: 30, health: 50, damage: 10, xp: 10,
                projectileSize: 8, projectileDamage: 15, projectileSpeed: 100, projectileColor: '#FF0000', attackRange: 250, attackSpeed: 0.8
            };
        
            switch (type) {
                case 'fast':
                    base.size = 20; base.speed = 50; base.health = 30; base.xp = 15; base.color = '#ff4444';
                    base.attackRange = 200; base.attackSpeed = 2; base.projectileSpeed = 150; 
                    break;
                case 'tank':
                    base.size = 30; 
                    base.speed = 15; base.health = 200; base.xp = 50; base.color = '#9966ff';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'elite':
                    base.size = 30; base.speed = 40; base.health = 500; base.damage = 20; base.xp = 200; base.color = '#ff0000';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'gunner':
                    base.size = 25; base.speed = 20; base.health = 40; base.damage = 0; base.xp = 20; base.color = '#3399ff';
                    base.attackRange = 400; base.attackSpeed = 1; base.projectileSpeed = 100; 
                    break;
                case 'drone':
                    base.size = 15; base.speed = 40; base.health = 20; base.xp = 12; base.color = '#888888';
                    base.attackRange = 150; base.attackSpeed = 2.5; base.projectileSpeed = 125; base.projectileSize = 5; base.projectileColor = '#FF0000'; 
                    break;
                case 'car':
                    base.size = 35; 
                    base.speed = 70; base.health = 300; base.damage = 25 * 0.8; base.xp = 75; base.color = '#663300'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'ninja':
                    base.size = 22; base.speed = 80; base.health = 60; base.damage = 15; base.xp = 30; base.color = '#333333';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'enemyDog':
                    base.size = 20; base.speed = 60; base.health = 35; base.damage = 12; base.xp = 18; base.color = '#A0522D'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'enemyDrone':
                    base.size = 15; base.speed = 45; base.health = 25; base.damage = 0; base.xp = 15; base.color = '#4682B4'; 
                    base.attackRange = 200; base.attackSpeed = 1.5; base.projectileSpeed = 110; base.projectileSize = 6; base.projectileColor = '#FF0000'; 
                    break;
                case 'cobra':
                    base.size = 25; base.speed = 40; base.health = 70; base.damage = 15; base.xp = 25; base.color = '#228B22'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'robotDrone': 
                    base.size = 18; base.speed = 70; base.health = 20; base.damage = 25; base.xp = 15; base.color = '#808080'; 
                    base.explosionRadius = 70; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'yellowSkull': 
                    base.size = 35; 
                    base.speed = 10; 
                    base.health = 400; 
                    base.damage = 15; 
                    base.xp = 100; 
                    base.color = '#FFFF00'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                default: 
                    base.color = '#777777';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
            }
            
            const healthScale = 1 + Math.pow(survivalTime / 60, 0.5); 
            const damageScale = 1 + Math.pow(survivalTime / 90, 0.4); 
            let speedScale = 1 + Math.min(survivalTime / 180, 1.5); 

            if (survivalTime >= 120) { 
                speedScale *= 1.15;
            }

            base.health *= healthScale;
            base.damage *= damageScale;
            base.speed *= speedScale;
            base.xp = Math.floor(base.xp * ((healthScale + damageScale) / 2) * 0.5); 

            if (type === 'gunner' || type === 'fast' || type === 'drone' || type === 'enemyDrone') { 
                base.projectileDamage *= damageScale;
                base.attackSpeed *= (1 + Math.min(survivalTime / 180, 1));
            }

            if (type === 'basic' && survivalTime < 60) {
                base.health *= 0.75; 
            }

            return base;
        }

        function explodeRobotDrone(drone) {
            playSound('explosion');
            spawnParticles(drone.x, drone.y, {r: 255, g: 100, b: 0}); 

            if (dist(player, drone) < (player.size / 2 + drone.explosionRadius)) {
                let damageTaken = drone.damage;
                damageTaken = damageTaken * (1 - player.stats.damageReduction);
                if (ultimateActive) {
                    damageTaken *= 0.5;
                }
                damageTaken = Math.max(0, damageTaken); 
                player.health -= damageTaken;
                if (player.health <= 0) {
                    gameOver();
                }
                showDamageNumber(damageTaken, player.x, player.y);
            }

            enemies.forEach(otherEnemy => {
                if (otherEnemy !== drone && !otherEnemy.controlled && dist(drone, otherEnemy) < (drone.explosionRadius + otherEnemy.size / 2)) {
                    otherEnemy.health -= drone.damage * 0.5; 
                    showDamageNumber(drone.damage * 0.5, otherEnemy.x, otherEnemy.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                }
            });
        }
        
        function spawnPowerup(x, y) {
            powerups.push({
                x: x, y: y, size: 10, color: '#ffff00', speed: 300, 
                xpValue: Math.floor((50 + Math.floor(Math.random() * 50)) * 1.5) 
            });
        }

        function spawnChestAtLocation(x, y) {
            chests.push({
                x: x, y: y, size: 30, type: 'chest'
            });
        }

        function activateTemporaryPowerup() {
            if (temporaryPowerupActive) {
                deactivateTemporaryPowerup();
            }

            const powerupChoices = ['spreadGun', 'femaleAllyAndDogs']; 
            const chosenPowerup = powerupChoices[Math.floor(Math.random() * powerupChoices.length)];

            temporaryPowerupType = chosenPowerup;

            if (survivalTime >= 300 && survivalTime < 900) { 
                temporaryPowerupDuration = 10;
            } else { 
                temporaryPowerupDuration = 5;
            }
            
            temporaryPowerupActive = true; 

            switch (chosenPowerup) {
                case 'spreadGun':
                    console.log("Spread Gun Activated!");
                    break;
                case 'femaleAllyAndDogs':
                    console.log("Female Ally and Dogs Summoned!");
                    femaleAlly = {
                        x: player.x + 50, 
                        y: player.y,
                        size: 20,
                        speed: player.speed * 1.5, 
                        health: 200, 
                        maxHealth: 200,
                        damage: player.stats.damage * 0.8, 
                        attackSpeed: player.stats.attackSpeed * 1.5, 
                        shootTimer: 0,
                        currentShootAngle: 0,
                        projectileSize: 4,
                        projectileSpeed: 600,
                        pierce: 0,
                        hits: 0,
                    };
                    allyDogs = [];
                    for (let i = 0; i < 3; i++) {
                        allyDogs.push({
                            x: player.x - 50 + (i * 20), 
                            y: player.y + 50,
                            size: 20,
                            speed: player.speed * 1.2, 
                            damage: player.stats.damage * 0.5, 
                            lastAttackTime: 0, 
                            attackCooldown: 0.5 
                        });
                    }
                    break;
            }
        }

        function deactivateTemporaryPowerup() {
            if (!temporaryPowerupActive) return;

            switch (temporaryPowerupType) {
                case 'spreadGun':
                    console.log("Spread Gun Deactivated!");
                    break;
                case 'femaleAllyAndDogs':
                    console.log("Female Ally and Dogs Deactivated!");
                    femaleAlly = null; 
                    allyDogs = []; 
                    break;
            }
            temporaryPowerupActive = false;
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
        }
        
        function gainXp(amount) {
            const wasMessageBoxHidden = messageBox.style.display !== 'block'; 
            player.xp += amount;
            console.log(`[XP Gain] XP gained: ${amount}, Current XP: ${player.xp}, Next Level XP: ${player.nextLevelXp}`);
            while (player.xp >= player.nextLevelXp) {
                levelUpQueue.push(true);
                player.xp -= player.nextLevelXp;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.8); 
                player.maxHealth += 10;
                player.health = Math.min(player.health + 10, player.maxHealth);
                player.level++;
                playSound('levelUp');
                console.log(`[LEVEL UP] New Level: ${player.level}, XP remaining: ${player.xp}, Next Level XP: ${player.nextLevelXp}. Queue size: ${levelUpQueue.length}`);
            }
            if (levelUpQueue.length > 0 && wasMessageBoxHidden) {
                console.log(`[Show Power] Calling showPowerSelection from gainXp. Queue size: ${levelUpQueue.length}, wasMessageBoxHidden: ${wasMessageBoxHidden}`);
                showPowerSelection();
            }
        }
        
        function showPowerSelection() {
            gameRunning = false;
            isPaused = true; 
            Tone.Transport.stop(Tone.now()); 
            messageBox.style.display = 'block';
            powerSelectionDiv.innerHTML = '';
            console.log("[Show Power] showPowerSelection called.");
        
            const numOptions = 4; 
            const availablePowers = POWER_OPTIONS.filter(p => p.level() < MAX_UPGRADE_LEVEL); 
            const selectedPowers = [];
        
            let tempAvailablePowers = [...availablePowers];

            while (selectedPowers.length < numOptions && tempAvailablePowers.length > 0) {
                const randomIndex = Math.floor(Math.random() * tempAvailablePowers.length);
                selectedPowers.push(tempAvailablePowers[randomIndex]);
                tempAvailablePowers.splice(randomIndex, 1); 
            }
        
            selectedPowers.forEach(power => {
                const card = document.createElement('div');
                card.className = 'power-card';
                card.innerHTML = `
                    <h4>${power.name} <span>Lvl ${power.level() + 1}</span></h4>
                    <p>${power.next()}</p>
                `;
                card.addEventListener('click', () => selectPower(power));
                powerSelectionDiv.appendChild(card);
            });
        }
        
        function selectPower(power) {
            power.effect();
            console.log(`[Power Select] Power selected: ${power.name}. Before shift, queue size: ${levelUpQueue.length}`);
            
            messageBox.style.display = 'none'; 
            
            if (levelUpQueue.length > 0) {
                levelUpQueue.shift(); 
                console.log(`[Power Select] After shift, queue size: ${levelUpQueue.length}. Calling showPowerSelection again.`);
                showPowerSelection(); 
            } else {
                console.log(`[Power Select] No more level ups pending. Resuming game.`);
                gameRunning = true;
                isPaused = false; 
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function resetGame() {
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            powerups.length = 0;
            damageNumbers.length = 0;
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            femaleAlly = null; 
            allyDogs = []; 
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            
            survivalTime = 0;
            shootTimer = 0;
            spawnTimer = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; 
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
            lastUziSoundTime = 0;


            updateMusicPatterns(currentMusicPatternIndex);
        }

        function handleRetry() {
            startGame();
        }

        function updateCamera() {
            camera.x = player.x - (camera.width / camera.zoom) / 2;
            camera.y = player.y - (camera.height / camera.zoom) / 2;

            camera.x = Math.max(0, Math.min(camera.x, gameWorld.width - (camera.width / camera.zoom)));
            camera.y = Math.max(0, Math.min(camera.y, gameWorld.height - (camera.height / camera.zoom)));
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused || isMenuOpen) return; 
        
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            survivalTime += deltaTime;
        
            update(deltaTime);
            draw();
        
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            shootTimer += effectiveDt;
            spawnTimer += effectiveDt;
            musicPatternTimer += effectiveDt;
            randomChestSpawnTimer += effectiveDt; 

            if (randomChestSpawnTimer >= RANDOM_CHEST_SPAWN_INTERVAL) {
                if (Math.random() < RANDOM_CHEST_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnChestAtLocation(x, y);
                }
                randomChestSpawnTimer = 0;
            }

            if (musicPatternTimer >= MUSIC_PATTERN_CHANGE_INTERVAL) {
                musicPatternTimer = 0;
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * BACKGROUND_MUSIC_PATTERNS.length);
                } while (newIndex === currentMusicPatternIndex);
                currentMusicPatternIndex = newIndex;
                updateMusicPatterns(currentMusicPatternIndex);
            }

            if (player.upgrades.burstCharge > 0) {
                player.burstChargeTimer -= effectiveDt;
            }

            if (player.stats.burstDamage > 0) {
                player.burstTimer += effectiveDt;
            }
            if (player.upgrades.shotgun > 0) { 
                player.shotgunTimer += effectiveDt;
            }
            if (player.stats.dualUziActive) { 
                player.dualUziTimer += effectiveDt;
            }
            if (player.stats.boomerangCount > 0) { 
                player.boomerangTimer += effectiveDt;
            }

            spinningKnives.forEach(knife => {
                knife.angle += knife.rotationSpeed * effectiveDt;
                knife.x = player.x + Math.cos(knife.angle) * knife.radius;
                knife.y = player.y + Math.sin(knife.angle) * knife.radius;
            });

            if (ultimateActive) {
                ultimateDuration -= effectiveDt;
                if (ultimateDuration <= 0) {
                    ultimateActive = false;
                    player.color = '#6A808C'; 
                    ultimateCharge = 0;
                    gameSpeedMultiplier = 1; 
                    playerSpeedModifier = 1; 
                    projectileSpeedModifier = 1; 
                    if (!isMusicMuted) Tone.Transport.playbackRate = 1; 
                }
            } else if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += effectiveDt * 5 * (1 + player.upgrades.ultimateRecharge * 0.2); 
                ultimateCharge = Math.min(ultimateCharge, ultimateMaxCharge);
            }

            if (temporaryPowerupActive) {
                temporaryPowerupDuration -= dt; 
                if (temporaryPowerupDuration <= 0) {
                    deactivateTemporaryPowerup();
                }
            }

            updatePlayer(effectiveDt);
            updateCamera();
            updateEnemies(effectiveDt);
            updateProjectiles(effectiveDt);
            updatePowerups(effectiveDt);
            updateChests(effectiveDt); 
            updateFemaleAllyAndDogs(effectiveDt); 
            updateDrones(effectiveDt); 
            updateBoomerangs(effectiveDt); 
            checkCollisions();
            updateDamageNumbers(effectiveDt);
            updateParticles(effectiveDt); 
        }
        
        async function gameOver() {
            gameRunning = false;
            isPaused = true; 
            playSound('gameOver');
            
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); 
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); 
            }
            Tone.Transport.stop(Tone.now()); 

            // Save user's personal best score for the current level
            if (window.saveUserLevelScore) {
                await window.saveUserLevelScore(currentLevelId, score);
            }

            showGameOverMenu();
            document.getElementById('final-score').textContent = `Score: ${score}`;
            document.getElementById('final-time').textContent = `Time Survived: ${survivalTime.toFixed(1)}s`;
            document.getElementById('final-level').textContent = `Level Reached: ${player.level}`;

            const currentHighScores = await window.getHighScoresFirebase();
            const isHighScore = currentHighScores.length < 10 || score > Math.min(...currentHighScores.map(s => s.score));

            if (isHighScore) {
                highScoreModal.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                displayHighScores();
            }
        }

        async function saveAndDisplayHighScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                if (window.saveHighScoreFirebase) {
                    await window.saveHighScoreFirebase(playerName, score, survivalTime.toFixed(1), player.level, currentLevelId);
                }
                highScoreModal.style.display = 'none';
                displayHighScores();
            } else {
                console.warn("Please enter a name to save your high score.");
            }
        }

        async function displayHighScores() {
            const highScores = await window.getHighScoresFirebase();
            highScoresList.innerHTML = '';
            
            if (highScores.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No high scores yet. Be the first!';
                highScoresList.appendChild(li);
                return;
            }

            highScores.forEach((s, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${index + 1}. ${s.name}</span>
                    <span>Score: ${s.score} | Time: ${s.survivalTime}s | Lvl: ${s.level} (${s.levelId === 'hotel_lobby' ? 'Hotel' : 'Park'})</span>
                `;
                highScoresList.appendChild(li);
            });
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = 'Resume';
                Tone.Transport.stop(Tone.now()); 
            } else {
                pauseButton.textContent = 'Pause';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            if (isMenuOpen) {
                gameMenu.style.display = 'block';
                Tone.Transport.stop(Tone.now()); 
            } else {
                gameMenu.style.display = 'none';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function toggleMusic() {
            isMusicMuted = !isMusicMuted;
            Tone.Destination.mute = isMusicMuted; 
            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }

        function spawnParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[0];
                        b = parts[0];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }
        
        function init() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;

            miniMapCanvas.width = miniMapCanvas.clientWidth;
            miniMapCanvas.height = miniMapCanvas.clientHeight;
            miniMapScale = miniMapCanvas.width / gameWorld.width; 

            window.addEventListener('resize', () => {
                canvas.width = gameContainer.clientWidth;
                canvas.height = gameContainer.clientHeight;
                camera.width = canvas.width / camera.zoom; 
                camera.height = canvas.height / camera.zoom; 

                miniMapCanvas.width = miniMapCanvas.clientWidth;
                miniMapCanvas.height = miniMapCanvas.clientHeight;
                miniMapScale = miniMapCanvas.width / gameWorld.width;

                if (!gameRunning) {
                    showStartMenu();
                }
            });
        
            document.getElementById('startButton').addEventListener('click', () => {
                Tone.start(); 
                setupAudio();
                startGame();
            });
            document.getElementById('restartButton').addEventListener('click', handleRetry);
            saveScoreButton.addEventListener('click', saveAndDisplayHighScore);

            pauseButton.addEventListener('click', togglePause);
            menuButton.addEventListener('click', toggleMenu);
            muteMusicButton.addEventListener('click', toggleMusic);
            resumeFromMenuButton.addEventListener('click', toggleMenu); 

            // New level select button and its event listeners
            levelSelectButton.addEventListener('click', showLevelSelectMenu);
            backToMainMenuButton.addEventListener('click', showStartMenu);

            canvas.addEventListener('mousedown', handlePointerEvent);
            canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
            
            function handlePointerEvent(e) {
                e.preventDefault();
                if (!gameRunning || isPaused || isMenuOpen) return; 

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const inputX = (clientX - rect.left) / camera.zoom;
                const inputY = (clientY - rect.top) / camera.zoom;
                
                player.targetX = camera.x + inputX;
                player.targetY = camera.y + inputY;
            }

            ultimateButton.addEventListener('click', () => {
                if (ultimateCharge >= ultimateMaxCharge && !ultimateActive) {
                    activateUltimate();
                }
            });
        
            // Initial obstacle generation based on default level
            generateObstacles();
        
            showStartMenu();

            if (typeof window.initFirebase === 'function') {
                window.initFirebase();
            } else {
                console.error("Firebase initialization function not found.");
            }
        }

        let enemies = []; 
        let projectiles = []; 
        let enemyProjectiles = []; 
        let powerups = []; 
        let obstacles = []; 

        function generateObstacles() {
            obstacles = []; 

            if (currentLevelId === 'hotel_lobby') {
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 50, height: 50, color: '#3c3c3c', type: 'pillar'
                    });
                }

                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 200, height: 50, color: '#4d4d4d', type: 'desk'
                    });
                }

                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 30, height: 30, color: '#2d2d2d', type: 'chair'
                    });
                }
            } else if (currentLevelId === 'the_park') {
                // Trees (circular, larger)
                for (let i = 0; i < 25; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 70, height: 70, color: '#006400', type: 'tree' // Dark green
                    });
                }
                // Bushes (rectangular, smaller)
                for (let i = 0; i < 35; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 40, height: 40, color: '#008000', type: 'bush' // Medium green
                    });
                }
                // Park Benches (rectangular, longer)
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 100, height: 30, color: '#8B4513', type: 'bench' // Saddle brown
                    });
                }
            }
        }
        
        function startGame() {
            gameRunning = true;
            isPaused = false;
            isMenuOpen = false;
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            player.health = 100;
            player.maxHealth = 100;
            player.xp = 0;
            player.level = 1;
            player.nextLevelXp = 100;
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.targetX = player.x;
            player.targetY = player.y;
            player.vx = 0; 
            player.vy = 0; 

            player.stats = {
                damage: 20, attackSpeed: 10, projectileSpeed: 400, pierce: 0, multiShot: 1, 
                healthRegen: 0.1, magnet: 50, damageReduction: 0, 
                spinningKnivesDamage: 0, spinningKnivesCount: 0, 
                burstDamage: 0, burstProjectileCount: 0,
                droneCount: 0, droneDamage: 0, droneAttackSpeed: 0,
                shotgunPellets: 0, shotgunDamage: 0, shotgunSpread: 0,
                dualUziActive: false, dualUziFireRate: 0, dualUziDamage: 0,
                boomerangDamage: 0, boomerangCount: 0, boomerangCooldown: 4, boomerangRange: 150, boomerangSpeed: 400,
                burstChargeDamage: 0, burstChargeProjectileCount: 0
            };
            player.upgrades = {
                damage: 0, attackSpeed: 0, health: 0, speed: 0, pierce: 0, multiShot: 0, 
                healthRegen: 0, magnet: 0, bulletproofSuit: 0, 
                ultimateRecharge: 0, burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, shotgun: 0, dualUzi: 0,
                boomerang: 0, burstCharge: 0
            };
            player.burstChargeCooldown = 5; 
            player.burstChargeTimer = 0; 
            player.burstCooldown = 1;
            player.burstTimer = 0;
            player.shotgunTimer = 0; 
            player.dualUziTimer = 0; 
            player.boomerangTimer = 0; 
            player.currentShootAngle = 0; 
            ultimateChargePerHit = 0.5; 
            lastShotSoundTime = 0;
            lastEnemyHitSoundTime = 0;
            lastUziSoundTime = 0; 

            currentMusicPatternIndex = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; 
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            femaleAlly = null; 
            allyDogs = []; 
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            player.color = '#6A808C'; 
            
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            messageBox.style.display = 'none';
            highScoreModal.style.display = 'none';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; // Ensure level select is hidden

            // Generate obstacles for the selected level
            generateObstacles();
            
            updateMusicPatterns(currentMusicPatternIndex);
            if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
        
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    </script>
</body>
</html>
