<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>Johnny Wicked Survivors</title>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            flex-direction: column;
        }
        
        #gameContainer {
            position: relative;
            /* Width and height will be dynamically set by JS based on resolution */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;
            box-sizing: border-box;
            transform-origin: center center; /* Ensure scaling is centered */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute; /* Keep absolute for precise placement within UI overlay */
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px; /* Scaled by responsive CSS */
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
            white-space: nowrap; /* Prevent text wrapping */
        }
        
        /* Top Left Controls: Score and Pause Button */
        #top-left-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px; /* Scaled by responsive CSS */
            pointer-events: all;
        }

        /* Bottom Left Controls: Time, Menu, and Level */
        #bottom-left-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px; /* Scaled by responsive CSS */
            pointer-events: all;
        }

        #score-display {
            position: static;
            margin-bottom: 5px;
        }
        
#time-display {
    position: static;
    margin-bottom: 5px;
    display: block;
    min-width: 80px; /* Adjust this value if needed */
    text-align: left;
}
        
        #level-display {
            position: static;
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* Scaled by responsive CSS */
            height: 15px; /* Scaled by responsive CSS */
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px; /* Scaled by responsive CSS */
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* Scaled by responsive CSS */
            height: 10px; /* Scaled by responsive CSS */
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box, .menu, #level-select-menu, #character-select-menu, #resolution-select-menu, #accessibility-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px; /* Scaled by responsive CSS */
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em; /* Scaled by responsive CSS */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
            z-index: 11;
            /* Make menus responsive */
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
#power-selection, #level-options, #character-options, #resolution-options {
    display: flex;
    gap: 30px; /* This is the change */
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 20px; /* Scaled by responsive CSS */
}

        .power-card, .character-card, .level-card, .resolution-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px; /* Scaled by responsive CSS */
            width: 160px; /* Scaled by responsive CSS */
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
            box-sizing: border-box;
        }

        .resolution-card {
            width: 180px; /* Slightly wider for resolution names */
        }
        
        .power-card:hover, .character-card:hover, .level-card:hover, .resolution-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4, .character-card h3, .level-card h3, .resolution-card h3 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
.power-card p, .character-card p, .level-card p, .resolution-card p {
    font-size: 0.7em; /* This is the change */
    margin-bottom: 0;
}

        .menu button, .control-button, #level-select-menu button, #character-select-menu button, #resolution-select-menu button, #accessibility-menu button {
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px; /* Scaled by responsive CSS */
            font-size: 1.2em; /* Scaled by responsive CSS */
            font-family: 'Chakra Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px; /* Scaled by responsive CSS */
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
            white-space: nowrap;
        }
        
        .menu button:hover, .control-button:hover, #level-select-menu button:hover, #character-select-menu button:hover, #resolution-select-menu button:hover, #accessibility-menu button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        #pauseButton, #menuButton, #muteMusicButton, #resumeFromMenuButton, #backToMainMenuButtonFromGame { 
            padding: 8px 15px; /* Scaled by responsive CSS */
            font-size: 0.9em; /* Scaled by responsive CSS */
            margin-top: 0;
            background: linear-gradient(45deg, #007bff, #0056b3);
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #pauseButton:hover, #menuButton:hover, #muteMusicButton:hover, #resumeFromMenuButton:hover, #backToMainMenuButtonFromGame:hover {
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px; /* Scaled by responsive CSS */
            right: 20px; /* Scaled by responsive CSS */
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px; /* Scaled by responsive CSS */
            font-size: 1.2em; /* Scaled by responsive CSS */
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px; /* Scaled by responsive CSS */
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: fadeOutAndShrink 0.8s forwards;
        }

        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px; /* Scaled by responsive CSS */
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none;
            pointer-events: all;
            max-width: 90%;
            box-sizing: border-box;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px; /* Scaled by responsive CSS */
            margin: 15px 0; /* Scaled by responsive CSS */
            border-radius: 5px;
            width: 80%;
            max-width: 250px; /* Scaled by responsive CSS */
            font-family: 'Chakra Petch', monospace;
            font-size: 0.8em; /* Scaled by responsive CSS */
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px; /* Scaled by responsive CSS */
            font-size: 0.8em; /* Scaled by responsive CSS */
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px; /* Scaled by responsive CSS */
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

.high-scores-header, #high-scores-list li, #start-menu-high-scores-list li {
    display: grid;
    grid-template-columns: 3fr 1fr 1fr 1fr; /* Defines four columns */
    gap: 20px; /* Adds space between columns */
    padding: 8px 15px; /* Adds padding for spacing */
    align-items: center;
}

.high-scores-header {
    background-color: rgba(0, 255, 255, 0.1); /* Light blue background for the header */
    border: 1px solid #00ffff;
    border-bottom: none;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    font-weight: bold;
    color: #00ffff; /* Brighter color for visibility */
    text-align: left;
}

#high-scores-list, #start-menu-high-scores-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 200px;
    overflow-y: auto;
    border-bottom: 1px solid #333;
    border-left: 1px solid #333;
    border-right: 1px solid #333;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    background-color: rgba(0, 0, 0, 0.5);
    font-size: 0.8em;
}

#high-scores-list li, #start-menu-high-scores-list li {
    border-bottom: 1px dashed #222;
    text-align: left;
}

#high-scores-list li:last-child, #start-menu-high-scores-list li:last-child {
    border-bottom: none;
}

        /* Level Select Menu Styles */
        .level-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px; /* Scaled by responsive CSS */
            width: 250px; /* Scaled by responsive CSS */
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            pointer-events: all;
            margin-bottom: 15px; /* Scaled by responsive CSS */
            box-sizing: border-box;
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card.locked:hover {
            transform: none;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card h3 {
            margin-top: 0;
            color: #00ffff;
            font-size: 1.5em; /* Scaled by responsive CSS */
        }

        .level-card p {
            font-size: 0.8em; /* Scaled by responsive CSS */
            margin-bottom: 5px;
        }

        .level-card .unlock-info {
            color: #ffdd00;
            font-size: 0.8em; /* Scaled by responsive CSS */
            font-weight: bold;
        }

        /* Mini-map styles */
        #miniMapContainer {
            position: absolute;
            top: 10px; /* Scaled by responsive CSS */
            right: 10px; /* Scaled by responsive CSS */
            width: 150px; /* Scaled by responsive CSS */
            height: 150px; /* Scaled by responsive CSS */
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            pointer-events: none;
        }

        #miniMapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    

        /* Responsive font sizes using vw units */
@media (max-width: 440px) {
            /* #gameContainer width/height set by JS for aspect ratio, max-width/height ensures fit */
            #gameContainer {
                max-width: 95vw;
                max-height: 95vh;
            }
            .hud-item, .menu, #high-score-modal, .power-card, .character-card, .level-card, .resolution-card,
            .menu button, .control-button, #ultimate-button, #accessibility-menu button, #resolution-select-menu button,
            #high-score-modal input, #high-score-modal button,
            #high-scores-list, #start-menu-high-scores-list,
            .level-card h3, .level-card p, .level-card .unlock-info,
            .resolution-card h3, .resolution-card p {
                font-size: clamp(0.7em, 2.5vw, 1.2em); /* Fluid font size */
                padding: clamp(5px, 1.5vw, 15px) clamp(10px, 3vw, 30px);
                margin-top: clamp(10px, 2vw, 20px);
                margin-bottom: clamp(5px, 1vw, 15px);
            }
            #xp-bar-container, #ultimate-bar-container {
                width: clamp(200px, 50vw, 300px);
                height: clamp(10px, 1.5vw, 15px);
            }
            #ultimate-bar-container {
                bottom: clamp(15px, 4vw, 30px);
            }
            #ultimate-button {
  bottom: clamp(40px, 8vw, 50px);
                right: clamp(10px, 3vw, 20px);
            }
            #miniMapContainer {
                width: clamp(100px, 20vw, 150px);
                height: clamp(100px, 20vw, 150px);
                top: clamp(5px, 1.5vw, 10px);
                right: clamp(5px, 1.5vw, 10px);
            }
            .power-card, .character-card {
                width: clamp(120px, 25vw, 160px);
            }
            .level-card {
                width: clamp(200px, 40vw, 250px);
            }
            .resolution-card {
                width: clamp(150px, 30vw, 180px);
            }
            #mobileControls {
                display: flex; /* Show for small screens */
                pointer-events: all;

            #top-left-controls, #bottom-left-controls {
                top: clamp(5px, 1.5vw, 10px);
                left: clamp(5px, 1.5vw, 10px);
                gap: clamp(3px, 0.8vw, 5px);
            }
            #bottom-left-controls {
                bottom: clamp(5px, 1.5vw, 10px);
                left: clamp(5px, 1.5vw, 10px);
            }
            #high-score-modal input {
                max-width: clamp(150px, 40vw, 250px);
            }
        }

        /* Specific styles for folding phones (example media query, adjust if needed for precise devices) */
        @media (max-width: 600px) and (max-height: 1000px) and (orientation: portrait) {
            /* #gameContainer will be set by JS, but max-width/height can still apply */
            #gameContainer {
                max-width: 98vw;
                max-height: 98vh;
            
        }
</style>
</head>
<body>
<div id="gameContainer">
<canvas id="gameCanvas"></canvas>
<div id="ui">
<div id="top-left-controls">
<div class="hud-item" id="score-display">Score: 0</div>
<button class="control-button" id="pauseButton">Pause</button>
</div>
<div id="bottom-left-controls">
<div class="hud-item" id="time-display">Time: 0s</div>
<button class="control-button" id="menuButton">Menu</button>
<div class="hud-item" id="level-display">Level: 1</div>
</div>
<div id="miniMapContainer">
<canvas id="miniMapCanvas"></canvas>
</div>
<div id="xp-bar-container"><div id="xp-bar"></div></div>
<div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
<button id="ultimate-button">Wicked Mode</button>
</div>
<div class="menu" id="start-menu">
<h1>JOHNNY WICKED SURVIVORS</h1>
<p>Click or tap anywhere to move. Your character will fire automatically.</p>
<p>New: Enemies can now shoot back! Be careful of the gunmen.</p>
<button id="startButton">Start Game</button>
<button id="levelSelectButton">Level Select</button>
<button id="resolutionButton">Resolution</button> <!-- New Resolution Button -->
<button id="accessibilityButton">Accessibility</button> <!-- New Accessibility Button -->
<h3>Global High Scores</h3>
<ul id="start-menu-high-scores-list">
</ul>
</div>
<div class="menu" id="game-over-menu" style="display: none;">
<h1>GAME OVER</h1>
<h2 id="final-score">Score: 0</h2>
<h2 id="final-time">Time Survived: 0s</h2>
<h2 id="final-level">Level Reached: 1</h2>
<h3>High Scores</h3>
<ul id="high-scores-list">
<div class="high-scores-header">
  <span>Name</span>
  <span>Score</span>
  <span>Level</span>
  <span>Time</span>
</div>
</ul>
<button id="restartButton">Restart Game</button>
<button id="backToMainMenuButtonGameOver">Return to Main Menu</button> </div>
<div class="menu" id="message-box" style="display: none;">
<h3 id="message-title">Level Up!</h3>
<p id="message-text">Choose your power-ups - you pick 2x each time:</p>
<div id="power-selection"></div>
</div>
<div class="menu" id="game-menu" style="display: none;">
    <h1>Game Menu</h1>
    <button class="control-button" id="autoPlayButton">Play for Me</button> <button class="control-button" id="muteMusicButton">Mute Sound Effects</button>
    <button class="control-button" id="resumeFromMenuButton">Resume Game</button>
    <button class="control-button" id="backToMainMenuButtonFromGame">Back to Main Menu</button>
</div>
<div id="high-score-modal" style="display: none;">
<h3>New High Score!</h3>
<p>Enter your name:</p>
<input id="playerNameInput" maxlength="15" placeholder="Your Name" type="text"/>
<button id="saveScoreButton">Save Score</button>
</div>
<div class="menu" id="level-select-menu" style="display: none;">
<h1>Select Level</h1>
<div id="level-options">
</div>
<button id="backToMainMenuButton">Back</button>
</div>
<div class="menu" id="character-select-menu" style="display: none;">
<h1>Select Your Survivor</h1>
<div id="character-options" style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-top: 20px;">
<div class="character-card" data-character="johnny">
<h3>Johnny Wicked</h3>
<p>Classic survivor, balanced abilities.</p>
<p>Starting Weapon: Pistol</p>
</div>
<div class="character-card" data-character="dixie">
<h3>Dixie</h3>
<p>Dog whisperer, commands loyal companions.</p>
<p>Starting Weapon: Twin pistols + 1 canine companion</p>
</div>
</div>
<button id="backToStartMenuFromCharSelect">Back</button>
</div>

<!-- New Resolution Select Menu -->
<div class="menu" id="resolution-select-menu" style="display: none;">
    <h1>Select Resolution</h1>
    <div id="resolution-options">
        <!-- Resolution cards will be populated by JavaScript -->
    </div>
    <button id="backToMainMenuFromResolution">Back</button>
</div>

<!-- New Accessibility Menu -->
<div class="menu" id="accessibility-menu" style="display: none;">
    <h1>Accessibility Options</h1>
    <button id="backToMainMenuFromAccessibility">Back</button>
</div>

<div id="mobileControls">
    <div id="movementJoystick" class="mobile-joystick-container">
        <div class="joystick-handle"></div>
    </div>
    <div id="attackJoystick" class="mobile-joystick-container">
        <div class="joystick-handle"></div>
    </div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<script>
    // --- Local Storage High Score System ---

    // Saves a high score to local storage.
    window.saveHighScoreLocally = function(name, score, time, level, levelId) {
        try {
            const highScores = JSON.parse(localStorage.getItem('jws_highScores') || '[]');
            const newScore = {
                name: name,
                score: score,
                survivalTime: time,
                level: level,
                levelId: levelId,
                timestamp: Date.now()
            };
            highScores.push(newScore);
            highScores.sort((a, b) => b.score - a.score); // Sort descending
            const topScores = highScores.slice(0, 10); // Keep only top 10
            localStorage.setItem('jws_highScores', JSON.stringify(topScores));
            console.log("High score saved locally!");
        } catch (e) {
            console.error("Error saving high score locally: ", e);
        }
    };

    // Retrieves high scores from local storage.
    window.getHighScoresLocally = function() {
        try {
            const highScores = JSON.parse(localStorage.getItem('jws_highScores') || '[]');
            console.log("[Local Get] Fetched high score data:", highScores);
            return highScores;
        } catch (e) {
            console.error("Error getting documents from local storage: ", e);
            return [];
        }
    };

    // Saves the user's best score for a specific level.
    window.saveUserLevelScoreLocally = function(levelId, score) {
        try {
            const levelScores = JSON.parse(localStorage.getItem('jws_levelScores') || '{}');
            const currentBestScore = levelScores[levelId] || 0;

            if (score > currentBestScore) {
                levelScores[levelId] = score;
                localStorage.setItem('jws_levelScores', JSON.stringify(levelScores));
                console.log(`User's highest score for ${levelId} updated locally to ${score}.`);
            }
        } catch (e) {
            console.error(`Error saving user level score locally for ${levelId}: `, e);
        }
    };

    // Loads the user's best score for a specific level.
    window.loadUserLevelScoreLocally = function(levelId) {
        try {
            const levelScores = JSON.parse(localStorage.getItem('jws_levelScores') || '{}');
            return levelScores[levelId] || 0;
        } catch (e) {
            console.error(`Error loading user level score locally for ${levelId}: `, e);
            return 0;
        }
    };
</script>
<script>
        // Get canvas and UI elements from the DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const messageBox = document.getElementById('message-box');
        const powerSelectionDiv = document.getElementById('power-selection');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoreModal = document.getElementById('high-score-modal');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const highScoresList = document.getElementById('high-scores-list');
        const startMenuHighScoresList = document.getElementById('start-menu-high-scores-list');
        const pauseButton = document.getElementById('pauseButton'); 
        const menuButton = document.getElementById('menuButton');     
        const gameMenu = document.getElementById('game-menu');       
        const autoPlayButton = document.getElementById('autoPlayButton'); // Now in accessibility menu
        const resumeFromMenuButton = document.getElementById('resumeFromMenuButton'); 
        const levelSelectButton = document.getElementById('levelSelectButton'); 
        const levelSelectMenu = document.getElementById('level-select-menu'); 
        const levelOptionsDiv = document.getElementById('level-options'); 
        const backToMainMenuButton = document.getElementById('backToMainMenuButton'); 
        const backToMainMenuButtonFromGame = document.getElementById('backToMainMenuButtonFromGame'); 
        const characterSelectMenu = document.getElementById('character-select-menu'); 
        const characterOptionsDiv = document.getElementById('character-options'); 
        const backToStartMenuFromCharSelect = document.getElementById('backToStartMenuFromCharSelect'); 
        const backToMainMenuButtonGameOver = document.getElementById('backToMainMenuButtonGameOver');

        // New Resolution and Accessibility Menu Elements
        const resolutionButton = document.getElementById('resolutionButton');
        const resolutionSelectMenu = document.getElementById('resolution-select-menu');
        const resolutionOptionsDiv = document.getElementById('resolution-options');
        const backToMainMenuFromResolution = document.getElementById('backToMainMenuFromResolution');
        const accessibilityButton = document.getElementById('accessibilityButton');
        const accessibilityMenu = document.getElementById('accessibility-menu');
        const backToMainMenuFromAccessibility = document.getElementById('backToMainMenuFromAccessibility');


        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');

        const mobileControls = document.getElementById('mobileControls');
        const movementJoystickContainer = document.getElementById('movementJoystick');
        const attackJoystickContainer = document.getElementById('attackJoystick');
        const movementJoystickHandle = movementJoystickContainer.querySelector('.joystick-handle');
        const attackJoystickHandle = attackJoystickContainer.querySelector('.joystick-handle');

        // Mini-map elements
        const miniMapCanvas = document.getElementById('miniMapCanvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        let miniMapScale = 1;

        // Game state variables
        let gameRunning = false;
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let particles = []; 
        let gameWorld = {
            width: 3000, 
            height: 3000 
        };
        let gameSpeedMultiplier = 1; 
        let playerSpeedModifier = 1; 
        let projectileSpeedModifier = 1; 
        let bulletTimeActive = false; 
        let bulletTimeDuration = 0; 
        let spinningKnives = []; 
        let screenFlash = { active: false, duration: 0, alpha: 0 };
        
        let randomChestSpawnTimer = 0; 
        const RANDOM_CHEST_SPAWN_INTERVAL = 3; 
        const RANDOM_CHEST_SPAWN_CHANCE = 0.05; 

        let randomHeartSpawnTimer = 0; 
        const HEART_SPAWN_START_TIME = 180; 
        const HEART_SPAWN_INTERVAL = 60; 
        const HEART_SPAWN_CHANCE = 0.2; 

        let chests = []; 
        let drones = []; 
        let boomerangs = []; 
        let autoPlayActive = false;

        // Camera for a larger game world
        let camera = {
            x: 0,
            y: 0,
            width: 900, // Initial default, will be set by resolution
            height: 700, // Initial default, will be set by resolution
            zoom: 0.8 
        };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#5C6E7F', 
            baseColor: '#5C6E7F', 
            speed: 300, 
            health: 100,
            maxHealth: 100,
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10, 
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 160, 
                damageReduction: 0, 
                spinningKnivesDamage: 0, 
                spinningKnivesCount: 0, 
                burstDamage: 0,
                burstProjectileCount: 0,
                droneCount: 0, 
                droneDamage: 0, 
                droneAttackSpeed: 0, 
                shotgunPellets: 0, 
                shotgunDamage: 0, 
                shotgunSpread: 0, 
                dualUziActive: false, 
                dualUziFireRate: 0, 
                dualUziDamage: 0, 
                boomerangDamage: 0, 
                boomerangCount: 0, 
                boomerangCooldown: 4, 
                boomerangRange: 150, 
                boomerangSpeed: 400, 
                burstChargeDamage: 0, 
                burstChargeProjectileCount: 0,
                forcefieldActive: false, 
                forcefieldDamage: 0,     
                forcefieldRadius: 0,     
                leashWhipDamage: 0,      
                knifeDamage: 0,
                knifeCount: 0,
                knifeCooldown: 1.5,
                swordDamage: 0,
                swordPierce: 0,
                swordCooldown: 3,
                acidAuraDamage: 0,
                acidAuraInterval: 0,
                acidAuraRadius: 0,
            },
            upgrades: {
                damage: 0,
                attackSpeed: 0,
                health: 0,
                speed: 0,
                pierce: 0,
                multiShot: 0,
                healthRegen: 0,
                magnet: 0,
                bulletproofSuit: 0, 
                ultimateRecharge: 0,
                burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, 
                shotgun: 0, 
                dualUzi: 0,
                boomerang: 0, 
                burstCharge: 0, 
                forcefield: 0,           
                dogPack: 0,              
                dogBones: 0,             
                leashWhip: 0,            
                dogStrength: 0,          
                dogSpeed: 0,             
                knifeThrow: 0,
                swordThrow: 0,
                acidAura: 0,
            },
            burstChargeCooldown: 5, 
            burstChargeTimer: 0, 
            burstCooldown: 1,
            burstTimer: 0,
            shotgunTimer: 0, 
            dualUziTimer: 0, 
            boomerangTimer: 0, 
            lastX: initialPlayerX,
            lastY: initialPlayerY,
            animationFrame: 0,
            isMoving: false,
            vx: 0, 
            vy: 0, 
            currentShootAngle: 0, 
            forcefieldTimer: 0,      
            forcefieldHitEnemies: new Set(), 
            leashWhipTimer: 0,       
            leashWhipActive: false,
            leashWhipAnimationTimer: 0,
            leashWhipTargetX: 0,
            leashWhipTargetY: 0,
            knifeThrowTimer: 0,
            swordThrowTimer: 0,
            acidAuraTimer: 0,
            acidAuraAngle: 0,
            acidAuraHitEnemies: new Set(),
            invincible: false,
            invincibilityTimer: 0,
            flashTimer: 0,
            isFlashing: false
        };

        // Game control states
        let isPaused = false; 
        let isMenuOpen = false; 
        let lastUziSoundTime = 0; 
        const UZI_SOUND_COOLDOWN = 0.05; 
        let levelUpQueue = []; 

        // Mobile control variables
        let movementJoystickActive = false;
        let attackJoystickActive = false;
        let movementInput = { x: 0, y: 0 };
        let attackInput = { x: 0, y: 0 };
        const JOYSTICK_MAX_DIST = 50; // Max distance handle can move from center

        // Level management
        let currentLevelId = 'hotel_lobby'; 
        let currentCharacter = 'johnny';

        // Dog specific variables (for Dixie)
        let allyDogs = []; 
        let dogProjectileDamage = 0;
        let dogProjectileSpeed = 0;
        const DOG_LEASH_RADIUS = 40;

        // Resolution settings
        const RESOLUTIONS = {
            'mobile': { id: 'mobile', name: '9:21 (Mobile)', aspectRatio: 9 / 21, defaultWidth: 500, defaultHeight: 933 }, 
            'folding': { id: 'folding', name: '5:4 (Folding)', aspectRatio: 5 / 4, defaultWidth: 800, defaultHeight: 640 },
            'monitor': { id: 'monitor', name: '16:9 (Monitor)', aspectRatio: 16 / 9, defaultWidth: 900, defaultHeight: 700 }
        };
        let currentResolution = RESOLUTIONS.mobile; // Default to 9:21 for mobile

        // Enemy and power-up configuration
        const ENEMY_TYPES = ['basic', 'fast', 'tank', 'elite', 'gunner', 'drone', 'car', 'ninja', 'enemyDog', 'enemyDrone', 'cobra', 'robotDrone', 'yellowSkull', 'enforcer']; 
        const MAX_UPGRADE_LEVEL = 8;
        const POWER_OPTIONS = [
{
    id: 'acidAura',
    name: 'Acid Aura',
    description: 'Releases a circular green acid pulse every second around the player.',
    level: () => player.upgrades.acidAura || 0,
    effect: () => {
        const lvl = player.upgrades.acidAura = (player.upgrades.acidAura || 0) + 1;
        player.stats.acidAuraDamage = 20 + lvl * 10;
        player.stats.acidAuraInterval = Math.max(0.4, 1 - lvl * 0.1);
        player.stats.acidAuraRadius = 50 + lvl * 15;
    },
    next: () => `Boost acid pulse damage to ${20 + ((player.upgrades.acidAura || 0) + 1) * 10}. Radius: ${50 + ((player.upgrades.acidAura || 0) + 1) * 15}. Interval: ${(Math.max(0.4, 1 - ((player.upgrades.acidAura || 0) + 1) * 0.1)).toFixed(1)}s.`,
    characters: ['johnny', 'dixie']
},

            { id: 'damage', name: 'Increase Damage', description: 'Increases projectile damage.',
              level: () => player.upgrades.damage,
              effect: () => player.stats.damage += 10,
              next: () => `Increase projectile damage by 10. (Lvl ${player.upgrades.damage + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'attackSpeed', name: 'Increase Attack Speed', description: 'Increases the number of projectiles fired per second.',
              level: () => player.upgrades.attackSpeed,
              effect: () => player.stats.attackSpeed += 2,
              next: () => `Increase fire rate by 2. (Lvl ${player.upgrades.attackSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'health', name: 'Increase Health', description: 'Increases max health and heals you.', 
              level: () => player.upgrades.health,
              effect: () => { player.maxHealth += 25; player.health = Math.min(player.health + 25, player.maxHealth); },
              next: () => `Increase max health by 25 and heal. (Lvl ${player.upgrades.health + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'speed', name: 'Increase Speed', description: 'Increases player movement speed.',
              level: () => player.upgrades.speed,
              effect: () => player.speed += 50,
              next: () => `Increase speed by 50. (Lvl ${player.upgrades.speed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'pierce', name: 'Pierce Shot', description: 'Your projectiles can hit multiple enemies.',
              level: () => player.upgrades.pierce,
              effect: () => player.stats.pierce++,
              next: () => `Projectiles can hit one more enemy. (Lvl ${player.upgrades.pierce + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'multiShot', name: 'Multi-shot', description: 'Fire multiple projectiles at once.', 
              level: () => player.upgrades.multiShot,
              effect: () => player.stats.multiShot++,
              next: () => `Fire one more projectile per shot. (Lvl ${player.upgrades.multiShot + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'healthRegen', name: 'Health Regen', description: 'Gain passive health regeneration.', 
              level: () => player.upgrades.healthRegen,
              effect: () => player.stats.healthRegen += 0.5,
              next: () => `Increase health regen by 0.5/s. (Lvl ${player.upgrades.healthRegen + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'magnet', name: 'Magnet Range', description: 'Increases the range for collecting XP.',
              level: () => player.upgrades.magnet,
              effect: () => player.stats.magnet += 20,
              next: () => `Increase magnet range by 20. (Lvl ${player.upgrades.magnet + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'bulletproofSuit', name: 'Bulletproof Suit', description: 'Reduces damage taken from all sources.',
              level: () => player.upgrades.bulletproofSuit,
              effect: () => {
                player.upgrades.bulletproofSuit++;
                player.stats.damageReduction = Math.min(0.8, player.upgrades.bulletproofSuit * 0.05); 
              },
              next: () => `Reduce damage taken by ${((player.upgrades.bulletproofSuit + 1) * 5).toFixed(0)}%. (Lvl ${player.upgrades.bulletproofSuit + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'burstCharge', name: 'Burst Charge', description: 'Unleashes a slow, wide arc of projectiles automatically.', 
              level: () => player.upgrades.burstCharge,
              effect: () => { 
                player.upgrades.burstCharge++;
                player.stats.burstChargeDamage = 50 + player.upgrades.burstCharge * 25; 
                player.stats.burstChargeProjectileCount = 5 + player.upgrades.burstCharge * 2;
                player.burstChargeCooldown = Math.max(1, 5 - player.upgrades.burstCharge * 0.5); 
                player.burstChargeTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.burstCharge + 1) * 2} projectiles in a wide arc. Cooldown: ${(Math.max(1, 5 - (player.upgrades.burstCharge + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.burstCharge + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'burstShot', name: 'Multi-shot Burst', description: 'Fires a burst of projectiles in a circle.',
              level: () => player.upgrades.burstShot,
              effect: () => {
                player.stats.burstDamage = 10 + player.upgrades.burstShot * 5;
                player.stats.burstProjectileCount = 8 + player.upgrades.burstShot * 2;
                player.burstCooldown = 1 - (player.upgrades.burstShot * 0.1);
              },
              next: () => `Fires a circle of projectiles. (Lvl ${player.upgrades.burstShot + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'spinningKnives', name: 'Spinning Knives', description: 'Summon knives that orbit you, damaging enemies.',
              level: () => player.upgrades.spinningKnives,
              effect: () => {
                player.upgrades.spinningKnives++;
                player.stats.spinningKnivesCount++;
                player.stats.spinningKnivesDamage = 25 + player.upgrades.spinningKnives * 10;
                player.stats.spinningKnivesRange = 40 + player.upgrades.spinningKnives * 10;
                updateSpinningKnivesEffect();
              },
              next: () => `Summon ${player.upgrades.spinningKnives + 1} spinning knives (wider orbit). (Lvl ${player.upgrades.spinningKnives + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'combatDrone', name: 'Combat Drone', description: 'Summon a drone that fires at enemies. Stacks.',
              level: () => player.upgrades.combatDrone,
              effect: () => {
                player.upgrades.combatDrone++;
                player.stats.droneCount = player.upgrades.combatDrone; 
                player.stats.droneDamage = 10 + player.upgrades.combatDrone * 5; 
                player.stats.droneAttackSpeed = 1 + player.upgrades.combatDrone * 0.2; 
                updateDronesEffect(); 
              },
              next: () => `Summon ${player.upgrades.combatDrone + 1} combat drone(s). (Lvl ${player.upgrades.combatDrone + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'shotgun', name: 'Shotgun', description: 'Fires a spray of powerful, short-range pellets.', 
              level: () => player.upgrades.shotgun,
              effect: () => {
                player.upgrades.shotgun++;
                player.stats.shotgunPellets = 5 + player.upgrades.shotgun * 2;
                player.stats.shotgunDamage = 15 + player.upgrades.shotgun * 5;
                player.stats.shotgunSpread = 0.3; 
                player.shotgunTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.shotgun + 1) * 2} pellets with a short range. (Lvl ${player.upgrades.shotgun + 1}/${MAX_UPGRADE_LEVEL})`, 
              characters: ['johnny', 'dixie']
            },
            { id: 'dualUzi', name: 'Dual Uzis', description: 'Fires two continuous streams of bullets.',
              level: () => player.upgrades.dualUzi,
              effect: () => {
                player.upgrades.dualUzi++;
                player.stats.dualUziActive = true;
                player.stats.dualUziFireRate = 10 + player.upgrades.dualUzi * 5;
                player.stats.dualUziDamage = 8 + player.upgrades.dualUzi * 4;
                player.dualUziTimer = 0; 
              },
              next: () => `Fires two streams at ${10 + (player.upgrades.dualUzi + 1) * 5} bullets/s. (Lvl ${player.upgrades.dualUzi + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'boomerang', name: 'Boomerang', description: 'Launches a spinning boomerang that hits enemies and returns.',
              level: () => player.upgrades.boomerang,
              effect: () => {
                player.upgrades.boomerang++;
                player.stats.boomerangCount = 1 + Math.floor(player.upgrades.boomerang / 2); 
                player.stats.boomerangDamage = 25 + player.upgrades.boomerang * 10;
                player.stats.boomerangCooldown = Math.max(1, 4 - player.upgrades.boomerang * 0.5); 
              },
              next: () => `Launch ${1 + Math.floor((player.upgrades.boomerang + 1) / 2)} boomerangs. Cooldown: ${(Math.max(1, 4 - (player.upgrades.boomerang + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.boomerang + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'forcefield', name: 'Forcefield', description: 'Creates an energy shield that damages nearby enemies and protects you.',
              level: () => player.upgrades.forcefield,
              effect: () => {
                player.upgrades.forcefield++;
                player.stats.forcefieldActive = true; 
                player.stats.forcefieldDamage = 10 + player.upgrades.forcefield * 8;
                player.stats.forcefieldRadius = 70 + player.upgrades.forcefield * 15;
                player.stats.damageReduction = Math.min(0.8, player.stats.damageReduction + 0.02); 
                player.forcefieldTimer = 0; 
                player.forcefieldHitEnemies.clear(); 
              },
              next: () => `Creates a forcefield (Radius: ${70 + (player.upgrades.forcefield + 1) * 15}, Damage: ${10 + (player.upgrades.forcefield + 1) * 8}). Also increases damage reduction. (Lvl ${player.upgrades.forcefield + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'dogPack', name: 'Dog Pack', description: 'Summon an additional loyal dog ally.',
              level: () => player.upgrades.dogPack,
              effect: () => { player.upgrades.dogPack++; addAllyDog(); console.log(`[Dixie] Added dog. Total dogs: ${allyDogs.length}`); },
              next: () => `Summon another dog ally. (Lvl ${player.upgrades.dogPack + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogBones', name: 'Dog Bones', description: 'Your dog allies shoot bone projectiles.',
              level: () => player.upgrades.dogBones,
              effect: () => { 
                player.upgrades.dogBones++; 
                dogProjectileDamage = 10 + player.upgrades.dogBones * 5; 
                dogProjectileSpeed = 300 + player.upgrades.dogBones * 50; 
              },
              next: () => `Dogs shoot bones for ${10 + (player.upgrades.dogBones + 1) * 5} damage. (Lvl ${player.upgrades.dogBones + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'leashWhip', name: 'Leash Whip', description: 'Dixie performs a short-range whip attack.',
              level: () => player.upgrades.leashWhip,
              effect: () => { 
                player.upgrades.leashWhip++; 
                player.stats.leashWhipDamage = 20 + player.upgrades.leashWhip * 10; 
                player.leashWhipCooldown = Math.max(0.5, 2 - player.upgrades.leashWhip * 0.2); 
              },
              next: () => `Unleash a whip dealing ${20 + (player.upgrades.leashWhip + 1) * 10} damage. Cooldown: ${(Math.max(0.5, 2 - (player.upgrades.leashWhip + 1) * 0.2)).toFixed(1)}s. (Lvl ${player.upgrades.leashWhip + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogStrength', name: 'Dog Strength', description: 'Increases the damage of your dog allies.',
              level: () => player.upgrades.dogStrength,
              effect: () => { allyDogs.forEach(dog => dog.damage += 5); },
              next: () => `Increase dog melee damage by 5. (Lvl ${player.upgrades.dogStrength + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogSpeed', name: 'Dog Speed', description: 'Increases the movement speed of your dog allies.',
              level: () => player.upgrades.dogSpeed,
              effect: () => { allyDogs.forEach(dog => dog.speed += 20); },
              next: () => `Increase dog movement speed by 20. (Lvl ${player.upgrades.dogSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'knifeThrow', name: 'Knife Throw', description: 'Throws a sharp knife at the closest enemy.',
              level: () => player.upgrades.knifeThrow,
              effect: () => {
                player.upgrades.knifeThrow++;
                player.stats.knifeDamage = 20 + player.upgrades.knifeThrow * 10;
                player.stats.knifeCount = 1 + Math.floor(player.upgrades.knifeThrow / 2);
                player.stats.knifeCooldown = Math.max(0.5, 1.5 - player.upgrades.knifeThrow * 0.1);
              },
              next: () => `Throws ${1 + Math.floor((player.upgrades.knifeThrow + 1) / 2)} knives for ${20 + (player.upgrades.knifeThrow + 1) * 10} damage. Cooldown: ${(Math.max(0.5, 1.5 - (player.upgrades.knifeThrow + 1) * 0.1)).toFixed(1)}s. (Lvl ${player.upgrades.knifeThrow + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie']
            },
            { id: 'swordThrow', name: 'Sword Throw', description: 'Throws a powerful, piercing sword.',
              level: () => player.upgrades.swordThrow,
              effect: () => {
                player.upgrades.swordThrow++;
                player.stats.swordDamage = 50 + player.upgrades.swordThrow * 20;
                player.stats.swordPierce = 1 + Math.floor(player.upgrades.swordThrow / 2);
                player.stats.swordCooldown = Math.max(1, 3 - player.upgrades.swordThrow * 0.2);
              },
              next: () => `Throws a sword that pierces ${1 + Math.floor((player.upgrades.swordThrow + 1) / 2)} enemies for ${50 + (player.upgrades.swordThrow + 1) * 20} damage. Cooldown: ${(Math.max(1, 3 - (player.upgrades.swordThrow + 1) * 0.2)).toFixed(1)}s. (Lvl ${player.upgrades.swordThrow + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie']
            }
        ];
        
        let shootTimer = 0;
        let spawnTimer = 0;
        let ultimateChargePerHit = 0.5; 
        let lastShotSoundTime = 0;
        let lastEnemyHitSoundTime = 0;
        const enemyHitSoundCooldown = 0.05;


        // Tone.js audio setup (only for sound effects, music removed)
        let playerSynth;
        let enemyHitSynth;
        let levelUpSynth;
        let ultimateSynth;
        let gameOverSynth;
        let explosionSound;

        // Helper function to calculate distance
        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // --- New Collision Resolution Functions ---

        // Resolves collision between two circles (e.g., player/enemy and pillar)
        function circleCircleCollideAndResolve(c1, c2) {
            let dx = c1.x - c2.x;
            let dy = c1.y - c2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = c1.size / 2 + c2.size / 2;

            if (distance < minDistance) {
                if (distance === 0) {
                    c1.x += Math.random() * 0.1 - 0.05;
                    c1.y += Math.random() * 0.1 - 0.05;
                    return true;
                }
                let overlap = minDistance - distance;
                let normalX = dx / distance;
                let normalY = dy / distance;

                c1.x += normalX * overlap;
                c1.y += normalY * overlap;

                let dotProduct = c1.vx * normalX + c1.vy * normalY;
                if (dotProduct < 0) {
                    c1.vx -= dotProduct * normalX;
                    c1.vy -= dotProduct * normalY;
                }
                return true;
            }
            return false;
        }

        // Resolves collision between a circle and a rectangle (e.g., player/enemy and desk/chair)
        function circleRectCollideAndResolve(circle, rect) {
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let dx = circle.x - closestX;
            let dy = circle.y - closestY;
            let distanceSquared = (dx * dx) + (dy * dy);
            let radius = circle.size / 2;

            if (distanceSquared < radius * radius) {
                let distance = Math.sqrt(distanceSquared);
                if (distance === 0) {
                    let overlapX = Math.min(Math.abs(circle.x - rect.x), Math.abs((rect.x + rect.width) - circle.x));
                    let overlapY = Math.min(Math.abs(circle.y - rect.y), Math.abs((rect.y + rect.height) - circle.y));

                    if (overlapX < overlapY) {
                        circle.x += (circle.x > rect.x + rect.width / 2 ? 1 : -1) * (radius - Math.abs(dx));
                    } else {
                        circle.y += (circle.y > rect.y + rect.height / 2 ? 1 : -1) * (radius - Math.abs(dy));
                    }
                } else {
                    let overlap = radius - distance;
                    let normalX = dx / distance;
                    let normalY = dy / distance;

                    circle.x += normalX * overlap;
                    circle.y += normalY * overlap;

                    let dotProduct = circle.vx * normalX + circle.vy * normalY;
                    if (dotProduct < 0) {
                        circle.vx -= dotProduct * normalX;
                        circle.vy -= dotProduct * normalY;
                    }
                }
                return true;
            }
            return false;
        }

        // --- End Collision Resolution Functions ---

        // Function to play sound effects
        function playSound(type) {
            switch(type) {
                case 'playerShot':
                    if (playerSynth) playerSynth.triggerAttackRelease("C4", "8n");
                    break;
                case 'enemyHit':
                    if (enemyHitSynth) enemyHitSynth.triggerAttackRelease("16n");
                    break;
                case 'levelUp':
                    if (levelUpSynth) levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    if (ultimateSynth) ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    if (gameOverSynth) gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    if (explosionSound) explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            Tone.start();
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5
                }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.1, decay: 0.5, sustain: 0.3, release: 1
                }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001, decay: 0.4, release: 0.2
                },
                harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            
            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); 
            drawEnemies();
            drawPlayer();
            drawSpinningKnives(); 
            drawAllyDogs(); 
            drawDrones(); 
            drawBoomerangs(); 
            if (ultimateActive) {
                drawUltimateEffect();
            }
            if (player.stats.forcefieldActive) {
                drawForcefield();
            }
            if (player.upgrades.acidAura > 0) {
                drawAcidAura();
            }
            if (player.leashWhipActive) {
                drawLeashWhip();
            }
            drawDamageNumbers();
            drawParticles(); 
            if (screenFlash.active) {
                drawScreenFlash();
            }

            ctx.restore(); 
            drawUI();
            drawMiniMap(); 
        }

        function drawScreenFlash() {
            ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash.alpha})`;
            // Draw relative to game world, not camera
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
        }
        
        function drawBackground() {
            let bgColor;
            let gridColor;

            if (currentLevelId === 'hotel_lobby') {
                bgColor = '#101010';
                gridColor = '#222222';
            } else if (currentLevelId === 'the_park') {
                bgColor = '#225522';
                gridColor = '#336633';
            } else if (currentLevelId === 'desert_oasis') { 
                bgColor = '#C2B280';
                gridColor = '#B09F6E';
            } else if (currentLevelId === 'factory_realm') {
                bgColor = '#2C3E50';
                gridColor = '#34495E';
            }
            else {
                bgColor = '#101010';
                gridColor = '#222222';
            }

            // Fill entire game world background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, gameWorld.width, gameWorld.height); 

            const patternSize = 50;
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            // Draw grid lines across the entire game world
            for (let x = 0; x <= gameWorld.width; x += patternSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gameWorld.height);
                ctx.stroke();
            }
            for (let y = 0; y <= gameWorld.height; y += patternSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gameWorld.width, y);
                ctx.stroke();
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') { 
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    if (obstacle.type === 'cactus') {
                        ctx.fillStyle = '#6B8E23';
                        ctx.fillRect(obstacle.x - camera.x - obstacle.width * 0.4, obstacle.y - camera.y - obstacle.width * 0.4, obstacle.width * 0.1, obstacle.width * 0.1);
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.3, obstacle.y - camera.y - obstacle.width * 0.3, obstacle.width * 0.1, obstacle.width * 0.1);
                        ctx.fillRect(obstacle.x - camera.x - obstacle.width * 0.2, obstacle.y - camera.y + obstacle.width * 0.3, obstacle.width * 0.1, obstacle.width * 0.1);
                    }
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair' || obstacle.type === 'bush' || obstacle.type === 'bench' || obstacle.type === 'old_car') { 
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                    if (obstacle.type === 'old_car') {
                        ctx.fillStyle = '#36454F';
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.2, obstacle.y - camera.y + obstacle.height * 0.2, obstacle.width * 0.2, obstacle.height * 0.6);
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.6, obstacle.y - camera.y + obstacle.height * 0.2, obstacle.width * 0.2, obstacle.height * 0.6);
                        ctx.fillStyle = '#111111';
                        ctx.beginPath();
                        ctx.arc(obstacle.x - camera.x + obstacle.width * 0.15, obstacle.y - camera.y + obstacle.height * 0.9, obstacle.width * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(obstacle.x - camera.x + obstacle.width * 0.85, obstacle.y - camera.y + obstacle.height * 0.9, obstacle.width * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (obstacle.type === 'machine') {
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                    ctx.fillStyle = '#34495E';
                    ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.1, obstacle.y - camera.y + obstacle.height * 0.1, obstacle.width * 0.8, obstacle.height * 0.2);
                    ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.1, obstacle.y - camera.y + obstacle.height * 0.7, obstacle.width * 0.8, obstacle.height * 0.2);
                    ctx.fillStyle = '#C0392B';
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x + obstacle.width * 0.5, obstacle.y - camera.y + obstacle.height * 0.5, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'conveyor_belt') {
                    ctx.fillStyle = '#7F8C8D';
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                    ctx.strokeStyle = '#2C3E50';
                    ctx.lineWidth = 2;
                    const lineSpacing = 10;
                    if (obstacle.width > obstacle.height) {
                        for (let i = 0; i < obstacle.width; i += lineSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x - camera.x + i, obstacle.y - camera.y);
                            ctx.lineTo(obstacle.x - camera.x + i, obstacle.y - camera.y + obstacle.height);
                            ctx.stroke();
                        }
                    } else {
                        for (let i = 0; i < obstacle.height; i += lineSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x - camera.x, obstacle.y - camera.y + i);
                            ctx.lineTo(obstacle.x - camera.x + obstacle.width, obstacle.y - camera.y + i);
                            ctx.stroke();
                        }
                    }
                } else if (obstacle.type === 'pipe') {
                    ctx.fillStyle = '#95A5A6';
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                    ctx.strokeStyle = '#34495E';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                }
            });
        }
        
        function drawPixelArt(ctx, x, y, spriteName, frame, size, isMoving) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;
            const currentCharacter = player.character || 'johnny';

            if (spriteName === 'player') {
                if (player.invincible && player.isFlashing) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                // Body
                ctx.fillStyle = player.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Legs - dynamic based on movement or character-specific idle pose
                if (isMoving) {
                    const legOffset = Math.sin(frame * 0.5) * s/4; 
                    ctx.fillStyle = player.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    ctx.fillStyle = player.color; 
                    if (currentCharacter === 'johnny') {
                        const idleOffset = Math.sin(survivalTime * 2) * s * 0.05;
                        ctx.fillRect(screenX - s/4, screenY + s + idleOffset, s/4, s); 
                        ctx.fillRect(screenX + s/4, screenY + s - idleOffset, s/4, s); 
                    } else {
                        ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                        ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                    }
                }

                // Arms - dynamic, facing shoot direction
                let armLength = s * 0.8;
                let armWidth = s * 0.3;
                let shoulderXOffset = s * 0.4; 
                let shoulderYOffset = s * 0.5; 

                if (currentCharacter === 'dixie') {
                    armLength = s * 1.5; 
                    armWidth = s * 0.2; 
                    shoulderXOffset = s * 0.5; 
                    shoulderYOffset = s * 0.6; 
                }

                ctx.fillStyle = player.color; 

                if ((currentCharacter === 'johnny') || (currentCharacter === 'dixie' && player.stats.dualUziActive)) {
                    const gunSize = s * 0.4;
                    const gunBarrelLength = s * 0.6;
                    const armBaseOffset = s * 0.2; 
                    const currentArmLength = (currentCharacter === 'johnny' ? s * 0.8 : s * 1.5);

                    const armAngle = player.currentShootAngle;
                    
                    let gunOffsets = [];
                    if (currentCharacter === 'johnny') {
                        gunOffsets.push(0);
                    } else if (currentCharacter === 'dixie' && player.stats.dualUziActive) {
                        gunOffsets.push(-armBaseOffset);
                        gunOffsets.push(armBaseOffset);
                    }

                    gunOffsets.forEach(offset => {
                        const armEndX = screenX + Math.cos(armAngle + Math.PI/2) * offset + Math.cos(armAngle) * currentArmLength;
                        const armEndY = screenY + Math.sin(armAngle + Math.PI/2) * offset + Math.sin(armAngle) * currentArmLength;

                        ctx.save();
                        ctx.translate(screenX + Math.cos(armAngle + Math.PI/2) * offset, screenY + Math.sin(armAngle + Math.PI/2) * offset);
                        ctx.rotate(armAngle);
                        ctx.fillRect(0, -armWidth / 2, currentArmLength, armWidth);
                        ctx.restore();

                        ctx.save();
                        ctx.translate(armEndX, armEndY);
                        ctx.rotate(armAngle);
                        ctx.fillStyle = '#444';
                        ctx.fillRect(0, -gunSize/4, gunBarrelLength, gunSize/2);
                        ctx.fillRect(-gunSize/2, -gunSize/2, gunSize, gunSize);
                        ctx.restore();
                    });

                } else {
                    ctx.save();
                    ctx.translate(screenX - shoulderXOffset, screenY - shoulderYOffset);
                    ctx.rotate(player.currentShootAngle);
                    ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                    ctx.restore();

                    ctx.save();
                    ctx.translate(screenX + shoulderXOffset, screenY - shoulderYOffset);
                    ctx.rotate(player.currentShootAngle);
                    ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                    ctx.restore();
                }

            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;

            if (enemy.controlled) {
                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 
            }

            if (enemy.type === 'robotDrone') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(screenX - s * 0.4, screenY - s * 0.1, s * 0.8, s * 0.2); 
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.4, s * 0.2, s * 0.8); 
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'yellowSkull') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY - s * 0.5, s * 0.4, 0, Math.PI * 2); 
                ctx.fill();

                ctx.fillStyle = '#000000'; 
                ctx.beginPath();
                ctx.arc(screenX - s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(screenX + s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.3, s * 0.2, s * 0.1); 
                ctx.fillRect(screenX - s * 0.2, screenY - s * 0.1, s * 0.4, s * 0.05); 
            } else if (enemy.type === 'enforcer') {
                ctx.fillStyle = enemy.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2); 
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(screenX - s*0.6, screenY - s*0.5, s*1.2, s*0.2); 
                ctx.fillRect(screenX - s*0.1, screenY - s*0.8, s*0.2, s*0.4); 
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY - s*0.6, s*0.15, 0, Math.PI * 2); 
                ctx.fill();
            }
            else {
                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);
                
                // Body
                ctx.fillStyle = enemy.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Arms (simplified, similar to player)
                ctx.fillRect(screenX - s/2 - s/4, screenY - s, s/4, s); 
                ctx.fillRect(screenX + s/2, screenY - s, s/4, s); 
                
                // Legs (animated, similar to player)
                const isEnemyMoving = Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0;
                if (isEnemyMoving) {
                    const legOffset = Math.sin(enemy.animationFrame * 0.5) * s/4; 
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                }

                if (enemy.type === 'tank') {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                } else if (enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone') { 
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
                } else if (enemy.type === 'elite') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (enemy.type === 'car') {
                    ctx.fillStyle = '#663300'; 
                    ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                } else if (enemy.type === 'ninja') {
                    ctx.fillStyle = '#333333'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                    ctx.fillStyle = '#1a1a1a'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
                } else if (enemy.type === 'enemyDog') { 
                    drawDogPixelArt(ctx, enemy, screenX, screenY, s);
                } else if (enemy.type === 'enemyDrone') {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    ctx.fillStyle = '#666666'; 
                    ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                    ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
                } else if (enemy.type === 'cobra') {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    if (enemy.segmentIndex === 0) {
                        ctx.fillStyle = '#FFD700'; 
                        ctx.beginPath();
                        ctx.arc(screenX + s/2, screenY, s/4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            if (enemy.controlled) {
                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            }
        }

        function drawDogPixelArt(ctx, dog, screenX, screenY, s) {
            ctx.fillStyle = dog.color; 
            ctx.beginPath();
            ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(screenX + s * 0.3, screenY - s * 0.4);
            ctx.lineTo(screenX + s * 0.5, screenY - s * 0.6);
            ctx.lineTo(screenX + s * 0.6, screenY - s * 0.3);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(screenX - s * 0.6, screenY + s * 0.1);
            ctx.lineTo(screenX - s * 0.8, screenY - s * 0.1);
            ctx.lineTo(screenX - s * 0.7, screenY + s * 0.2);
            ctx.fill();

            ctx.fillRect(screenX - s * 0.4, screenY + s * 0.4, s * 0.15, s * 0.3);
            ctx.fillRect(screenX + s * 0.2, screenY + s * 0.4, s * 0.15, s * 0.3);
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size, player.isMoving);

            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;

            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                
                drawEnemyPixelArt(ctx, enemy);
            });
        }

        function drawBoneProjectile(ctx, x, y, size) {
            ctx.fillStyle = '#D2B48C';
            ctx.beginPath();
            ctx.ellipse(x, y, size * 1.5, size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(x - size * 1.5, y, size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 1.5, y, size * 0.7, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                
                if (p.color === '#D2B48C') {
                    drawBoneProjectile(ctx, screenX, screenY, p.size);
                } else if (p.type === 'knife') {
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.beginPath();
                    ctx.moveTo(-p.size, -p.size / 4);
                    ctx.lineTo(p.size, 0);
                    ctx.lineTo(-p.size, p.size / 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'sword') {
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.fillRect(-p.size * 1.5, -p.size / 4, p.size * 3, p.size / 2);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-p.size * 1.8, -p.size / 2, p.size * 0.5, p.size);
                    ctx.restore();
                }
                else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();

                if (p.isAoE) {
                    const opacity = 0.5 * (1 - (p.lifetime / p.maxLifetime)); 
                    ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.aoeRadius * (1 - opacity), 0, Math.PI * 2); 
                    ctx.stroke();
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                if (p.type === 'xp') {
                    ctx.fillStyle = '#FFD700'; 
                    ctx.shadowColor = '#FFA500'; 
                    ctx.shadowBlur = 8; 
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); 
                    ctx.fill();
                    ctx.shadowBlur = 0; 
                } else if (p.type === 'heart') {
                    ctx.fillStyle = '#FF0000'; 
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.moveTo(screenX + p.size * 0.5, screenY + p.size * 0.3);
                    ctx.bezierCurveTo(
                        screenX + p.size * 1.0, screenY - p.size * 0.7,
                        screenX + p.size * 1.5, screenY + p.size * 0.3,
                        screenX, screenY + p.size * 1.0
                    );
                    ctx.bezierCurveTo(
                        screenX - p.size * 1.5, screenY + p.size * 0.3,
                        screenX - p.size * 1.0, screenY - p.size * 0.7,
                        screenX - p.size * 0.5, screenY + p.size * 0.3
                    );
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; 
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; 
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);
            });
        }

        function drawSpinningKnives() {
            spinningKnives.forEach(knife => {
                const screenX = knife.x - camera.x;
                const screenY = knife.y - camera.y;
                ctx.fillStyle = '#AAAAAA'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, knife.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawAllyDogs() {
            allyDogs.forEach(dog => {
                const s = dog.size;
                const screenX = dog.x - camera.x;
                const screenY = dog.y - camera.y;

                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 

                drawDogPixelArt(ctx, dog, screenX, screenY, s);

                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            });
        }

        function drawDrones() {
            drones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;

                ctx.fillStyle = '#00FFFF'; 
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                ctx.fillStyle = '#666666'; 
                ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
            });
        }

        function drawBoomerangs() {
            boomerangs.forEach(b => {
                const screenX = b.x - camera.x;
                const screenY = b.y - camera.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 8); 
                
                ctx.fillStyle = b.color; 
                const bananaWidth = b.size * 0.6; 
                const bananaLength = b.size * 2; 

                ctx.beginPath();
                ctx.moveTo(0, -bananaWidth / 2);
                ctx.bezierCurveTo(
                    bananaLength * 0.5, -bananaWidth * 1.5, 
                    bananaLength * 0.5, bananaWidth * 1.5,  
                    0, bananaWidth / 2                      
                );
                ctx.bezierCurveTo(
                    -bananaLength * 0.5, bananaWidth * 1.5, 
                    -bananaLength * 0.5, -bananaWidth * 1.5, 
                    0, -bananaWidth / 2                     
                );
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }
        
        function drawUltimateEffect() {
            ctx.beginPath();
            const pulseSize = player.size * (1 + 0.5 * Math.sin(survivalTime * 10));
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.arc(screenX, screenY, pulseSize * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.5 * (ultimateDuration/3)})`; 
            ctx.lineWidth = 10;
            ctx.stroke();

            ctx.fillStyle = `rgba(255, 102, 0, ${0.1 * (ultimateDuration/3)})`; 
            // Fill the entire visible camera area
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height); 
        }

        function drawForcefield() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            const pulse = 1 + 0.1 * Math.sin(survivalTime * 5); 
            const currentRadius = player.stats.forcefieldRadius * pulse;

            ctx.beginPath();
            ctx.arc(screenX, screenY, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.7 * (1 - Math.abs(Math.sin(survivalTime * 2)) * 0.2)})`; 
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = `rgba(0, 255, 255, ${0.1 * (1 - Math.abs(Math.sin(survivalTime * 2)) * 0.2)})`; 
            ctx.fill();
        }

        function drawAcidAura() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            const currentRadius = player.stats.acidAuraRadius * (1 + 0.1 * Math.sin(player.acidAuraTimer * 10));
            const rotationSpeed = 2;
            const startAngle = player.acidAuraAngle;
            const endAngle = player.acidAuraAngle + Math.PI;
            
            ctx.beginPath();
            ctx.arc(screenX, screenY, currentRadius, startAngle, endAngle);
            ctx.lineTo(screenX, screenY);
            ctx.closePath();
            ctx.fillStyle = `rgba(0, 255, 0, ${0.3 + 0.2 * Math.sin(player.acidAuraTimer * 5)})`;
            ctx.fill();

            ctx.strokeStyle = `rgba(0, 255, 0, ${0.6 + 0.2 * Math.sin(player.acidAuraTimer * 5)})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawLeashWhip() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;

            const baseWhipLength = 150;
            const whipLengthPerLevel = 20;
            const currentWhipLength = baseWhipLength + player.upgrades.leashWhip * whipLengthPerLevel;

            let whipAngle = player.currentShootAngle;
            const closestEnemy = findClosestEnemy();
            if (closestEnemy) {
                whipAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            }

            const endX = screenX + Math.cos(whipAngle) * currentWhipLength;
            const endY = screenY + Math.sin(whipAngle) * currentWhipLength;

            const opacity = player.leashWhipAnimationTimer / 0.2;
            const lineWidth = 5 + player.upgrades.leashWhip;

            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            const midX = screenX + Math.cos(whipAngle + Math.PI/4) * currentWhipLength / 2;
            const midY = screenY + Math.sin(whipAngle + Math.PI/4) * currentWhipLength / 2;
            ctx.quadraticCurveTo(midX, midY, endX, endY);
            
            ctx.strokeStyle = `rgba(139, 69, 19, ${opacity})`;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(endX, endY, lineWidth * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 223, 0, ${opacity})`;
            ctx.fill();
        }


        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `Time: ${minutes}:${seconds}`;
            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
            ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;

            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateButton.classList.add('ready');
            } else {
                ultimateButton.classList.remove('ready');
            }
        }
        
        function showDamageNumber(damage, x, y) {
            damageNumbers.push({
                x: x,
                y: y,
                text: Math.round(damage),
                lifetime: 1
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const screenX = d.x - camera.x;
                const screenY = d.y - camera.y;
                ctx.fillStyle = `rgba(255, 50, 50, ${d.lifetime})`;
                ctx.font = `14px 'Chakra Petch'`;
                ctx.textAlign = 'center';
                ctx.fillText(d.text, screenX, screenY);
            });
        }

        function drawParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }

        function drawMiniMap() {
            miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#1a1a1a';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#444444'; 
            obstacles.forEach(obstacle => {
                const miniX = obstacle.x * miniMapScale;
                const miniY = obstacle.y * miniMapScale;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(miniX, miniY, obstacle.width / 2 * miniMapScale, 0, Math.PI * 2);
                    miniMapCtx.fill();
                } else {
                    miniMapCtx.fillRect(miniX, miniY, obstacle.width * miniMapScale, obstacle.height * miniMapScale);
                }
            });

            miniMapCtx.fillStyle = '#ff0000'; 
            enemies.forEach(enemy => {
                const miniX = enemy.x * miniMapScale;
                const miniY = enemy.y * miniMapScale;
                miniMapCtx.fillStyle = enemy.controlled ? '#00ff66' : '#ff0000'; 
                miniMapCtx.beginPath();
                miniMapCtx.arc(miniX, miniY, enemy.size / 2 * miniMapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            const miniPlayerX = player.x * miniMapScale;
            const miniPlayerY = player.y * miniMapScale;
            miniMapCtx.fillStyle = '#00ffff'; 
            miniMapCtx.beginPath();
            miniMapCtx.arc(miniPlayerX, miniPlayerY, player.size / 2 * miniMapScale, 0, Math.PI * 2);
            miniMapCtx.fill();

            chests.forEach(chest => {
                const miniX = chest.x * miniMapScale;
                const miniY = chest.y * miniMapScale;
                const chestMiniSize = chest.size * miniMapScale * 1.5; 
                miniMapCtx.fillStyle = '#FFD700'; 
                miniMapCtx.fillRect(miniX - chestMiniSize / 2, miniY - chestMiniSize / 2, chestMiniSize, chestMiniSize);
            });

            powerups.forEach(p => {
                if (p.type === 'heart') {
                    const miniX = p.x * miniMapScale;
                    const miniY = p.y * miniMapScale;
                    const heartMiniSize = p.size * miniMapScale * 1.5; 
                    miniMapCtx.fillStyle = '#FF0000';
                    miniMapCtx.beginPath();
                    miniMapCtx.moveTo(miniX + heartMiniSize * 0.5, miniY + heartMiniSize * 0.3);
                    miniMapCtx.bezierCurveTo(
                        miniX + heartMiniSize * 1.0, miniY - heartMiniSize * 0.7,
                        miniX + heartMiniSize * 1.5, miniY + heartMiniSize * 0.3,
                        miniX, miniY + heartMiniSize * 1.0 
                    );
                    miniMapCtx.bezierCurveTo(
                        miniX - heartMiniSize * 1.5, miniY + heartMiniSize * 0.3,
                        miniX - heartMiniSize * 1.0, miniY - heartMiniSize * 0.7, 
                        miniX - heartMiniSize * 0.5, miniY + heartMiniSize * 0.3 // Corrected to miniY
                    );
                    miniMapCtx.closePath(); // Ensure path is closed
                    miniMapCtx.fill();
                }
            });
        }

        function hideAllMenus() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none'; 
            messageBox.style.display = 'none';
            levelSelectMenu.style.display = 'none'; 
            characterSelectMenu.style.display = 'none'; 
            highScoreModal.style.display = 'none';
            resolutionSelectMenu.style.display = 'none'; // Hide new menu
            accessibilityMenu.style.display = 'none'; // Hide new menu
        }

        function showStartMenu() {
            hideAllMenus();
            startMenu.style.display = 'block';
            displayHighScores('start-menu-high-scores-list');
        }
        
        function showGameOverMenu() {
            hideAllMenus();
            gameOverMenu.style.display = 'block';
        }

        function showLevelSelectMenu() {
            hideAllMenus();
            levelSelectMenu.style.display = 'block';
            populateLevelOptions();
        }

        function showCharacterSelectMenu() {
            hideAllMenus();
            characterSelectMenu.style.display = 'block';
        }

        // New functions for Resolution and Accessibility menus
        function showResolutionSelectMenu() {
            hideAllMenus();
            resolutionSelectMenu.style.display = 'block';
            populateResolutionOptions();
        }

        function showAccessibilityMenu() {
            hideAllMenus();
            accessibilityMenu.style.display = 'block';
        }


        function populateLevelOptions() {
            levelOptionsDiv.innerHTML = ''; 

            const highestHotelLobbyScore = window.loadUserLevelScoreLocally('hotel_lobby');
            const highestTheParkScore = window.loadUserLevelScoreLocally('the_park');
            const highestCasablancaScore = window.loadUserLevelScoreLocally('desert_oasis');
            const highestFactoryScore = window.loadUserLevelScoreLocally('factory_realm');

            const levels = [
                { id: 'hotel_lobby', name: 'Hotel Lobby', unlockScore: 0, description: 'The classic battleground.' },
                { id: 'the_park', name: 'The Park', unlockScore: 0, description: 'A green oasis, full of danger.' },
                { id: 'desert_oasis', name: 'Casablanca', unlockScore: 5000, description: 'A scorching landscape with hidden dangers.' }, 
                { id: 'factory_realm', name: 'Realm of the Forgotten Factory', unlockScore: 10000, description: 'A desolate factory, full of menacing machines.' }
            ];

            levels.forEach(level => {
                const card = document.createElement('div');
                card.className = 'level-card';
                card.innerHTML = `<h3>${level.name}</h3><p>${level.description}</p>`;

                let isLocked = false;
                
                if (level.id === 'desert_oasis' && level.unlockScore > 0) {
                    const maxScore = Math.max(highestHotelLobbyScore, highestTheParkScore, highestCasablancaScore, highestFactoryScore); 
                    if (maxScore < level.unlockScore) {
                        isLocked = true;
                        card.classList.add('locked');
                        const unlockInfo = document.createElement('p');
                        unlockInfo.className = 'unlock-info';
                        unlockInfo.textContent = `Unlock: ${level.unlockScore} Score in Any Level (Your Best: ${maxScore})`;
                        card.appendChild(unlockInfo);
                    }
                } else if (level.id === 'factory_realm' && level.unlockScore > 0) {
                    const maxScore = Math.max(highestHotelLobbyScore, highestTheParkScore, highestCasablancaScore, highestFactoryScore);
                    if (maxScore < level.unlockScore) {
                        isLocked = true;
                        card.classList.add('locked');
                        const unlockInfo = document.createElement('p');
                        unlockInfo.className = 'unlock-info';
                        unlockInfo.textContent = `Unlock: ${level.unlockScore} Score in Any Level (Your Best: ${maxScore})`;
                        card.appendChild(unlockInfo);
                    }
                }

                if (!isLocked) {
                    card.addEventListener('click', () => {
                        currentLevelId = level.id;
                        showCharacterSelectMenu(); 
                    });
                }
                levelOptionsDiv.appendChild(card);
            });
        }

        function populateResolutionOptions() {
            resolutionOptionsDiv.innerHTML = '';
            for (const key in RESOLUTIONS) {
                const resolution = RESOLUTIONS[key];
                const card = document.createElement('div');
                card.className = 'resolution-card';
                card.innerHTML = `
                    <h3>${resolution.name}</h3>
                    <p>Aspect Ratio: ${resolution.aspectRatio.toFixed(2)}</p>
                `;
                card.addEventListener('click', () => setResolution(key));
                resolutionOptionsDiv.appendChild(card);
            }
        }
        
        function updatePlayer(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            if (autoPlayActive) {
                let targetX = player.x;
                let targetY = player.y;
                let desiredMovementX = 0;
                let desiredMovementY = 0;

                const dangerRadius = 200;
                const escapeSpeedMultiplier = 1.5;
                const approachSpeedMultiplier = 1;
                let currentSpeed = player.speed;

                let closestEnemy = null;
                let minEnemyDistance = Infinity;
                enemies.forEach(enemy => {
                    const d = dist(player, enemy);
                    if (d < minEnemyDistance) {
                        minEnemyDistance = d;
                        closestEnemy = enemy;
                    }
                });

                if (closestEnemy && minEnemyDistance < dangerRadius) {
                    const angleAway = Math.atan2(player.y - closestEnemy.y, player.x - closestEnemy.x);
                    desiredMovementX = Math.cos(angleAway);
                    desiredMovementY = Math.sin(angleAway);
                    currentSpeed *= escapeSpeedMultiplier;
                } else {
                    let closestHeart = null;
                    let minHeartDistance = Infinity;
                    powerups.forEach(p => {
                        if (p.type === 'heart') {
                            const d = dist(player, p);
                            if (d < minHeartDistance) {
                                minHeartDistance = d;
                                closestHeart = p;
                            }
                        }
                    });

                    if (player.health < player.maxHealth * 0.5 && closestHeart) {
                        const angleToHeart = Math.atan2(closestHeart.y - player.y, closestHeart.x - player.x);
                        desiredMovementX = Math.cos(angleToHeart);
                        desiredMovementY = Math.sin(angleToHeart);
                        currentSpeed *= approachSpeedMultiplier;
                    } else {
                        let closestPickup = null;
                        let minPickupDistance = Infinity;
                        [...powerups.filter(p => p.type === 'xp'), ...chests].forEach(p => {
                            const d = dist(player, p);
                            if (d < minPickupDistance) {
                                minPickupDistance = d;
                                closestPickup = p;
                            }
                        });

                        if (closestPickup) {
                            const angleToPickup = Math.atan2(closestPickup.y - player.y, closestPickup.x - player.x);
                            desiredMovementX = Math.cos(angleToPickup);
                            desiredMovementY = Math.sin(angleToPickup);
                            currentSpeed *= approachSpeedMultiplier;
                        } else {
                            desiredMovementX = Math.random() * 2 - 1;
                            desiredMovementY = Math.random() * 2 - 1;
                        }
                    }
                }

                player.vx = desiredMovementX * currentSpeed;
                player.vy = desiredMovementY * currentSpeed;

                player.targetX = player.x + player.vx;
                player.targetY = player.y + player.vy;

            } else {
                // Manual play logic (with joystick input if active)
                let dx = 0;
                let dy = 0;

                if (movementInput.x !== 0 || movementInput.y !== 0) {
                    dx = movementInput.x;
                    dy = movementInput.y;
                } else {
                    dx = player.targetX - player.x;
                    dy = player.targetY - player.y;
                }
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                player.isMoving = distance > 5 || movementInput.x !== 0 || movementInput.y !== 0;

                if (player.isMoving) {
                    const angle = Math.atan2(dy, dx);
                    const currentSpeed = player.speed * (ultimateActive ? playerSpeedModifier : 1);
                    player.vx = Math.cos(angle) * currentSpeed;
                    player.vy = Math.sin(angle) * currentSpeed;
                } else {
                    player.vx = 0; 
                    player.vy = 0; 
                }
            }


            let newX = player.x + player.vx * effectiveDt;
            let newY = player.y + player.vy * effectiveDt;

            let tempPlayer = {
                x: newX,
                y: newY,
                size: player.size,
                vx: player.vx,
                vy: player.vy
            };
            
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus' || obstacle.type === 'machine' || obstacle.type === 'conveyor_belt' || obstacle.type === 'pipe') {
                    let obstacleCircle = {
                        x: obstacle.x,
                        y: obstacle.y,
                        size: obstacle.width 
                    };
                    circleCircleCollideAndResolve(tempPlayer, obstacleCircle);
                } else { 
                    circleRectCollideAndResolve(tempPlayer, obstacle);
                }
            });

            player.x = tempPlayer.x;
            player.y = tempPlayer.y;
            player.vx = tempPlayer.vx; 
            player.vy = tempPlayer.vy;

            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
            
            if (player.isMoving) {
                player.animationFrame = (player.animationFrame + effectiveDt * 10) % 4;
            } else {
                player.animationFrame = 0;
            }
        
            player.health += player.stats.healthRegen * effectiveDt;
            player.health = Math.min(player.health + player.stats.healthRegen * effectiveDt, player.maxHealth);

            if (player.invincible) {
                player.invincibilityTimer -= effectiveDt;
                player.flashTimer += effectiveDt;

                if (player.flashTimer >= 0.1) {
                    player.isFlashing = !player.isFlashing;
                    player.flashTimer = 0;
                }

                if (player.invincibilityTimer <= 0) {
                    player.invincible = false;
                    player.isFlashing = false;
                    player.color = player.baseColor;
                }
            }
        
            if (player.upgrades.burstCharge > 0 && player.burstChargeTimer <= 0) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; 
                    const numProjectiles = player.stats.burstChargeProjectileCount;
                    const arcSpread = 0.8; 
                    const angleStep = arcSpread / (numProjectiles > 1 ? (numProjectiles - 1) : 1);
                    const startAngle = angle - arcSpread / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const projectileAngle = startAngle + i * angleStep;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            vy: Math.sin(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            size: 5, 
                            damage: ultimateActive ? player.stats.burstChargeDamage * 3 : player.stats.burstChargeDamage,
                            color: ultimateActive ? '#ff9933' : '#FFFFFF', 
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    player.burstChargeTimer = player.burstChargeCooldown;
                    playSound('playerShot'); 
                }
            }
        
            // Determine player shoot angle for Johnny's pistol or other directed attacks
            let shootAngle = 0;
            const closestEnemy = findClosestEnemy();
            if (closestEnemy) {
                shootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            } else if (attackInput.x !== 0 || attackInput.y !== 0) {
                shootAngle = Math.atan2(attackInput.y, attackInput.x);
            }

            player.currentShootAngle = shootAngle; // Update player's visual facing direction

            // Johnny's default attack (pistol)
            if (currentCharacter === 'johnny' && shootTimer >= 1 / player.stats.attackSpeed) {
                if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                    let currentMultiShot = player.stats.multiShot;
                    let currentProjectileSpeed = player.stats.projectileSpeed;
                    let currentDamage = player.stats.damage;

                    for (let i = 0; i < currentMultiShot; i++) {
                        const spread = (i - (currentMultiShot - 1) / 2) * 0.1; 
                        const projectileAngle = shootAngle + spread;
                        
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            vy: Math.sin(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            size: 3,
                            damage: ultimateActive ? currentDamage * 3 : currentDamage,
                            color: ultimateActive ? '#ff6600' : '#d1d1d1',
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    if (survivalTime - lastShotSoundTime >= 5) {
                        playSound('playerShot'); 
                        lastShotSoundTime = survivalTime;
                    }
                }
                
                shootTimer = 0;
            }

            if (player.stats.burstDamage > 0 && player.burstTimer >= player.burstCooldown) {
                if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                    player.currentShootAngle = shootAngle;
                }
                const numProjectiles = player.stats.burstProjectileCount;
                const angleStep = (Math.PI * 2) / numProjectiles;
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = i * angleStep;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        vy: Math.sin(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        size: 3,
                        damage: player.stats.burstDamage,
                        color: ultimateActive ? '#ff6600' : '#d1d1d1',
                        pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                        hits: 0
                    });
                }
                player.burstTimer = 0;
                if (survivalTime - lastShotSoundTime >= 5) {
                    playSound('playerShot'); 
                    lastShotSoundTime = survivalTime;
                }
            }

            if (player.upgrades.shotgun > 0) {
                player.shotgunTimer += effectiveDt;
                const shotgunCooldown = 0.8 / (1 + player.upgrades.shotgun * 0.1); 
                if (player.shotgunTimer >= shotgunCooldown) {
                    if (closestEnemy && dist(player, closestEnemy) < 200 || attackInput.x !== 0 || attackInput.y !== 0) { 
                        player.currentShootAngle = shootAngle; 
                        for (let i = 0; i < player.stats.shotgunPellets; i++) {
                            const spread = (i - (player.stats.shotgunPellets - 1) / 2) * player.stats.shotgunSpread;
                            const projectileAngle = shootAngle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 300, 
                                vy: Math.sin(projectileAngle) * 300,
                                size: 5,
                                damage: player.stats.shotgunDamage,
                                color: '#FFA500', 
                                pierce: 0, 
                                hits: 0,
                                lifetime: 0.3, 
                                maxLifetime: 0.3 
                            });
                        }
                        playSound('playerShot'); 
                        player.shotgunTimer = 0;
                    }
                }
            }

            // Dual Uzi logic (for Johnny or Dixie if upgraded/default)
            if (player.stats.dualUziActive) {
                player.dualUziTimer += effectiveDt;
                const uziCooldown = 1 / player.stats.dualUziFireRate;
                if (player.dualUziTimer >= uziCooldown) {
                    if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                        player.currentShootAngle = shootAngle;
                        const armBaseOffset = player.size * 0.2;
                        const armLengthOffset = player.size * 1.5;

                        projectiles.push({
                            x: player.x + Math.cos(shootAngle - Math.PI/2) * armBaseOffset + Math.cos(shootAngle) * armLengthOffset,
                            y: player.y + Math.sin(shootAngle - Math.PI/2) * armBaseOffset + Math.sin(shootAngle) * armLengthOffset,
                            vx: Math.cos(shootAngle) * 600,
                            vy: Math.sin(shootAngle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        projectiles.push({
                            x: player.x + Math.cos(shootAngle + Math.PI/2) * armBaseOffset + Math.cos(shootAngle) * armLengthOffset,
                            y: player.y + Math.sin(shootAngle + Math.PI/2) * armBaseOffset + Math.sin(shootAngle) * armLengthOffset,
                            vx: Math.cos(shootAngle) * 600,
                            vy: Math.sin(shootAngle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        if (survivalTime - lastUziSoundTime >= UZI_SOUND_COOLDOWN) {
                            playSound('playerShot'); 
                            lastUziSoundTime = survivalTime;
                        }
                    }
                    player.dualUziTimer = 0;
                }
            }

            if (player.stats.boomerangCount > 0) {
                player.boomerangTimer += effectiveDt;
                if (player.boomerangTimer >= player.stats.boomerangCooldown) {
                    if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                        player.currentShootAngle = shootAngle;
                    }
                    const numBoomerangs = player.stats.boomerangCount;
                    const angleStep = (Math.PI * 2) / numBoomerangs; 
                    for (let i = 0; i < numBoomerangs; i++) {
                        const initialAngle = Math.random() * Math.PI * 2; 
                        boomerangs.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(initialAngle) * player.stats.boomerangSpeed,
                            vy: Math.sin(initialAngle) * player.stats.boomerangSpeed,
                            size: 15, 
                            damage: player.stats.boomerangDamage,
                            color: '#FFFF00', 
                            distanceTraveled: 0,
                            returning: false,
                            hitEnemies: new Set(), 
                            maxOutwardDistance: player.stats.boomerangRange,
                            speed: player.stats.boomerangSpeed
                        });
                    }
                    player.boomerangTimer = 0;
                }
            }

            // Leash Whip ability for Dixie
            if (currentCharacter === 'dixie' && player.upgrades.leashWhip > 0) {
                player.leashWhipTimer += effectiveDt;
                if (player.leashWhipTimer >= player.leashWhipCooldown) {
                    let targetX = player.x + Math.cos(player.currentShootAngle) * (150 + player.upgrades.leashWhip * 20);
                    let targetY = player.y + Math.sin(player.currentShootAngle) * (150 + player.upgrades.leashWhip * 20);

                    const enemiesInWhipRange = enemies.filter(enemy => 
                        !enemy.controlled && dist(player, enemy) < (player.size / 2 + 100 + (player.upgrades.leashWhip * 10) + enemy.size / 2)
                    );
                    if (enemiesInWhipRange.length > 0) {
                        const closestEnemyInWhip = enemiesInWhipRange.sort((a,b) => dist(player,a) - dist(player,b))[0];
                        player.leashWhipTargetX = closestEnemyInWhip.x;
                        player.leashWhipTargetY = closestEnemyInWhip.y;
                        
                        enemiesInWhipRange.forEach(enemy => {
                            const damageDealt = player.stats.leashWhipDamage;
                            enemy.health -= damageDealt;
                            ultimateCharge += ultimateChargePerHit;
                            showDamageNumber(damageDealt, enemy.x, enemy.y);
                            if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                playSound('enemyHit');
                                lastEnemyHitSoundTime = survivalTime;
                            }
                            spawnParticles(enemy.x, enemy.y, {r: 150, g: 75, b: 0}); 
                        });
                        playSound('playerShot'); 
                    } else {
                        player.leashWhipTargetX = targetX;
                        player.leashWhipTargetY = targetY;
                    }
                    player.leashWhipActive = true;
                    player.leashWhipAnimationTimer = 0.2;
                    player.leashWhipTimer = 0;
                }
            }

            // Knife Throw Logic
            if (player.upgrades.knifeThrow > 0) {
                player.knifeThrowTimer += effectiveDt;
                if (player.knifeThrowTimer >= player.stats.knifeCooldown) {
                    if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                        for (let i = 0; i < player.stats.knifeCount; i++) {
                            const spread = (i - (player.stats.knifeCount - 1) / 2) * 0.1;
                            const projectileAngle = shootAngle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 500,
                                vy: Math.sin(projectileAngle) * 500,
                                size: 8,
                                damage: ultimateActive ? player.stats.knifeDamage * 3 : player.stats.knifeDamage,
                                color: '#A9A9A9',
                                pierce: 0,
                                hits: 0,
                                type: 'knife'
                            });
                        }
                        playSound('playerShot');
                        player.knifeThrowTimer = 0;
                    }
                }
            }

            // Sword Throw Logic (Dixie only)
            if (currentCharacter === 'dixie' && player.upgrades.swordThrow > 0) {
                player.swordThrowTimer += effectiveDt;
                if (player.swordThrowTimer >= player.stats.swordCooldown) {
                    if (closestEnemy || attackInput.x !== 0 || attackInput.y !== 0) {
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(shootAngle) * 600,
                            vy: Math.sin(shootAngle) * 600,
                            size: 12,
                            damage: ultimateActive ? player.stats.swordDamage * 3 : player.stats.swordDamage,
                            color: '#ADD8E6',
                            pierce: ultimateActive ? player.stats.swordPierce + 1 : player.stats.swordPierce,
                            hits: 0,
                            type: 'sword'
                        });
                        playSound('playerShot');
                        player.swordThrowTimer = 0;
                    }
                }
            }

            // Acid Aura Logic
            if (player.upgrades.acidAura > 0) {
                player.acidAuraTimer += effectiveDt;
                player.acidAuraAngle = (player.acidAuraAngle + effectiveDt * 2) % (Math.PI * 2);
                if (player.acidAuraTimer >= player.stats.acidAuraInterval) {
                    enemies.forEach(enemy => {
                        if (!enemy.controlled && dist(player, enemy) < player.stats.acidAuraRadius + enemy.size / 2) {
                            if (!player.acidAuraHitEnemies.has(enemy)) {
                                const damageDealt = player.stats.acidAuraDamage;
                                enemy.health -= damageDealt;
                                ultimateCharge += ultimateChargePerHit;
                                showDamageNumber(damageDealt, enemy.x, enemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                                spawnParticles(enemy.x, enemy.y, {r: 0, g: 255, b: 0});
                                player.acidAuraHitEnemies.add(enemy);
                            }
                        }
                    });
                    player.acidAuraTimer = 0;
                    player.acidAuraHitEnemies.clear();
                }
            }
        }

        function findClosestEnemy() {
            let closest = null;
            let minDistance = Infinity;

            enemies.forEach(enemy => {
                const distance = dist(player, enemy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function activateUltimate() {
            ultimateActive = true;
            ultimateDuration = 1.5; 
            if (currentCharacter === 'johnny') { 
                player.color = '#ff6600'; 
            } else if (currentCharacter === 'dixie') {
                player.color = player.baseColor;
            }
            ultimateCharge = 0;
            playSound('ultimateActivate');

            gameSpeedMultiplier = 0.25; 
            playerSpeedModifier = 3; 
            projectileSpeedModifier = 3;
        }
        
        function updateEnemies(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width + 50); // Use camera.width directly as it's already scaled by zoom
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height + 50); // Use camera.height directly
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes >= 5 && Math.floor(timeInMinutes) % 5 === 0 && Math.random() < 0.1) { 
                    enemyType = 'enforcer';
                } else if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra'; 
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        
            enemies = enemies.filter(enemy => {
                let angle;

                const prevX = enemy.x;
                const prevY = enemy.y;

                if (enemy.controlled) {
                    const closestEnemy = enemies
                        .filter(e => !e.controlled)
                        .sort((a, b) => dist(enemy, a) - dist(enemy, b))[0];
                    if (closestEnemy) {
                        angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - closestEnemy.x);
                    } else {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    }
                } else if (enemy.type === 'cobra') {
                    if (enemy.segmentIndex === 0) { 
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed; 
                    } else { 
                        const prevSegment = enemies.find(e => e.snakeId === enemy.snakeId && e.segmentIndex === enemy.segmentIndex - 1);
                        if (prevSegment) {
                            const dx = prevSegment.x - enemy.x;
                            const dy = prevSegment.y - enemy.y;
                            const segmentDistance = Math.sqrt(dx*dx + dy*dy);
                            const minSegmentDistance = enemy.size * 1.2; 
                            
                            if (segmentDistance > minSegmentDistance) {
                                angle = Math.atan2(dy, dx);
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0;
                                enemy.vy = 0;
                            }
                        } else {
                            enemy.vx = 0;
                            enemy.vy = 0;
                        }
                    }
                } else if (enemy.type === 'robotDrone') {
                    angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2 + 10)) { 
                        explodeRobotDrone(enemy);
                        return false; 
                    }
                } else if (enemy.type === 'enforcer') {
                    const distance = dist(player, enemy);
                    if (distance < enemy.attackRange) {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        enemy.shootTimer += effectiveDt;
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            const attackAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            const numProjectiles = 5; 
                            const coneSpread = Math.PI / 4; 
                            for (let i = 0; i < numProjectiles; i++) {
                                const spread = (i - (numProjectiles - 1) / 2) * (coneSpread / numProjectiles);
                                const projectileAngle = attackAngle + spread;
                                enemyProjectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(projectileAngle) * enemy.projectileSpeed,
                                    vy: Math.sin(projectileAngle) * enemy.projectileSpeed,
                                    size: enemy.projectileSize,
                                    damage: enemy.projectileDamage,
                                    color: enemy.projectileColor,
                                    isAoE: false, 
                                    lifetime: 0.2, 
                                    maxLifetime: 0.2,
                                    sourceEnemy: enemy 
                                });
                            }
                            playSound('playerShot'); 
                            enemy.shootTimer = 0;
                        }
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed;
                    }
                } else { 
                    const distance = dist(player, enemy);
                    if ((enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone' || enemy.type === 'enemyDrone') && distance < enemy.attackRange) {
                        angle = Math.atan2(player.y - enemy.y, player.x - player.x);
                        enemy.shootTimer += effectiveDt; 
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            const isBazooka = survivalTime > 300 || player.level > 5; 
                            
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * enemy.projectileSpeed,
                                vy: Math.sin(angle) * enemy.projectileSpeed,
                                size: isBazooka ? 15 : enemy.projectileSize, 
                                damage: isBazooka ? enemy.projectileDamage * 2 : enemy.projectileDamage, 
                                color: '#FF0000', 
                                hits: 0,
                                isAoE: isBazooka, 
                                aoeRadius: isBazooka ? 70 : 0, 
                                lifetime: isBazooka ? 1 : 0, 
                                maxLifetime: isBazooka ? 1 : 0,
                                sourceEnemy: enemy 
                            });
                            enemy.shootTimer = 0;
                        }
                        enemy.vx = 0; 
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        
                        if (enemy.type !== 'gunner' && Math.random() < 0.01) { 
                            enemy.flankAngle = (Math.random() - 0.5) * Math.PI / 2;
                        }
                        if (enemy.flankAngle !== undefined) {
                            angle += enemy.flankAngle;
                        }
                    }
                }

                if (enemy.type !== 'cobra' || enemy.segmentIndex === 0) { 
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                }
                

                let tempEnemy = {
                    x: enemy.x + enemy.vx * effectiveDt, 
                    y: enemy.y + enemy.vy * effectiveDt, 
                    size: enemy.size,
                    vx: enemy.vx,
                    vy: enemy.vy
                };

                if (!enemy.ghostModeActive) {
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus' || obstacle.type === 'machine' || obstacle.type === 'conveyor_belt' || obstacle.type === 'pipe') {
                            let obstacleCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempEnemy, obstacleCircle);
                        } else {
                            circleRectCollideAndResolve(tempEnemy, obstacle);
                        }
                    });
                }


                enemy.x = tempEnemy.x;
                enemy.y = tempEnemy.y;
                enemy.vx = tempEnemy.vx; 
                enemy.vy = tempEnemy.vy;

                const movedDistance = dist({x: prevX, y: prevY}, {x: enemy.x, y: enemy.y});
                const stuckThreshold = 1; 

                if (movedDistance < stuckThreshold) {
                    enemy.stuckTimer += effectiveDt;
                    if (enemy.stuckTimer >= 2 && !enemy.ghostModeActive) { 
                        enemy.ghostModeActive = true;
                        enemy.ghostModeTimer = 1; 
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} entered ghost mode!`);
                    }
                } else {
                    enemy.stuckTimer = 0; 
                }

                if (enemy.ghostModeActive) {
                    enemy.ghostModeTimer -= effectiveDt;
                    if (enemy.ghostModeTimer <= 0) {
                        enemy.ghostModeActive = false;
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} exited ghost mode.`);
                    }
                }

                if (Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0) {
                    enemy.animationFrame = (enemy.animationFrame + effectiveDt * 10) % 4;
                } else {
                    enemy.animationFrame = 0;
                }

                enemy.x = Math.max(-100, Math.min(gameWorld.width + 100, enemy.x)); 
                enemy.y = Math.max(-100, Math.min(gameWorld.height + 100, enemy.y));
        
                return enemy.x > -150 && enemy.x < gameWorld.width + 150 && 
                       enemy.y > -150 && enemy.y < gameWorld.height + 150;
            });

            const cobraIds = new Set(enemies.filter(e => e.type === 'cobra').map(e => e.snakeId));
            cobraIds.forEach(id => {
                let segments = enemies.filter(e => e.snakeId === id).sort((a, b) => a.segmentIndex - b.segmentIndex);
                segments.forEach((segment, index) => {
                    segment.segmentIndex = index; 
                });
            });
        }
        
        function updateProjectiles(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            projectiles = projectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.lifetime !== undefined) {
                    p.lifetime -= effectiveDt;
                }
                
                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && p.hits <= p.pierce && (p.lifetime === undefined || p.lifetime > 0); 
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.isAoE || p.lifetime !== undefined) { 
                    p.lifetime -= effectiveDt;
                }

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && (!p.isAoE && p.lifetime === undefined || p.lifetime > 0);
            });
        }
        
        function updatePowerups(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            powerups = powerups.filter(p => {
                const distance = dist(player, p);
                if (distance < player.stats.magnet) {
                    const angle = Math.atan2(player.y - p.y, player.x - p.x);
                    p.x += Math.cos(angle) * p.speed * effectiveDt; 
                    p.y += Math.sin(angle) * p.speed * effectiveDt; 
                }
                return true;
            });
        }

        function updateChests(dt) {
            chests = chests.filter(chest => {
                return true;
            });
        }
        
        function updateDamageNumbers(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            damageNumbers = damageNumbers.filter(d => {
                d.y -= 20 * effectiveDt; 
                d.lifetime -= effectiveDt; 
                return d.lifetime > 0;
            });
        }

        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha -= dt * 2; 
                p.size -= dt * 5; 
                return p.alpha > 0 && p.size > 0;
            });
        }

        function updateSpinningKnivesEffect() {
            spinningKnives = [];
            const numKnives = player.stats.spinningKnivesCount;
            const radius = player.size * 2; 
            const knifeSize = 5;
            const knifeDamage = player.stats.spinningKnivesDamage;
            const rotationSpeed = 5; 

            for (let i = 0; i < numKnives; i++) {
                spinningKnives.push({
                    angle: (Math.PI * 2 / numKnives) * i, 
                    radius: radius,
                    size: knifeSize,
                    damage: knifeDamage,
                    rotationSpeed: rotationSpeed,
                    hitEnemies: new Set() 
                });
            }
        }

        function updateAllyDogs(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            const leashRadius = DOG_LEASH_RADIUS; 
            const attackRadius = 400; 

            const targetedEnemies = new Set();
            allyDogs.forEach(dog => {
                if (dog.currentTarget) {
                    targetedEnemies.add(dog.currentTarget);
                }
            });

            allyDogs.forEach(dog => {
                let intendedVx = 0;
                let intendedVy = 0;
                let closestEnemyInAttackRange = null;
                let minDistanceToEnemy = Infinity;

                enemies.forEach(enemy => {
                    if (!enemy.controlled && !targetedEnemies.has(enemy)) {
                        const distToEnemy = dist(dog, enemy);
                        if (distToEnemy < attackRadius && distToEnemy < minDistanceToEnemy) {
                            minDistanceToEnemy = distToEnemy;
                            closestEnemyInAttackRange = enemy;
                        }
                    }
                });

                if (!closestEnemyInAttackRange && enemies.filter(e => !e.controlled).length === 1) {
                    closestEnemyInAttackRange = enemies.find(e => !e.controlled);
                }
                
                dog.currentTarget = closestEnemyInAttackRange;

                if (closestEnemyInAttackRange) {
                    const angleToEnemy = Math.atan2(closestEnemyInAttackRange.y - dog.y, closestEnemyInAttackRange.x - dog.x);
                    intendedVx = Math.cos(angleToEnemy) * dog.speed;
                    intendedVy = Math.sin(angleToEnemy) * dog.speed;
                } else {
                    dog.orbitAngle = (dog.orbitAngle + effectiveDt * 0.8) % (Math.PI * 2); 
                    const targetX = player.x + Math.cos(dog.orbitAngle) * dog.orbitRadius;
                    const targetY = player.y + Math.sin(dog.orbitAngle) * dog.orbitRadius;

                    const dx = targetX - dog.x;
                    const dy = targetY - dog.y;
                    const distToOrbit = Math.sqrt(dx * dx + dy * dy);
                    if (distToOrbit > 5) { 
                        const angleToOrbit = Math.atan2(dy, dx);
                        intendedVx = Math.cos(angleToOrbit) * dog.speed;
                        intendedVy = Math.sin(angleToOrbit) * dog.speed;
                    }
                }

                const prevX = dog.x;
                const prevY = dog.y;

                let tempDog = {
                    x: dog.x + intendedVx * effectiveDt, 
                    y: dog.y + intendedVy * effectiveDt, 
                    size: dog.size,
                    vx: intendedVx, 
                    vy: intendedVy
                };
                
                if (!dog.ghostModeActive) {
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus' || obstacle.type === 'machine' || obstacle.type === 'conveyor_belt' || obstacle.type === 'pipe') {
                            let obstacleCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempDog, obstacleCircle);
                        } else {
                            circleRectCollideAndResolve(tempDog, obstacle);
                        }
                    });
                }

                dog.x = tempDog.x;
                dog.y = tempDog.y;
                dog.vx = tempDog.vx; 
                dog.vy = tempDog.vy;

                const movedDistance = dist({x: prevX, y: prevY}, {x: dog.x, y: dog.y});
                const stuckThreshold = 1; 

                if (movedDistance < stuckThreshold) {
                    dog.stuckTimer += effectiveDt;
                    if (dog.stuckTimer >= 1 && !dog.ghostModeActive) {
                        dog.ghostModeActive = true;
                        dog.ghostModeTimer = 0.5;
                        dog.stuckTimer = 0; 
                        console.log(`Ally dog entered ghost mode!`);
                    }
                } else {
                    dog.stuckTimer = 0; 
                }

                if (dog.ghostModeActive) {
                    dog.ghostModeTimer -= effectiveDt;
                    if (dog.ghostModeTimer <= 0) {
                        dog.ghostModeActive = false;
                        dog.stuckTimer = 0; 
                        console.log(`Ally dog exited ghost mode.`);
                    }
                }

                if (closestEnemyInAttackRange && dist(dog, closestEnemyInAttackRange) < (dog.size / 2 + closestEnemyInAttackRange.size / 2) && (survivalTime - dog.lastAttackTime >= dog.attackCooldown)) {
                    closestEnemyInAttackRange.health -= dog.damage;
                    showDamageNumber(dog.damage, closestEnemyInAttackRange.x, closestEnemyInAttackRange.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                    dog.lastAttackTime = survivalTime; 
                }

                if (currentCharacter === 'dixie' && player.upgrades.dogBones > 0 && closestEnemyInAttackRange) {
                    dog.shootTimer += effectiveDt;
                    if (dog.shootTimer >= 1 / dog.attackSpeed) {
                        const angleToEnemy = Math.atan2(closestEnemyInAttackRange.y - dog.y, closestEnemyInAttackRange.x - dog.x);
                        projectiles.push({
                            x: dog.x,
                            y: dog.y,
                            vx: Math.cos(angleToEnemy) * dogProjectileSpeed,
                            vy: Math.sin(angleToEnemy) * dogProjectileSpeed,
                            size: 8, 
                            damage: dogProjectileDamage,
                            color: '#D2B48C',
                            pierce: 0,
                            hits: 0
                        });
                        playSound('playerShot'); 
                        dog.shootTimer = 0;
                    }
                }
            });
        }

        function addAllyDog() {
            const numDogs = allyDogs.length + 1;
            const baseOrbitRadius = DOG_LEASH_RADIUS;
            const orbitSpread = 20;
            const initialAngleOffset = Math.random() * Math.PI * 2;

            for (let i = 0; i < numDogs; i++) {
                const angle = initialAngleOffset + (Math.PI * 2 / numDogs) * i;
                const radius = baseOrbitRadius + (i % 2) * orbitSpread;
                
                if (i < allyDogs.length) {
                    allyDogs[i].orbitAngle = angle;
                    allyDogs[i].orbitRadius = radius;
                } else {
                    allyDogs.push({
                        x: player.x + Math.cos(angle) * radius, 
                        y: player.y + Math.sin(angle) * radius,
                        size: 20,
                        color: '#8B4513', 
                        speed: 200 + player.upgrades.dogSpeed * 20, 
                        damage: 10 + player.upgrades.dogStrength * 5, 
                        lastAttackTime: 0, 
                        attackCooldown: 0.5,
                        shootTimer: 0, 
                        attackSpeed: 1,
                        orbitAngle: angle,
                        orbitRadius: radius,
                        vx: 0,
                        vy: 0,
                        stuckTimer: 0,
                        ghostModeActive: false,
                        ghostModeTimer: 0,
                        currentTarget: null
                    });
                }
            }
            console.log(`[Dixie] Dog added. Current dog count: ${allyDogs.length}`);
        }

        function updateDrones(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            drones.forEach(drone => {
                const closestEnemy = enemies.find(e => !e.controlled); 
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                    if (dist(drone, player) > 150) { 
                        drone.x += Math.cos(angle) * drone.speed * effectiveDt;
                        drone.y += Math.sin(angle) * drone.speed * effectiveDt;
                    } else {
                        drone.orbitAngle += effectiveDt * 2; 
                        drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                        drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                    }

                    drone.shootTimer += effectiveDt;
                    if (drone.shootTimer >= 1 / drone.attackSpeed) {
                        projectiles.push({
                            x: drone.x,
                            y: drone.y,
                            vx: Math.cos(angle) * 500, 
                            vy: Math.sin(angle) * 500,
                            size: 4,
                            damage: drone.damage,
                            color: '#00FFFF', 
                            pierce: 0,
                            hits: 0
                        });
                        drone.shootTimer = 0;
                    }
                } else {
                    drone.orbitAngle += effectiveDt * 2; 
                    drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                    drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                }
            });
        }

        function updateDronesEffect() {
            while (drones.length < player.stats.droneCount) {
                const newDrone = {
                    x: player.x,
                    y: player.y,
                    size: 10,
                    speed: 200, 
                    damage: player.stats.droneDamage,
                    attackSpeed: player.stats.droneAttackSpeed,
                    shootTimer: 0,
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitRadius: 50 + drones.length * 10 
                };
                drones.push(newDrone);
            }
            drones.forEach(drone => {
                drone.damage = player.stats.droneDamage;
                drone.attackSpeed = player.stats.droneAttackSpeed;
            });
        }

        function updateBoomerangs(dt) {
            boomerangs = boomerangs.filter(b => {
                if (!b.returning) {
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.distanceTraveled += b.speed * dt;

                    if (b.distanceTraveled >= b.maxOutwardDistance) {
                        b.returning = true;
                    }
                } else {
                    const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                    b.vx = Math.cos(angleToPlayer) * b.speed;
                    b.vy = Math.sin(angleToPlayer) * b.speed;
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;

                    if (dist(player, b) < player.size / 2 + b.size / 2) {
                        return false; 
                    }
                }
                return b.x > -100 && b.x < gameWorld.width + 100 && b.y > -100 && b.y < gameWorld.height + 100;
            });
        }
        
        function checkCollisions() {
            enemies.forEach(enemy => {
                if (!enemy.controlled) {
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2) && 
                        (enemy.type === 'basic' || enemy.type === 'tank' || enemy.type === 'car' || enemy.type === 'ninja' || enemy.type === 'enemyDog' || enemy.type === 'cobra' || enemy.type === 'yellowSkull' || enemy.type === 'enforcer')) { 
                        
                        if (!player.invincible) {
                            let damageTaken = enemy.damage;
                            damageTaken = damageTaken * (1 - player.stats.damageReduction);
                            
                            if (ultimateActive) {
                                damageTaken *= 0.5;
                            }
                            damageTaken = Math.max(0, damageTaken); 
                            player.health -= damageTaken;
                            
                            player.invincible = true;
                            player.invincibilityTimer = 0.5;
                            player.flashTimer = 0;
                            player.isFlashing = true;
                            player.color = 'rgba(255,255,255,0.7)';

                            if (player.health <= 0) {
                                gameOver();
                            }
                        }
                    }
                }
            });
        
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    if (!enemy.controlled && dist(p, enemy) < (p.size + enemy.size / 2)) {
                        if (enemy.type === 'robotDrone') {
                            explodeRobotDrone(enemy);
                            enemies.splice(j, 1); 
                            j--; 
                            projectileRemoved = true; 
                            break;
                        }
                        
                        const damageDealt = p.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (p.type === 'knife' || p.type === 'sword') {
                            spawnParticles(enemy.x, enemy.y, {r: 200, g: 200, b: 200}); 
                        } else {
                            spawnParticles(enemy.x, enemy.y, enemy.color);
                        }

                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit'); 
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        p.hits++;
        
                        if (p.hits > p.pierce) {
                            projectiles.splice(i, 1);
                            projectileRemoved = true;
                            break; 
                        }
                    }
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (dist(player, p) < (player.size / 2 + p.size / 2)) { 
                    if (!player.invincible) {
                        let damageTaken = p.damage;
                        damageTaken = damageTaken * (1 - player.stats.damageReduction);

                        if (ultimateActive) {
                            damageTaken *= 0.5;
                        }
                        damageTaken = Math.max(0, damageTaken); 
                        player.health -= damageTaken;

                        player.invincible = true;
                        player.invincibilityTimer = 0.5; 
                        player.flashTimer = 0;
                        player.isFlashing = true;
                        player.color = 'rgba(255,255,255,0.7)';

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }

                    if (p.isAoE) {
                        enemies.forEach(otherEnemy => {
                            if (otherEnemy !== p.sourceEnemy && !otherEnemy.controlled && dist(p, otherEnemy) < p.aoeRadius + otherEnemy.size / 2) {
                                otherEnemy.health -= p.damage * 0.5; 
                                showDamageNumber(p.damage * 0.5, otherEnemy.x, otherEnemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                            }
                        });
                        playSound('explosion'); 
                        spawnParticles(p.x, p.y, {r: 255, g: 100, b: 0}); 
                    }
                    enemyProjectiles.splice(i, 1); 
                    i--; 
                }
            }

            spinningKnives.forEach(knife => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !knife.hitEnemies.has(enemy) && dist(knife, enemy) < (knife.size + enemy.size / 2)) {
                        const damageDealt = knife.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        knife.hitEnemies.add(enemy); 
                    }
                });
                knife.hitEnemies.clear();
            });

            boomerangs.forEach(b => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !b.hitEnemies.has(enemy) && dist(b, enemy) < (b.size + enemy.size / 2)) {
                        const damageDealt = b.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        b.hitEnemies.add(enemy); 
                    }
                });
            });
        
            allyDogs.forEach(dog => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && dist(dog, enemy) < (dog.size / 2 + enemy.size / 2)) {
                        if (survivalTime - dog.lastAttackTime >= dog.attackCooldown) {
                            enemy.health -= dog.damage;
                            showDamageNumber(dog.damage, enemy.x, enemy.y);
                            if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                playSound('enemyHit');
                                lastEnemyHitSoundTime = survivalTime;
                            }
                            dog.lastAttackTime = survivalTime; 
                        }
                    }
                });
            });
        
            powerups.forEach(p => {
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    if (p.type === 'xp') {
                        gainXp(p.xpValue);
                    } else if (p.type === 'heart') {
                        player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.5);
                        console.log("Health restored! Current health:", player.health);
                    }
                    powerups = powerups.filter(item => item !== p);
                }
            });

            for (let i = chests.length - 1; i >= 0; i--) {
                const chest = chests[i];
                if (dist(player, chest) < (player.size / 2 + chest.size / 2)) {
                    activateChestPowerup();
                    chests.splice(i, 1);
                }
            }
        
            enemies = enemies.filter(enemy => {
                if (enemy.health <= 0) {
                    gainXp(enemy.xp);
                    score += 10;
                    spawnParticles(enemy.x, enemy.y, enemy.color);
                    spawnPowerup(enemy.x, enemy.y, 'xp'); 
                    if (enemy.type === 'enforcer') {
                        spawnChestAtLocation(enemy.x, enemy.y);
                    }
                    return false; 
                }
                return true; 
            });
        }
        
        function spawnEnemy() {
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width + 50); // Adjusted to use camera.width directly
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height + 50); // Adjusted to use camera.height directly
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes >= 5 && Math.floor(timeInMinutes) % 5 === 0 && Math.random() < 0.1) { 
                    enemyType = 'enforcer';
                } else if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra'; 
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        }

        function spawnCobra(x, y) {
            const numSegments = 5 + Math.floor(Math.random() * 3); 
            const segmentSize = 25;
            const snakeId = Date.now(); 

            for (let i = 0; i < numSegments; i++) {
                const segmentX = x - i * segmentSize * 1.5; 
                const segmentY = y;
                enemies.push({
                    x: segmentX,
                    y: segmentY,
                    type: 'cobra',
                    controlled: false, 
                    snakeId: snakeId,
                    segmentIndex: i,
                    stuckTimer: 0, 
                    ghostModeActive: false, 
                    ghostModeTimer: 0, 
                    lastX: segmentX, 
                    lastY: segmentY, 
                    ...getEnemyStats('cobra')
                });
            }
        }
        
        function getEnemyStats(type) {
            const base = {
                size: 25, speed: 30, health: 50, damage: 10, xp: 10,
                projectileSize: 8, projectileDamage: 15, projectileSpeed: 100, projectileColor: '#FF0000', attackRange: 250, attackSpeed: 0.8
            };
        
            switch (type) {
                case 'basic':
                    base.color = '#777777';
                    break;
                case 'fast':
                    base.size = 20; base.speed = 50; base.health = 30; base.xp = 15; base.color = '#ff4444';
                    base.attackRange = 200; base.attackSpeed = 2; base.projectileSpeed = 150; 
                    break;
                case 'tank':
                    base.size = 30; 
                    base.speed = 15; base.health = 200; base.xp = 50; base.color = '#9966ff';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'elite':
                    base.size = 30; base.speed = 40; base.health = 500; base.damage = 20; base.xp = 200; base.color = '#ff0000';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'gunner':
                    base.size = 25; base.speed = 20; base.health = 40; base.damage = 0; base.xp = 20; base.color = '#3399ff';
                    base.attackRange = 400; base.attackSpeed = 1; base.projectileSpeed = 100; 
                    break;
                case 'drone':
                    base.size = 15; base.speed = 40; base.health = 20; base.xp = 12; base.color = '#888888';
                    base.attackRange = 150; base.attackSpeed = 2.5; base.projectileSpeed = 125; base.projectileSize = 5; base.projectileColor = '#FF0000'; 
                    break;
                case 'car':
                    base.size = 35; 
                    base.speed = 70; base.health = 300; base.damage = 25 * 0.8; base.xp = 75; base.color = '#663300'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'ninja':
                    base.size = 22; base.speed = 80; base.health = 60; base.damage = 15; base.xp = 30; base.color = '#333333';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'enemyDog':
                    base.size = 20; base.speed = 60; base.health = 35; base.damage = 12; base.xp = 18; base.color = '#A0522D'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'enemyDrone':
                    base.size = 15; base.speed = 45; base.health = 25; base.damage = 0; base.xp = 15; base.color = '#4682B4'; 
                    base.attackRange = 200; base.attackSpeed = 1.5; base.projectileSpeed = 110; base.projectileSize = 6; base.projectileColor = '#FF0000'; 
                    break;
                case 'cobra':
                    base.size = 25; base.speed = 40; base.health = 70; base.damage = 15; base.xp = 25; base.color = '#228B22'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'robotDrone': 
                    base.size = 18; base.speed = 70; base.health = 20; base.damage = 25; base.xp = 15; base.color = '#808080'; 
                    base.explosionRadius = 70; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'yellowSkull': 
                    base.size = 35; 
                    base.speed = 10; 
                    base.health = 400; 
                    base.damage = 15; 
                    base.xp = 100; 
                    base.color = '#FFFF00'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'enforcer': 
                    base.size = 40; 
                    base.speed = 10; 
                    base.health = 1000; 
                    base.damage = 30; 
                    base.xp = 500; 
                    base.color = '#8B0000'; 
                    base.attackRange = 80; 
                    base.attackSpeed = 0.5; 
                    base.projectileSize = 20; 
                    base.projectileDamage = 40; 
                    base.projectileSpeed = 100; 
                    base.projectileColor = '#FF4500'; 
                    break;
                default: 
                    base.color = '#777777';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
            }
            
            const healthScale = 1 + Math.pow(survivalTime / 60, 0.5); 
            const damageScale = 1 + Math.pow(survivalTime / 90, 0.4); 
            let speedScale = 1 + Math.min(survivalTime / 180, 1.5); 

            if (survivalTime >= 120) { 
                speedScale *= 1.15;
            }

            base.health *= healthScale;
            base.damage *= damageScale;
            base.speed *= speedScale;
            base.xp = Math.floor(base.xp * ((healthScale + damageScale) / 2) * 0.5); 

            if (type === 'gunner' || type === 'fast' || type === 'drone' || type === 'enemyDrone' || type === 'enforcer') { 
                base.projectileDamage *= damageScale;
                base.attackSpeed *= (1 + Math.min(survivalTime / 180, 1));
            }

            if (type === 'basic' && survivalTime < 60) {
                base.health *= 0.75; 
            }

            return base;
        }

        function explodeRobotDrone(drone) {
            playSound('explosion');
            spawnParticles(drone.x, drone.y, {r: 255, g: 100, b: 0}); 

            if (dist(player, drone) < (player.size / 2 + drone.explosionRadius)) {
                if (!player.invincible) {
                    let damageTaken = drone.damage;
                    damageTaken = damageTaken * (1 - player.stats.damageReduction);
                    if (ultimateActive) {
                        damageTaken *= 0.5;
                    }
                    damageTaken = Math.max(0, damageTaken); 
                    player.health -= damageTaken;

                    player.invincible = true;
                    player.invincibilityTimer = 0.5; 
                    player.flashTimer = 0;
                    player.isFlashing = true;
                    player.color = 'rgba(255,255,255,0.7)';

                    if (player.health <= 0) {
                        gameOver();
                    }
                    showDamageNumber(damageTaken, player.x, player.y);
                }
            }

            enemies.forEach(otherEnemy => {
                if (otherEnemy !== drone && !otherEnemy.controlled && dist(drone, otherEnemy) < (drone.explosionRadius + otherEnemy.size / 2)) {
                    otherEnemy.health -= drone.damage * 0.5; 
                    showDamageNumber(drone.damage * 0.5, otherEnemy.x, otherEnemy.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                }
            });
        }
        
        function spawnPowerup(x, y, type) {
            if (type === 'xp') {
                powerups.push({
                    x: x, y: y, size: 10, color: '#ffff00', speed: 300, 
                    xpValue: 25, 
                    type: 'xp'
                });
            } else if (type === 'heart') {
                 powerups.push({
                    x: x, y: y, size: 15, color: '#FF0000', speed: 300, 
                    type: 'heart'
                });
            }
        }

        function spawnChestAtLocation(x, y) {
            chests.push({
                x: x, y: y, size: 30, type: 'chest'
            });
        }

        // --- NEW: Chest Powerup Functions ---

        function activateChestPowerup() {
            const powerupChoices = ['nuke', 'xpSuck', 'levelUp'];
            const chosenPowerup = powerupChoices[Math.floor(Math.random() * powerupChoices.length)];
            
            playSound('explosion');

            switch (chosenPowerup) {
                case 'nuke':
                    killAllEnemiesEffect();
                    console.log("Chest Powerup: Nuke!");
                    break;
                case 'xpSuck':
                    applyInstantMagnetEffect();
                    console.log("Chest Powerup: XP Suck!");
                    break;
                case 'levelUp':
                    gainXp(player.nextLevelXp);
                    console.log("Chest Powerup: Instant Level Up!");
                    break;
            }
        }

        function applyInstantMagnetEffect() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                if (p.type === 'xp') {
                    gainXp(p.xpValue);
                    powerups.splice(i, 1);
                }
            }
        }

        function killAllEnemiesEffect() {
            screenFlash.active = true;
            screenFlash.duration = 0.5;
            screenFlash.alpha = 0.7;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                score += 10;
                spawnParticles(enemy.x, enemy.y, enemy.color);
            }
            enemies.length = 0;
        }

        // --- END: Chest Powerup Functions ---
        
        function gainXp(amount) {
            const wasMessageBoxHidden = messageBox.style.display !== 'block'; 
            player.xp += amount;
            console.log(`[XP Gain] XP gained: ${amount}, Current XP: ${player.xp}, Next Level XP: ${player.nextLevelXp}`);
            while (player.xp >= player.nextLevelXp) {
                levelUpQueue.push(true);
                player.xp -= player.nextLevelXp;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5); 
                player.maxHealth += 10;
                player.health = Math.min(player.health + 10, player.maxHealth);
                player.level++;
                playSound('levelUp');
                console.log(`[LEVEL UP] New Level: ${player.level}, XP remaining: ${player.xp}, Next Level XP: ${player.nextLevelXp}. Queue size: ${levelUpQueue.length}`);
            }
            if (levelUpQueue.length > 0 && wasMessageBoxHidden) {
                console.log(`[Show Power] Calling showPowerSelection from gainXp. Queue size: ${levelUpQueue.length}, wasMessageBoxHidden: ${wasMessageBoxHidden}`);
                showPowerSelection();
            }
        }
        
        function showPowerSelection() {
            gameRunning = false;
            isPaused = true; 
            messageBox.style.display = 'block';
            powerSelectionDiv.innerHTML = '';
            console.log("[Show Power] showPowerSelection called.");
        
            const numOptions = 4; 
            const availablePowers = POWER_OPTIONS.filter(p => 
                p.level() < MAX_UPGRADE_LEVEL && p.characters.includes(currentCharacter)
            ); 
            
            if (autoPlayActive) {
                let bestPower = null;
                if (player.health < player.maxHealth * 0.5) {
                    bestPower = availablePowers.find(p => p.id === 'health');
                }
                if (!bestPower) {
                    bestPower = availablePowers.find(p => p.id === 'damage' || p.id === 'shotgun' || p.id === 'acidAura' || p.id === 'leashWhip');
                }
                if (!bestPower && availablePowers.length > 0) {
                    bestPower = availablePowers[0];
                }

                if (bestPower) {
                    selectPower(bestPower);
                    return;
                }
            }


            const selectedPowers = [];
            let tempAvailablePowers = [...availablePowers];

            while (selectedPowers.length < numOptions && tempAvailablePowers.length > 0) {
                const randomIndex = Math.floor(Math.random() * tempAvailablePowers.length);
                selectedPowers.push(tempAvailablePowers[randomIndex]);
                tempAvailablePowers.splice(randomIndex, 1); 
            }
        
            selectedPowers.forEach(power => {
                const card = document.createElement('div');
                card.className = 'power-card';
                card.innerHTML = `
                    <h3>${power.name} <span>Lvl ${power.level() + 1}</span></h3>
                    <p>${power.next()}</p>
                `;
                card.addEventListener('click', () => selectPower(power));
                powerSelectionDiv.appendChild(card);
            });
        }
        
        function selectPower(power) {
            power.effect();
            console.log(`[Power Select] Power selected: ${power.name}. Before shift, queue size: ${levelUpQueue.length}`);
            
            messageBox.style.display = 'none'; 
            
            if (levelUpQueue.length > 0) {
                levelUpQueue.shift(); 
                console.log(`[Power Select] After shift, queue size: ${levelUpQueue.length}. Calling showPowerSelection again.`);
                showPowerSelection(); 
            } else {
                console.log(`[Power Select] No more level ups pending. Resuming game.`);
                gameRunning = true;
                isPaused = false; 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function resetGame() {
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            powerups.length = 0;
            damageNumbers.length = 0;
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            allyDogs = [];
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            
            survivalTime = 0;
            shootTimer = 0;
            spawnTimer = 0;
            randomChestSpawnTimer = 0; 
            randomHeartSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            lastUziSoundTime = 0;

            player.stats.forcefieldActive = false;
            player.stats.forcefieldDamage = 0;
            player.stats.forcefieldRadius = 0;
            player.forcefieldTimer = 0;
            player.forcefieldHitEnemies.clear();
            player.stats.leashWhipDamage = 0; 
            player.leashWhipCooldown = 0;    
            player.leashWhipTimer = 0;       
            player.leashWhipActive = false;
            player.leashWhipAnimationTimer = 0;
            player.leashWhipTargetX = 0;
            player.leashWhipTargetY = 0;

            dogProjectileDamage = 0; 
            dogProjectileSpeed = 0;  

            player.stats.knifeDamage = 0;
            player.stats.knifeCount = 0;
            player.stats.knifeCooldown = 1.5;
            player.stats.swordDamage = 0;
            player.stats.swordPierce = 0;
            player.stats.swordCooldown = 3;
            player.stats.acidAuraDamage = 0;
            player.stats.acidAuraInterval = 0;
            player.stats.acidAuraRadius = 0;


            player.upgrades.knifeThrow = 0;
            player.upgrades.swordThrow = 0;
            player.upgrades.acidAura = 0;


            player.knifeThrowTimer = 0;
            player.swordThrowTimer = 0;
            player.acidAuraTimer = 0;
            player.acidAuraAngle = 0;
            player.acidAuraHitEnemies.clear();

            player.invincible = false;
            player.invincibilityTimer = 0;
            player.flashTimer = 0;
            player.isFlashing = false;
        }

        function handleRetry() {
            startGame();
        }

        function backToMainMenu() {
            resetGame();
            gameRunning = false;
            isPaused = false;
            isMenuOpen = false;
            showStartMenu();
        }

        function updateCamera() {
            camera.x = player.x - (camera.width / 2); // Center camera on player
            camera.y = player.y - (camera.height / 2);

            // Clamp camera to game world boundaries
            camera.x = Math.max(0, Math.min(camera.x, gameWorld.width - camera.width));
            camera.y = Math.max(0, Math.min(camera.y, gameWorld.height - camera.height));
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused || isMenuOpen) return; 
        
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            survivalTime += deltaTime;
        
            update(deltaTime);
            draw();
        
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            shootTimer += effectiveDt;
            spawnTimer += effectiveDt;
            randomChestSpawnTimer += effectiveDt; 
            randomHeartSpawnTimer += effectiveDt;

            if (screenFlash.active) {
                screenFlash.duration -= dt;
                screenFlash.alpha = (screenFlash.duration / 0.5) * 0.7;
                if (screenFlash.duration <= 0) {
                    screenFlash.active = false;
                }
            }

            if (randomChestSpawnTimer >= RANDOM_CHEST_SPAWN_INTERVAL) {
                if (Math.random() < RANDOM_CHEST_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnChestAtLocation(x, y);
                }
                randomChestSpawnTimer = 0;
            }

            if (survivalTime >= HEART_SPAWN_START_TIME && randomHeartSpawnTimer >= HEART_SPAWN_INTERVAL) {
                if (Math.random() < HEART_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnPowerup(x, y, 'heart');
                }
                randomHeartSpawnTimer = 0;
            }

            if (player.upgrades.burstCharge > 0) {
                player.burstChargeTimer -= effectiveDt;
            }

            if (player.stats.burstDamage > 0) {
                player.burstTimer += effectiveDt;
            }
            if (player.upgrades.shotgun > 0) { 
                player.shotgunTimer += effectiveDt;
            }
            if (player.stats.dualUziActive) { 
                player.dualUziTimer += effectiveDt;
            }
            if (player.stats.boomerangCount > 0) { 
                player.boomerangTimer += effectiveDt;
            }
            if (currentCharacter === 'dixie' && player.upgrades.leashWhip > 0) { 
                player.leashWhipTimer += effectiveDt;
            }
            if (player.leashWhipActive) {
                player.leashWhipAnimationTimer -= effectiveDt;
                if (player.leashWhipAnimationTimer <= 0) {
                    player.leashWhipActive = false;
                }
            }
            if (player.upgrades.knifeThrow > 0) {
                player.knifeThrowTimer += effectiveDt;
            }
            if (player.upgrades.swordThrow > 0) {
                player.swordThrowTimer += effectiveDt;
            }
            if (player.upgrades.acidAura > 0) {
                player.acidAuraTimer += effectiveDt;
                player.acidAuraAngle = (player.acidAuraAngle + effectiveDt * 2) % (Math.PI * 2);
            }


            spinningKnives.forEach(knife => {
                knife.angle += knife.rotationSpeed * effectiveDt;
                knife.x = player.x + Math.cos(knife.angle) * knife.radius;
                knife.y = player.y + Math.sin(knife.angle) * knife.radius;
            });

            if (player.stats.forcefieldActive) {
                player.forcefieldTimer += effectiveDt;
                const forcefieldTickInterval = 0.5; 
                if (player.forcefieldTimer >= forcefieldTickInterval) {
                    enemies.forEach(enemy => {
                        if (!enemy.controlled && dist(player, enemy) < player.stats.forcefieldRadius + enemy.size / 2) {
                            if (!player.forcefieldHitEnemies.has(enemy)) {
                                const damageDealt = player.stats.forcefieldDamage;
                                enemy.health -= damageDealt;
                                ultimateCharge += ultimateChargePerHit;
                                showDamageNumber(damageDealt, enemy.x, enemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                                player.forcefieldHitEnemies.add(enemy);
                            }
                        }
                    });
                    player.forcefieldTimer = 0;
                    player.forcefieldHitEnemies.clear(); 
                }
            }

            if (ultimateActive) {
                ultimateDuration -= effectiveDt;
                if (ultimateDuration <= 0) {
                    ultimateActive = false;
                    player.color = player.baseColor; 
                    ultimateCharge = 0;
                    gameSpeedMultiplier = 1; 
                    playerSpeedModifier = 1; 
                    projectileSpeedModifier = 1; 
                }
            } else if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += effectiveDt * 5 * (1 + player.upgrades.ultimateRecharge * 0.2); 
                ultimateCharge = Math.min(ultimateCharge, ultimateMaxCharge);
            }

            updatePlayer(effectiveDt);
            updateCamera();
            updateEnemies(effectiveDt);
            updateProjectiles(effectiveDt);
            updatePowerups(effectiveDt);
            updateChests(effectiveDt); 
            updateAllyDogs(effectiveDt); 
            updateDrones(effectiveDt); 
            updateBoomerangs(effectiveDt); 
            checkCollisions();
            updateDamageNumbers(effectiveDt);
            updateParticles(effectiveDt); 
        }
        
        function gameOver() {
            gameRunning = false;
            isPaused = true; 
            playSound('gameOver');
            
            player.color = player.baseColor;

            if (window.saveUserLevelScoreLocally) {
                window.saveUserLevelScoreLocally(currentLevelId, score);
            }

            showGameOverMenu();
            document.getElementById('final-score').textContent = `Score: ${score}`;
            document.getElementById('final-time').textContent = `Time Survived: ${survivalTime.toFixed(1)}s`;
            document.getElementById('final-level').textContent = `Level Reached: ${player.level}`;

            const currentHighScores = window.getHighScoresLocally();
            const isHighScore = currentHighScores.length < 10 || score > Math.min(...currentHighScores.map(s => s.score));

            if (isHighScore) {
                highScoreModal.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                displayHighScores('high-scores-list');
            }
        }

        function saveAndDisplayHighScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                console.log(`[High Score Modal] Player name entered: "${playerName}"`);
                if (window.saveHighScoreLocally) {
                    window.saveHighScoreLocally(playerName, score, survivalTime.toFixed(1), player.level, currentLevelId);
                }
                highScoreModal.style.display = 'none';
                displayHighScores('high-scores-list');
            } else {
                console.warn("Please enter a name to save your high score.");
            }
        }

    // Displays the high scores on the main menu and game over screen.
    function displayHighScores(listId) {
        const highScores = getHighScoresLocally();
        const listElement = document.getElementById(listId);
        listElement.innerHTML = '';
        if (highScores.length === 0) {
            listElement.innerHTML = '<li>No scores yet. Be the first to survive!</li>';
            return;
        }
        highScores.forEach(score => {
            const minutes = Math.floor(score.survivalTime / 60);
            const seconds = Math.floor(score.survivalTime % 60).toString().padStart(2, '0');
            const formattedTime = `${minutes}:${seconds}`;

            const li = document.createElement('li');
            li.innerHTML = `<span>${score.name}</span> Score: ${score.score} | Time: ${formattedTime} | Level: ${score.level}`;
            listElement.appendChild(li);
        });
    }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = 'Resume';
            } else {
                pauseButton.textContent = 'Pause';
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            if (isMenuOpen) {
                gameMenu.style.display = 'block';
            } else {
                gameMenu.style.display = 'none';
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function spawnParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }
        
        // Function to set the game resolution (aspect ratio and base dimensions)
        function setResolution(resolutionKey) {
            currentResolution = RESOLUTIONS[resolutionKey];
            console.log(`Setting resolution to: ${currentResolution.name}`);
            // Update gameContainer's internal resolution (its width/height)
            // The actual on-screen size will be determined by resizeGame to fit the viewport.
            // These values define the *game world units* visible at 1:1 zoom.
            camera.width = currentResolution.defaultWidth / camera.zoom;
            camera.height = currentResolution.defaultHeight / camera.zoom;
            
            // Re-calculate and apply scaling to fit the new resolution within the viewport
            resizeGame(); 
            // Return to main menu after selecting resolution for a clean start
            showStartMenu(); 
        }

        function resizeGame() {
            const targetAspectRatio = currentResolution.aspectRatio;
            let newWidth, newHeight;

            const viewportRatio = window.innerWidth / window.innerHeight;
            const viewportMargin = 0.95; // Use 95% of viewport for scaling

            if (viewportRatio > targetAspectRatio) {
                // Viewport is wider than target aspect ratio, fit by height
                newHeight = window.innerHeight * viewportMargin;
                newWidth = newHeight * targetAspectRatio;
            } else {
                // Viewport is taller or same aspect ratio, fit by width
                newWidth = window.innerWidth * viewportMargin;
                newHeight = newWidth / targetAspectRatio;
            }

            // Set minimum size for usability on very small screens, adjust as needed
            const minWidth = 300;
            const minHeight = minWidth / targetAspectRatio;

            newWidth = Math.max(newWidth, minWidth);
            newHeight = Math.max(newHeight, minHeight);


            gameContainer.style.width = `${newWidth}px`;
            gameContainer.style.height = `${newHeight}px`;

            // Scale the canvas to match the container
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Camera dimensions are already set by setResolution based on `defaultWidth/Height`
            // and `camera.zoom`. We just need to ensure the camera object reflects these.
            // camera.width and camera.height here represent the *visible game world area* in pixels.
            // They are not directly set by canvas.width/height *unless* zoom is 1.
            // We set camera.width/height when selecting resolution for internal game logic.
            // The canvas width/height is the actual pixel resolution of the drawing surface.
            
            miniMapCanvas.width = miniMapContainer.clientWidth;
            miniMapCanvas.height = miniMapContainer.clientHeight;
            miniMapScale = miniMapCanvas.width / gameWorld.width;

            // Show/hide mobile controls based on screen width
            if (window.innerWidth < 768) { // Example breakpoint for mobile
                mobileControls.style.display = 'none';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        function init() {
            Tone.start().then(() => {
                setupAudio(); 
            }).catch(e => console.error("Error starting Tone.js audio context:", e));

            // Set initial default resolution before initial resize
            setResolution('mobile'); // Default to 9:21 for mobile
            resizeGame(); // Initial resize on load (uses the default resolution)

            window.addEventListener('resize', resizeGame);
        
            document.getElementById('startButton').addEventListener('click', () => {
                autoPlayActive = false;
                showCharacterSelectMenu(); 
            });
            document.getElementById('restartButton').addEventListener('click', handleRetry);
            saveScoreButton.addEventListener('click', saveAndDisplayHighScore);
            backToMainMenuButtonGameOver.addEventListener('click', backToMainMenu); 

            pauseButton.addEventListener('click', togglePause);
            menuButton.addEventListener('click', toggleMenu);
            resumeFromMenuButton.addEventListener('click', toggleMenu); 

            levelSelectButton.addEventListener('click', showLevelSelectMenu);
            backToMainMenuButton.addEventListener('click', showStartMenu);
            backToMainMenuButtonFromGame.addEventListener('click', backToMainMenu); 

            document.querySelectorAll('.character-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    currentCharacter = e.currentTarget.dataset.character;
                    startGame(); 
                });
            });
            backToStartMenuFromCharSelect.addEventListener('click', showStartMenu);

            // Event listeners for new Resolution and Accessibility buttons
            resolutionButton.addEventListener('click', showResolutionSelectMenu);
            backToMainMenuFromResolution.addEventListener('click', showStartMenu);
            
            accessibilityButton.addEventListener('click', showAccessibilityMenu);
            backToMainMenuFromAccessibility.addEventListener('click', showStartMenu);

            // autoPlayButton is now directly in pause menu
autoPlayButton.addEventListener('click', () => {
    autoPlayActive = true;
    gameMenu.style.display = 'none';
    isPaused = false;
    isMenuOpen = false;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
});


            // Re-adding passive: false for touch events to prevent scrolling
            canvas.addEventListener('mousedown', handlePointerEvent);
            canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
            
            function handlePointerEvent(e) {
                if (autoPlayActive || movementJoystickActive || attackJoystickActive) return;

                e.preventDefault();
                if (!gameRunning || isPaused || isMenuOpen) return; 

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Adjust input coordinates based on current camera zoom and position
                const inputX = (clientX - rect.left) / camera.zoom;
                const inputY = (clientY - rect.top) / camera.zoom;
                
                player.targetX = camera.x + inputX;
                player.targetY = camera.y + inputY;
            }

            // Joystick event listeners
            movementJoystickHandle.addEventListener('touchstart', (e) => {
                movementJoystickActive = true;
                e.preventDefault(); // Prevent scrolling
            }, { passive: false });
            movementJoystickHandle.addEventListener('touchmove', (e) => {
                if (!movementJoystickActive) return;
                e.preventDefault(); // Prevent scrolling

                const touch = e.touches[0];
                const rect = movementJoystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_MAX_DIST) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * JOYSTICK_MAX_DIST;
                    deltaY = Math.sin(angle) * JOYSTICK_MAX_DIST;
                }

                movementJoystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                movementInput.x = deltaX;
                movementInput.y = deltaY;
            }, { passive: false });
            movementJoystickHandle.addEventListener('touchend', () => {
                movementJoystickActive = false;
                movementJoystickHandle.style.transform = 'translate(0, 0)';
                movementInput.x = 0;
                movementInput.y = 0;
            });

            attackJoystickHandle.addEventListener('touchstart', (e) => {
                attackJoystickActive = true;
                e.preventDefault(); // Prevent scrolling
            }, { passive: false });
            attackJoystickHandle.addEventListener('touchmove', (e) => {
                if (!attackJoystickActive) return;
                e.preventDefault(); // Prevent scrolling

                const touch = e.touches[0];
                const rect = attackJoystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_MAX_DIST) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * JOYSTICK_MAX_DIST;
                    deltaY = Math.sin(angle) * JOYSTICK_MAX_DIST;
                }

                attackJoystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                attackInput.x = deltaX;
                attackInput.y = deltaY;
            }, { passive: false });
            attackJoystickHandle.addEventListener('touchend', () => {
                attackJoystickActive = false;
                attackJoystickHandle.style.transform = 'translate(0, 0)';
                attackInput.x = 0;
                attackInput.y = 0;
            });


            ultimateButton.addEventListener('click', () => {
                if (ultimateCharge >= ultimateMaxCharge && !ultimateActive) {
                    activateUltimate();
                }
            });
        
            generateObstacles();
        
            displayHighScores('start-menu-high-scores-list');

            showStartMenu();
        }

        let enemies = []; 
        let projectiles = []; 
        let enemyProjectiles = []; 
        let powerups = []; 
        let obstacles = []; 

        function generateObstacles() {
            obstacles = []; 

            if (currentLevelId === 'hotel_lobby') {
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 50, height: 50, color: '#3c3c3c', type: 'pillar'
                    });
                }

                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 200, height: 50, color: '#4d4d4d', type: 'desk'
                    });
                }

                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 30, height: 30, color: '#2d2d2d', type: 'chair'
                    });
                }
            } else if (currentLevelId === 'the_park') {
                for (let i = 0; i < 25; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 70, height: 70, color: '#006400', type: 'tree' 
                    });
                }
                for (let i = 0; i < 35; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 40, height: 40, color: '#008000', type: 'bush' 
                    });
                }
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 100, height: 30, color: '#8B4513', type: 'bench' 
                    });
                }
            } else if (currentLevelId === 'desert_oasis') { 
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 60, height: 60, color: '#32CD32', type: 'cactus' 
                    });
                }
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 150, height: 60, color: '#696969', type: 'old_car' 
                    });
                }
            } else if (currentLevelId === 'factory_realm') {
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    const width = 80 + Math.random() * 70;
                    const height = 60 + Math.random() * 50;
                    obstacles.push({
                        x: x, y: y, width: width, height: height, color: '#5D6D7E', type: 'machine' 
                    });
                }
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                    const width = orientation === 'horizontal' ? 300 : 30;
                    const height = orientation === 'horizontal' ? 30 : 300;
                    obstacles.push({
                        x: x, y: y, width: width, height: height, color: '#424949', type: 'conveyor_belt' 
                    });
                }
                for (let i = 0; i < 25; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                    const width = orientation === 'horizontal' ? 100 : 20;
                    const height = orientation === 'horizontal' ? 20 : 100;
                    obstacles.push({
                        x: x, y: y, width: width, height: height, color: '#AAB7B8', type: 'pipe' 
                    });
                }
            }
        }
        
        function startGame() {
            gameRunning = true;
            isPaused = false;
            isMenuOpen = false;
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            player.xp = 0;
            player.level = 1;
            player.nextLevelXp = 100;
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.targetX = player.x;
            player.targetY = player.y;
            player.vx = 0; 
            player.vy = 0; 

            player.stats = {
                damage: 20, attackSpeed: 10, projectileSpeed: 400, pierce: 0, multiShot: 1, 
                healthRegen: 0.1, magnet: 160, damageReduction: 0, 
                spinningKnivesDamage: 0, spinningKnivesCount: 0, 
                burstDamage: 0, burstProjectileCount: 0,
                droneCount: 0, droneDamage: 0, droneAttackSpeed: 0,
                shotgunPellets: 0, shotgunDamage: 0, shotgunSpread: 0,
                dualUziActive: false, dualUziFireRate: 0, dualUziDamage: 0,
                boomerangDamage: 0, boomerangCount: 0, boomerangCooldown: 4, boomerangRange: 150, boomerangSpeed: 400,
                burstChargeDamage: 0, burstChargeProjectileCount: 0,
                forcefieldActive: false, 
                forcefieldDamage: 0,
                forcefieldRadius: 0,
                leashWhipDamage: 0, 
                knifeDamage: 0,
                knifeCount: 0,
                knifeCooldown: 1.5,
                swordDamage: 0,
                swordPierce: 0,
                swordCooldown: 3,
                acidAuraDamage: 0,
                acidAuraInterval: 0,
                acidAuraRadius: 0,
            };
            player.upgrades = {
                damage: 0, attackSpeed: 0, health: 0, speed: 0, pierce: 0, multiShot: 0, 
                healthRegen: 0, magnet: 0, bulletproofSuit: 0, 
                ultimateRecharge: 0, burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, shotgun: 0, dualUzi: 0,
                boomerang: 0, burstCharge: 0,
                forcefield: 0,
                dogPack: 0,       
                dogBones: 0,      
                leashWhip: 0,     
                dogStrength: 0,   
                dogSpeed: 0,      
                knifeThrow: 0,
                swordThrow: 0,
                acidAura: 0,
            };
            player.burstChargeCooldown = 5; 
            player.burstChargeTimer = 0; 
            player.burstCooldown = 1;
            player.burstTimer = 0;
            player.shotgunTimer = 0; 
            player.dualUziTimer = 0; 
            player.boomerangTimer = 0; 
            player.currentShootAngle = 0; 
            ultimateChargePerHit = 0.5; 
            lastShotSoundTime = 0;
            lastEnemyHitSoundTime = 0;
            lastUziSoundTime = 0; 
            player.forcefieldTimer = 0; 
            player.forcefieldHitEnemies.clear(); 
            player.leashWhipTimer = 0; 
            player.leashWhipActive = false;
            player.leashWhipAnimationTimer = 0;
            player.leashWhipTargetX = 0;
            player.leashWhipTargetY = 0;
            player.knifeThrowTimer = 0;
            player.swordThrowTimer = 0;
            player.acidAuraTimer = 0;
            player.acidAuraAngle = 0;
            player.acidAuraHitEnemies.clear();


            dogProjectileDamage = 0; 
            dogProjectileSpeed = 0;  

            player.character = currentCharacter;
            if (currentCharacter === 'johnny') {
                player.health = 100;
                player.maxHealth = 100;
                player.color = '#6A808C'; 
                player.baseColor = '#6A808C';
                allyDogs = [];
            } else if (currentCharacter === 'dixie') {
                player.health = 120;
                player.maxHealth = 120;
                player.color = '#FF69B4'; 
                player.baseColor = '#FF69B4'; 
                allyDogs = []; // Dixie no longer starts with an ally dog
                // No addAllyDog() call here, as she no longer starts with a dog.
                player.stats.dualUziActive = true; // Renamed to represent Twin Pistols
                player.stats.dualUziFireRate = 8; // Adjust fire rate for Twin Pistols
                player.stats.dualUziDamage = 8; // Adjust damage for Twin Pistols
            }

            randomChestSpawnTimer = 0; 
            randomHeartSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            
            player.invincible = false;
            player.invincibilityTimer = 0;
            player.flashTimer = 0;
            player.isFlashing = false;


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            
            hideAllMenus(); // Use the consolidated hide function

            generateObstacles();
            
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    
</script>
</body>
</html>
