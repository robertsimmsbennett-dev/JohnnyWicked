<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Johnny Wicked Survivors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            user-select: none; /* Prevent text selection on touch */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Remove tap highlight on iOS */
            flex-direction: column; /* For better mobile layout */
        }
        
        #gameContainer {
            position: relative;
            width: 900px; /* Base width */
            height: 700px; /* Base height */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;

            /* Responsive adjustments for gameContainer */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 95vh; /* Max height relative to viewport */
            aspect-ratio: 9 / 7; /* Maintain aspect ratio */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Make canvas fill its container */
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
        }
        
        /* New styles for top-left and top-right control groups */
        #top-left-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: all; /* Allow interaction */
        }

        #top-right-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex; /* Use flexbox for vertical alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: flex-end; /* Align items to the right */
            gap: 5px; /* Space between items */
            pointer-events: all; /* Allow interaction */
        }

        #score-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between score and pause button */
        }
        
        /* Time display now part of top-right-controls */
        #time-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between time and menu button */
            display: block; /* Ensure it's visible */
        }
        
        #level-display {
            bottom: 10px;
            left: 10px;
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box, #game-menu { /* Apply menu styles to message-box and game-menu */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
        }
        
        #power-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .power-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 200px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
        }
        
        .power-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
        .power-card p {
            font-size: 0.9em;
            margin-bottom: 0;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0000;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 11; /* Added z-index to ensure menu is on top */
        }
        
        .menu h1 {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            font-size: 2.5em;
        }
        
        .menu h2 {
            color: #ff0000;
        }
        
        .menu button, .control-button { /* Combined button styles */
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }
        
        .menu button:hover, .control-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        /* Specific styles for the new control buttons */
        #pauseButton, #menuButton, #muteMusicButton, #resumeFromMenuButton { /* Added resumeFromMenuButton */
            padding: 8px 15px; /* Smaller padding for control buttons */
            font-size: 1em; /* Smaller font size */
            margin-top: 0; /* Remove top margin */
            background: linear-gradient(45deg, #007bff, #0056b3); /* Blue gradient */
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #pauseButton:hover, #menuButton:hover, #muteMusicButton:hover, #resumeFromMenuButton:hover {
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Particle effect styles */
        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8); /* White with some transparency */
            border-radius: 50%; /* Make them circular */
            pointer-events: none; /* Do not block mouse events */
            animation: fadeOutAndShrink 0.8s forwards; /* Animation for fading and shrinking */
        }

        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            width: 80%;
            max-width: 250px;
            font-family: 'Chakra Petch', monospace;
            font-size: 1em;
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        #high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #high-scores-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #high-scores-list li:last-child {
            border-bottom: none;
        }
        #high-scores-list li span {
            color: #00ffff;
            font-weight: bold;
        }

        /* Mini-map styles */
        #miniMapContainer {
            position: absolute;
            top: 10px; /* Adjust as needed */
            right: 10px; /* Adjust as needed */
            width: 150px; /* Fixed width */
            height: 150px; /* Fixed height */
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            border-radius: 5px;
            overflow: hidden; /* Ensure content stays within bounds */
            pointer-events: none; /* Do not block clicks on game elements */
            z-index: 10; /* Above game canvas, below menus */
        }

        #miniMapCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <!-- Top Left Controls: Score and Pause Button -->
            <div id="top-left-controls">
                <div id="score-display" class="hud-item">Score: 0</div>
                <button id="pauseButton" class="control-button">Pause</button>
            </div>

            <!-- Top Right Controls: Time and Menu Button -->
            <div id="top-right-controls">
                <div id="time-display" class="hud-item">Time: 0s</div>
                <button id="menuButton" class="control-button">Menu</button>
            </div>

            <!-- Mini-map container -->
            <div id="miniMapContainer">
                <canvas id="miniMapCanvas"></canvas>
            </div>

            <div id="level-display" class="hud-item">Level: 1</div>
            <div id="xp-bar-container"><div id="xp-bar"></div></div>
            <div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
            <button id="ultimate-button">Wicked Mode</button>
        </div>
        
        <div id="start-menu" class="menu">
            <h1>JOHNNY WICKED SURVIVORS</h1>
            <p>Click or tap anywhere to move. Your character will fire automatically.</p>
            <p>New: Enemies can now shoot back! Be careful of the gunmen.</p>
            <button id="startButton">Start Game</button>
        </div>

        <div id="game-over-menu" class="menu" style="display: none;">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Score: 0</h2>
            <h2 id="final-time">Time Survived: 0s</h2>
            <h2 id="final-level">Level Reached: 1</h2>
            <h3>High Scores</h3>
            <ul id="high-scores-list">
                <!-- High scores will be loaded here -->
            </ul>
            <button id="restartButton">Restart Game</button>
        </div>

        <div id="message-box" class="menu" style="display: none;">
            <h3 id="message-title">Level Up!</h3>
            <p id="message-text">Choose your power-up:</p>
            <div id="power-selection"></div>
        </div>

        <!-- New Game Menu -->
        <div id="game-menu" class="menu" style="display: none;">
            <h1>Game Menu</h1>
            <button id="muteMusicButton" class="control-button">Mute Music</button>
            <button id="resumeFromMenuButton" class="control-button">Resume Game</button>
        </div>

        <div id="high-score-modal" style="display: none;">
            <h3>New High Score!</h3>
            <p>Enter your name:</p>
            <input type="text" id="playerNameInput" maxlength="15" placeholder="Your Name">
            <button id="saveScoreButton">Save Score</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in init function)
        window.fb = {};

        window.initFirebase = async function() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing. High score system will not function.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            window.fb.db = getFirestore(app);
            window.fb.auth = getAuth(app);

            // Sign in anonymously if no custom token is provided
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(window.fb.auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await signInAnonymously(window.fb.auth);
                    console.log("Signed in anonymously instead.");
                }
            } else {
                await signInAnonymously(window.fb.auth);
                console.log("Signed in anonymously.");
            }

            // Listen for auth state changes to ensure user is ready
            onAuthStateChanged(window.fb.auth, (user) => {
                if (user) {
                    window.fb.userId = user.uid;
                    console.log("Firebase user ready:", window.fb.userId);
                } else {
                    console.log("Firebase user not signed in.");
                }
            });
        };

        window.saveHighScoreFirebase = async function(name, score, time, level) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated.");
                return;
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.__app_id}/public/data/highScores`);
            try {
                await addDoc(highScoresCollection, {
                    name: name,
                    score: score,
                    survivalTime: time,
                    level: level,
                    timestamp: Date.now(), // Use server timestamp for consistency
                    userId: window.fb.userId // Store user ID for potential future features
                });
                console.log("High score saved successfully!");
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        };

        window.getHighScoresFirebase = async function() {
            if (!window.fb.db) {
                console.error("Firestore not initialized.");
                return [];
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.__app_id}/public/data/highScores`);
            const q = query(highScoresCollection, orderBy("score", "desc"), limit(10));
            
            try {
                const querySnapshot = await getDocs(q);
                const highScores = [];
                querySnapshot.forEach((doc) => {
                    highScores.push(doc.data());
                });
                return highScores;
            } catch (e) {
                console.error("Error getting documents: ", e);
                return [];
            }
        };
    </script>

    <script>
        // Get canvas and UI elements from the DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const messageBox = document.getElementById('message-box');
        const powerSelectionDiv = document.getElementById('power-selection');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoreModal = document.getElementById('high-score-modal');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const highScoresList = document.getElementById('high-scores-list');
        const pauseButton = document.getElementById('pauseButton'); // New
        const menuButton = document.getElementById('menuButton');     // New
        const gameMenu = document.getElementById('game-menu');       // New
        const muteMusicButton = document.getElementById('muteMusicButton'); // New
        const resumeFromMenuButton = document.getElementById('resumeFromMenuButton'); // New
        
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');

        // Mini-map elements
        const miniMapCanvas = document.getElementById('miniMapCanvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        let miniMapScale = 1; // Will be calculated in init

        // Game state variables
        let gameRunning = false;
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let particles = []; // New array for particles
        let gameWorld = {
            width: 3000, // Increased game world width
            height: 3000 // Increased game world height
        };
        let gameSpeedMultiplier = 1; // Global speed multiplier for Bullet Time
        let playerSpeedModifier = 1; // Multiplier for player speed during bullet time
        let projectileSpeedModifier = 1; // Multiplier for player projectiles during bullet time
        let bulletTimeActive = false;
        let bulletTimeDuration = 0;
        let spinningKnives = []; // Array for spinning knives
        let friendlyDog = null; // Friendly dog companion
        let temporaryPowerupActive = false; // Flag for temporary power-ups
        let temporaryPowerupDuration = 0; // Duration for temporary power-ups
        let temporaryPowerupType = ''; // Type of active temporary power-up (e.g., 'spreadGun', 'friendlyDog')
        
        // Removed chestSpawnTimer and CHEST_SPAWN_INTERVAL
        let randomChestSpawnTimer = 0; // New timer for random chest spawns
        const RANDOM_CHEST_SPAWN_INTERVAL = 5; // Check for random chest every 5 seconds
        const RANDOM_CHEST_SPAWN_CHANCE = 0.01; // 1% chance for a chest to spawn
        
        let chests = []; // Array for chests
        let drones = []; // Array for combat drones
        let boomerangs = []; // Array for boomerangs
        let convertedEnemies = []; // Track converted enemies for duration

        // Camera for a larger game world
        let camera = {
            x: 0,
            y: 0,
            width: 900,
            height: 700,
            zoom: 0.8 // Slightly zoomed out
        };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#6A808C', // Blue-grey suit color
            speed: 300, 
            health: 100,
            maxHealth: 100,
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10, 
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 50,
                damageReduction: 0, // Replaced defense
                spinningKnivesDamage: 0, 
                spinningKnivesCount: 0, 
                burstDamage: 0,
                burstProjectileCount: 0,
                droneCount: 0, // New: Number of combat drones
                droneDamage: 0, // New: Combat drone damage
                droneAttackSpeed: 0, // New: Combat drone attack speed
                shotgunPellets: 0, // New: Shotgun pellets
                shotgunDamage: 0, // New: Shotgun damage
                shotgunSpread: 0, // New: Shotgun spread
                dualUziActive: false, // New: Dual Uzi active
                dualUziFireRate: 0, // New: Dual Uzi fire rate
                dualUziDamage: 0, // New: Dual Uzi damage
                boomerangDamage: 0, // New: Boomerang damage
                boomerangCount: 0, // New: Boomerang count
                boomerangCooldown: 4, // New: Boomerang cooldown
                boomerangRange: 150, // New: Boomerang outward travel distance
                boomerangSpeed: 400, // New: Boomerang speed
                burstChargeDamage: 0, // New: Burst Charge damage
                burstChargeProjectileCount: 0, // New: Burst Charge projectile count
            },
            upgrades: {
                damage: 0,
                attackSpeed: 0,
                health: 0,
                speed: 0,
                pierce: 0,
                multiShot: 0,
                healthRegen: 0,
                magnet: 0,
                bulletproofSuit: 0, // Replaced defense
                ultimateRecharge: 0,
                burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, // New: Combat drone upgrade level
                shotgun: 0, // New: Shotgun upgrade level
                dualUzi: 0, // New: Dual Uzi upgrade level
                boomerang: 0, // New: Boomerang upgrade level
                burstCharge: 0, // New: Burst Charge upgrade level
            },
            burstChargeCooldown: 5, // Initial cooldown for burst charge
            burstChargeTimer: 0, // Timer for burst charge
            burstCooldown: 1,
            burstTimer: 0,
            shotgunTimer: 0, // New: Shotgun timer
            dualUziTimer: 0, // New: Dual Uzi timer
            boomerangTimer: 0, // New: Boomerang timer
            lastX: initialPlayerX,
            lastY: initialPlayerY,
            animationFrame: 0,
            isMoving: false,
            vx: 0, // Added velocity X
            vy: 0, // Added velocity Y
            currentShootAngle: 0, // New: Stores the current shooting angle for arm animation
        };

        // Input handling
        const keys = {
            // 'e' key removed as burst charge is now automatic
        };

        // Game entities
        // Enemies, projectiles, etc. are already defined globally.

        // Game control states
        let isPaused = false; // New state variable
        let isMenuOpen = false; // New state variable
        let isMusicMuted = false; // New state variable
        let lastUziSoundTime = 0; // Cooldown for Uzi sound
        const UZI_SOUND_COOLDOWN = 0.05; // 0.05 seconds cooldown for Uzi sound

        // Enemy and power-up configuration
        const ENEMY_TYPES = ['basic', 'fast', 'tank', 'elite', 'gunner', 'drone', 'car', 'ninja', 'enemyDog', 'enemyDrone', 'cobra', 'robotDrone', 'yellowSkull']; // Added new enemy types
        const MAX_UPGRADE_LEVEL = 8;
        const POWER_OPTIONS = [
            { id: 'damage', name: 'Increase Damage', description: 'Increases projectile damage.',
              level: () => player.upgrades.damage,
              effect: () => player.stats.damage += 10,
              next: () => `Increase projectile damage by 10. (Lvl ${player.upgrades.damage + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'attackSpeed', name: 'Increase Attack Speed', description: 'Increases the number of projectiles fired per second.',
              level: () => player.upgrades.attackSpeed,
              effect: () => player.stats.attackSpeed += 2,
              next: () => `Increase fire rate by 2. (Lvl ${player.upgrades.attackSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'health', name: 'Increase Health', description: 'Increases max health and heals you.', 
              level: () => player.upgrades.health,
              effect: () => { player.maxHealth += 25; player.health = Math.min(player.health + 25, player.maxHealth); },
              next: () => `Increase max health by 25 and heal. (Lvl ${player.upgrades.health + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'speed', name: 'Increase Speed', description: 'Increases player movement speed.',
              level: () => player.upgrades.speed,
              effect: () => player.speed += 50,
              next: () => `Increase speed by 50. (Lvl ${player.upgrades.speed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'pierce', name: 'Pierce Shot', description: 'Your projectiles can hit multiple enemies.',
              level: () => player.upgrades.pierce,
              effect: () => player.stats.pierce++,
              next: () => `Projectiles can hit one more enemy. (Lvl ${player.upgrades.pierce + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'multiShot', name: 'Multi-shot', description: 'Fire multiple projectiles at once.', 
              level: () => player.upgrades.multiShot,
              effect: () => player.stats.multiShot++,
              next: () => `Fire one more projectile per shot. (Lvl ${player.upgrades.multiShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'healthRegen', name: 'Health Regen', description: 'Gain passive health regeneration.', 
              level: () => player.upgrades.healthRegen,
              effect: () => player.stats.healthRegen += 0.5,
              next: () => `Increase health regen by 0.5/s. (Lvl ${player.upgrades.healthRegen + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'magnet', name: 'Magnet Range', description: 'Increases the range for collecting XP.',
              level: () => player.upgrades.magnet,
              effect: () => player.stats.magnet += 20,
              next: () => `Increase magnet range by 20. (Lvl ${player.upgrades.magnet + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'bulletproofSuit', name: 'Bulletproof Suit', description: 'Reduces damage taken from all sources.',
              level: () => player.upgrades.bulletproofSuit,
              effect: () => {
                player.upgrades.bulletproofSuit++;
                player.stats.damageReduction = Math.min(0.8, player.upgrades.bulletproofSuit * 0.05); // Max 80% reduction
              },
              next: () => `Reduce damage taken by ${((player.upgrades.bulletproofSuit + 1) * 5).toFixed(0)}%. (Lvl ${player.upgrades.bulletproofSuit + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'burstCharge', name: 'Burst Charge', description: 'Unleashes a slow, wide arc of projectiles automatically.', 
              level: () => player.upgrades.burstCharge,
              effect: () => { 
                player.upgrades.burstCharge++;
                player.stats.burstChargeDamage = 50 + player.upgrades.burstCharge * 25; 
                player.stats.burstChargeProjectileCount = 5 + player.upgrades.burstCharge * 2;
                player.burstChargeCooldown = Math.max(1, 5 - player.upgrades.burstCharge * 0.5); // Min 1 second cooldown
                player.burstChargeTimer = 0; // Reset timer to allow immediate firing if just acquired
              },
              next: () => `Fires ${5 + (player.upgrades.burstCharge + 1) * 2} projectiles in a wide arc. Cooldown: ${(Math.max(1, 5 - (player.upgrades.burstCharge + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.burstCharge + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'ultimateRecharge', name: 'Ultimate Recharge Speed', description: 'The ultimate ability recharges faster.',
              level: () => player.upgrades.ultimateRecharge,
              effect: () => ultimateChargePerHit += 0.2,
              next: () => `Ultimate charges faster per hit. (Lvl ${player.upgrades.ultimateRecharge + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'burstShot', name: 'Multi-shot Burst', description: 'Fires a burst of projectiles in a circle.',
              level: () => player.upgrades.burstShot,
              effect: () => {
                player.stats.burstDamage = 10 + player.upgrades.burstShot * 5;
                player.stats.burstProjectileCount = 8 + player.upgrades.burstShot * 2;
                player.burstCooldown = 1 - (player.upgrades.burstShot * 0.1);
              },
              next: () => `Fires a circle of projectiles. (Lvl ${player.upgrades.burstShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'spinningKnives', name: 'Spinning Knives', description: 'Summon knives that orbit you, damaging enemies.',
              level: () => player.upgrades.spinningKnives,
              effect: () => {
                player.upgrades.spinningKnives++;
                player.stats.spinningKnivesCount++;
                player.stats.spinningKnivesDamage = 15 + player.upgrades.spinningKnives * 5;
                updateSpinningKnivesEffect();
              },
              next: () => `Summon ${player.upgrades.spinningKnives + 1} spinning knives. (Lvl ${player.upgrades.spinningKnives + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'combatDrone', name: 'Combat Drone', description: 'Summon a drone that fires at enemies. Stacks.',
              level: () => player.upgrades.combatDrone,
              effect: () => {
                player.upgrades.combatDrone++;
                player.stats.droneCount = player.upgrades.combatDrone; 
                player.stats.droneDamage = 10 + player.upgrades.combatDrone * 5; 
                player.stats.droneAttackSpeed = 1 + player.upgrades.combatDrone * 0.2; 
                updateDronesEffect(); 
              },
              next: () => `Summon ${player.upgrades.combatDrone + 1} combat drone(s). (Lvl ${player.upgrades.combatDrone + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'shotgun', name: 'Shotgun', description: 'Fires a spray of powerful, short-range pellets.', // Updated description
              level: () => player.upgrades.shotgun,
              effect: () => {
                player.upgrades.shotgun++;
                player.stats.shotgunPellets = 5 + player.upgrades.shotgun * 2;
                player.stats.shotgunDamage = 15 + player.upgrades.shotgun * 5;
                player.stats.shotgunSpread = 0.4; // Fixed spread for consistent spray
                player.shotgunTimer = 0; // Reset timer to allow immediate firing if just acquired
              },
              next: () => `Fires ${5 + (player.upgrades.shotgun + 1) * 2} pellets with a short range. (Lvl ${player.upgrades.shotgun + 1}/${MAX_UPGRADE_LEVEL})`, // Updated next description
            },
            { id: 'dualUzi', name: 'Dual Uzis', description: 'Fires two continuous streams of bullets.',
              level: () => player.upgrades.dualUzi,
              effect: () => {
                player.upgrades.dualUzi++;
                player.stats.dualUziActive = true;
                player.stats.dualUziFireRate = 8 + player.upgrades.dualUzi * 4; // Reduced initial fire rate
                player.stats.dualUziDamage = 2 + player.upgrades.dualUzi * 1.5; // Reduced initial damage
                player.dualUziTimer = 0; // Reset timer to allow immediate firing if just acquired
              },
              next: () => `Fires two streams at ${8 + (player.upgrades.dualUzi + 1) * 4} bullets/s. (Lvl ${player.upgrades.dualUzi + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'boomerang', name: 'Boomerang', description: 'Launches a spinning boomerang that hits enemies and returns.',
              level: () => player.upgrades.boomerang,
              effect: () => {
                player.upgrades.boomerang++;
                player.stats.boomerangCount = 1 + Math.floor(player.upgrades.boomerang / 2); // 1 boomerang per 2 levels, starting at 1
                player.stats.boomerangDamage = 25 + player.upgrades.boomerang * 10;
                player.stats.boomerangCooldown = Math.max(1, 4 - player.upgrades.boomerang * 0.5); // Min 1 second cooldown
              },
              next: () => `Launch ${1 + Math.floor((player.upgrades.boomerang + 1) / 2)} boomerangs. Cooldown: ${(Math.max(1, 4 - (player.upgrades.boomerang + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.boomerang + 1}/${MAX_UPGRADE_LEVEL})`,
            }
        ];
        
        let shootTimer = 0;
        let spawnTimer = 0;
        // Ultimate charge per hit reduced for slower build-up
        let ultimateChargePerHit = 0.5; 
        let lastShotSoundTime = 0;
        let lastEnemyHitSoundTime = 0;
        const enemyHitSoundCooldown = 0.05;


        // Tone.js audio setup
        let playerSynth;
        let enemyHitSynth;
        let levelUpSynth;
        let ultimateSynth;
        let gameOverSynth;
        let backgroundMusicSynth;
        let backgroundMusicSequence;
        let bassSynth;
        let bassSequence;
        let explosionSound;

        // Music pattern variables
        const BACKGROUND_MUSIC_PATTERNS = [
            [["C3", "G3"], ["A#3", "F3"], ["C4", "G3"], ["D#4", "A#3"]],
            [["D3", "A3"], ["C4", "G3"], ["D4", "A3"], ["F4", "C4"]],
            [["E3", "B3"], ["D3", "A3"], ["E4", "B3"], ["G4", "D4"]]
        ];
        const BASS_MUSIC_PATTERNS = [
            ["C1", "G0", "C1", "F0"],
            ["D1", "A0", "D1", "G0"],
            ["E1", "B0", "E1", "A0"]
        ];
        let currentMusicPatternIndex = 0;
        let musicPatternTimer = 0;
        const MUSIC_PATTERN_CHANGE_INTERVAL = 20;

        // Helper function to calculate distance
        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // --- New Collision Resolution Functions ---

        // Resolves collision between two circles (e.g., player/enemy and pillar)
        function circleCircleCollideAndResolve(c1, c2) {
            let dx = c1.x - c2.x;
            let dy = c1.y - c2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = c1.size / 2 + c2.size / 2; // c2.size is diameter for pillar, so c2.size/2 is radius

            if (distance < minDistance) {
                if (distance === 0) { // Objects are exactly on top of each other, push randomly to prevent infinite loop
                    c1.x += Math.random() * 0.1 - 0.05;
                    c1.y += Math.random() * 0.1 - 0.05;
                    return true;
                }
                let overlap = minDistance - distance;
                let normalX = dx / distance;
                let normalY = dy / distance;

                // Push c1 out of c2
                c1.x += normalX * overlap;
                c1.y += normalY * overlap;

                // Slide along the surface (project velocity onto tangent)
                let dotProduct = c1.vx * normalX + c1.vy * normalY;
                if (dotProduct < 0) { // Only if moving towards the obstacle
                    c1.vx -= dotProduct * normalX;
                    c1.vy -= dotProduct * normalY;
                }
                return true;
            }
            return false;
        }

        // Resolves collision between a circle and a rectangle (e.g., player/enemy and desk/chair)
        function circleRectCollideAndResolve(circle, rect) {
            // Find the closest point on the rectangle to the center of the circle
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let dx = circle.x - closestX;
            let dy = circle.y - closestY;
            let distanceSquared = (dx * dx) + (dy * dy);
            let radius = circle.size / 2;

            if (distanceSquared < radius * radius) {
                let distance = Math.sqrt(distanceSquared);
                if (distance === 0) { // Circle center is inside rectangle
                    // Push out along the axis with least penetration
                    let overlapX = Math.min(Math.abs(circle.x - rect.x), Math.abs((rect.x + rect.width) - circle.x));
                    let overlapY = Math.min(Math.abs(circle.y - rect.y), Math.abs((rect.y + rect.height) - circle.y));

                    if (overlapX < overlapY) {
                        circle.x += (circle.x > rect.x + rect.width / 2 ? 1 : -1) * (radius - Math.abs(dx));
                    } else {
                        circle.y += (circle.y > rect.y + rect.height / 2 ? 1 : -1) * (radius - Math.abs(dy));
                    }
                } else {
                    let overlap = radius - distance;
                    let normalX = dx / distance;
                    let normalY = dy / distance;

                    // Push circle out of rectangle
                    circle.x += normalX * overlap;
                    circle.y += normalY * overlap;

                    // Slide along the surface
                    let dotProduct = circle.vx * normalX + circle.vy * normalY;
                    if (dotProduct < 0) { // Only if moving into the obstacle
                        circle.vx -= dotProduct * normalX;
                        circle.vy -= dotProduct * normalY;
                    }
                }
                return true;
            }
            return false;
        }

        // --- End Collision Resolution Functions ---

        // Function to play sound effects
        function playSound(type) {
            // Do not play sounds if music is muted
            if (isMusicMuted && (type === 'playerShot' || type === 'enemyHit' || type === 'levelUp' || type === 'ultimateActivate' || type === 'gameOver' || type === 'explosion')) {
                return;
            }

            switch(type) {
                case 'playerShot':
                    playerSynth.triggerAttackRelease("C4", "8n");
                    break;
                case 'enemyHit':
                    enemyHitSynth.triggerAttackRelease("16n");
                    break;
                case 'levelUp':
                    levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5
                }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.1, decay: 0.5, sustain: 0.3, release: 1
                }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            backgroundMusicSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
                envelope: {
                    attack: 2, decay: 1, sustain: 0.8, release: 3
                },
                volume: -21 // Reduced by an additional 10% (approx 1 dB)
            }).toDestination();

            bassSynth = new Tone.Synth({
                oscillator: { type: "fatsawtooth", count: 4, spread: 40 },
                envelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.8, release: 1.0
                },
                filter: {
                    type: 'lowpass', frequency: 300, Q: 1.5
                },
                filterEnvelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5, baseFrequency: 200, octaves: 1
                },
                volume: -14 // Reduced by an additional 10% (approx 1 dB)
            }).toDestination();

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001, decay: 0.4, release: 0.2
                },
                harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;

            updateMusicPatterns(0);
        }

        function updateMusicPatterns(patternIndex) {
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); // Pass Tone.now()
                backgroundMusicSequence.dispose();
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); // Pass Tone.now()
                bassSequence.dispose();
            }

            backgroundMusicSequence = new Tone.Sequence((time, note) => {
                backgroundMusicSynth.triggerAttackRelease(note, "2n", time);
            }, BACKGROUND_MUSIC_PATTERNS[patternIndex], "4n");
            backgroundMusicSequence.loop = true;
            backgroundMusicSequence.playbackRate = 1;
            backgroundMusicSequence.humanize = true;

            bassSequence = new Tone.Sequence((time, note) => {
                bassSynth.triggerAttackRelease(note, "2n", time);
            }, BASS_MUSIC_PATTERNS[patternIndex], "2n");
            bassSequence.loop = true;
            bassSequence.playbackRate = 1;
            bassSequence.humanize = true;

            if (gameRunning && !isPaused && !isMenuOpen && !isMusicMuted) {
                backgroundMusicSequence.start(0);
                bassSequence.start(0);
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Apply camera zoom to the context
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            
            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); // Draw chests
            drawEnemies();
            drawPlayer();
            drawSpinningKnives(); // Draw spinning knives
            drawFriendlyDog(); // Draw friendly dog
            drawDrones(); // Draw drones
            drawBoomerangs(); // Draw boomerangs
            if (ultimateActive) {
                drawUltimateEffect();
            }
            drawDamageNumbers();
            drawParticles(); // Draw particles

            ctx.restore(); // Restore context to original scale for UI
            drawUI();
            drawMiniMap(); // Draw mini-map last so it's on top of UI
        }
        
        function drawBackground() {
            ctx.fillStyle = '#101010';
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); // Draw background scaled

            const patternSize = 50;
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 1;

            const startX = -camera.x % patternSize;
            const startY = -camera.y % patternSize;

            for (let x = startX; x < camera.width / camera.zoom; x += patternSize) {
                for (let y = startY; y < camera.height / camera.zoom; y += patternSize) {
                    ctx.beginPath();
                    ctx.rect(x, y, patternSize, patternSize);
                    ctx.stroke();
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar') {
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair') {
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                }
            });
        }
        
        function drawPixelArt(ctx, x, y, spriteName, frame, size, isMoving) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;

            if (spriteName === 'player') {
                // Head
                ctx.fillStyle = '#c79b69'; // Skin tone
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                // Body
                ctx.fillStyle = player.color; // Use player's dynamic color
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Legs
                if (isMoving) {
                    const legOffset = Math.sin(frame * 0.5) * s/4; // Slower, more subtle leg swing
                    ctx.fillStyle = player.color; // Suit color
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); // Left leg
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); // Right leg
                } else {
                    ctx.fillStyle = player.color; // Suit color
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); // Left leg
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); // Right leg
                }

                // Arms - dynamic, facing shoot direction
                const armLength = s * 0.8;
                const armWidth = s * 0.3;
                const shoulderXOffset = s * 0.4; // Horizontal distance from player center to arm pivot
                const shoulderYOffset = s * 0.5; // Vertical distance from player center to arm pivot (top of body)

                ctx.fillStyle = player.color; // Suit color for arms

                // Left Arm
                ctx.save();
                // Translate to the left shoulder pivot point
                ctx.translate(screenX - shoulderXOffset, screenY - shoulderYOffset);
                // Rotate by the shooting angle
                ctx.rotate(player.currentShootAngle);
                // Draw the arm, extending from the pivot point in the direction of the angle
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

                // Right Arm
                ctx.save();
                // Translate to the right shoulder pivot point
                ctx.translate(screenX + shoulderXOffset, screenY - shoulderYOffset);
                // Rotate by the shooting angle
                ctx.rotate(player.currentShootAngle);
                // Draw the arm, extending from the pivot point in the direction of the angle
                ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                ctx.restore();

            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;

            // Draw glowing green aura for allied characters
            if (enemy.controlled) {
                ctx.save(); // Save the current state of the canvas
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; // Green glow
                ctx.shadowBlur = 15; // Increased blur for a stronger glow
                ctx.fillStyle = '#00ff66'; // Always green for aura
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); // Slightly larger circle for aura
                ctx.fill();
                ctx.restore(); // Restore the canvas state to remove shadow for the enemy itself
            }

            if (enemy.type === 'robotDrone') {
                ctx.fillStyle = enemy.color; // Original color for robot drone
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2); // Body
                ctx.fill();
                ctx.fillStyle = '#AAAAAA'; // Lighter grey for details
                ctx.fillRect(screenX - s * 0.4, screenY - s * 0.1, s * 0.8, s * 0.2); // Horizontal bar
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.4, s * 0.2, s * 0.8); // Vertical bar
                ctx.fillStyle = '#FF0000'; // Red eye
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'yellowSkull') {
                ctx.fillStyle = enemy.color; // Yellow for the skull
                ctx.beginPath();
                ctx.arc(screenX, screenY - s * 0.5, s * 0.4, 0, Math.PI * 2); // Main skull shape
                ctx.fill();

                ctx.fillStyle = '#000000'; // Black for eye sockets
                ctx.beginPath();
                ctx.arc(screenX - s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(screenX + s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.3, s * 0.2, s * 0.1); // Nose
                ctx.fillRect(screenX - s * 0.2, screenY - s * 0.1, s * 0.4, s * 0.05); // Mouth line
            }
            else {
                // Head
                ctx.fillStyle = '#c79b69'; // Skin tone
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);
                
                // Body
                ctx.fillStyle = enemy.color; // Original enemy color
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Arms (simplified, similar to player)
                ctx.fillRect(screenX - s/2 - s/4, screenY - s, s/4, s); // Left arm
                ctx.fillRect(screenX + s/2, screenY - s, s/4, s); // Right arm
                
                // Legs (animated, similar to player)
                const isEnemyMoving = Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0;
                if (isEnemyMoving) {
                    const legOffset = Math.sin(enemy.animationFrame * 0.5) * s/4; // Slower, more subtle leg swing
                    ctx.fillStyle = enemy.color; // Use enemy color for legs
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); // Left leg
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); // Right leg
                } else {
                    ctx.fillStyle = enemy.color; // Use enemy color for legs
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); // Left leg
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); // Right leg
                }

                if (enemy.type === 'tank') {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                } else if (enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone') { 
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
                } else if (enemy.type === 'elite') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (enemy.type === 'car') {
                    ctx.fillStyle = '#663300'; // Brown for car body
                    ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                    // Removed black spots (wheels) as requested
                } else if (enemy.type === 'ninja') {
                    ctx.fillStyle = '#333333'; // Dark grey for ninja suit
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                    ctx.fillStyle = '#1a1a1a'; // Mask
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
                } else if (enemy.type === 'enemyDog') {
                    ctx.fillStyle = enemy.color; // Use enemy color for dog
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (enemy.type === 'enemyDrone') {
                    ctx.fillStyle = enemy.color; // Cyan for drone
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); // Body
                    ctx.fillStyle = '#666666'; // Grey for propeller
                    ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); // Horizontal propeller
                    ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); // Vertical propeller
                } else if (enemy.type === 'cobra') {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); // Simple square segment
                    // Add a small head indicator for the first segment
                    if (enemy.segmentIndex === 0) {
                        ctx.fillStyle = '#FFD700'; // Gold for head
                        ctx.beginPath();
                        ctx.arc(screenX + s/2, screenY, s/4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw "A" above allied characters
            if (enemy.controlled) {
                ctx.fillStyle = '#00ff66'; // Green color for the 'A'
                ctx.font = 'bold 16px Chakra Petch'; // Larger, bold font
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); // Position above head
            }
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size, player.isMoving);

            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;

            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                
                drawEnemyPixelArt(ctx, enemy);
            });
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw AoE indicator for bazooka projectiles
                if (p.isAoE) {
                    const opacity = 0.5 * (1 - (p.lifetime / p.maxLifetime)); // Fade out
                    ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.aoeRadius * (1 - opacity), 0, Math.PI * 2); // Expand as it fades
                    ctx.stroke();
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FFD700'; // Gold color for coins
                ctx.shadowColor = '#FFA500'; // Orange shadow for glow
                ctx.shadowBlur = 8; // Slightly reduced blur
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); // Draw a circle
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow blur
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; // Brown for chest
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; // Gold for lock
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);
            });
        }

        function drawSpinningKnives() {
            spinningKnives.forEach(knife => {
                const screenX = knife.x - camera.x;
                const screenY = knife.y - camera.y;
                ctx.fillStyle = '#AAAAAA'; // Knife color
                ctx.beginPath();
                ctx.arc(screenX, screenY, knife.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawFriendlyDog() {
            if (friendlyDog) {
                const s = friendlyDog.size;
                const screenX = friendlyDog.x - camera.x;
                const screenY = friendlyDog.y - camera.y;
                
                // Body
                ctx.fillStyle = '#8B4513'; // Brown for dog body
                ctx.beginPath();
                ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.beginPath();
                ctx.moveTo(screenX + s * 0.3, screenY - s * 0.4);
                ctx.lineTo(screenX + s * 0.5, screenY - s * 0.6);
                ctx.lineTo(screenX + s * 0.6, screenY - s * 0.3);
                ctx.fill();

                // Tail
                ctx.beginPath();
                ctx.moveTo(screenX - s * 0.6, screenY + s * 0.1);
                ctx.lineTo(screenX - s * 0.8, screenY - s * 0.1);
                ctx.lineTo(screenX - s * 0.7, screenY + s * 0.2);
                ctx.fill();

                // Legs (simplified)
                ctx.fillRect(screenX - s * 0.4, screenY + s * 0.4, s * 0.15, s * 0.3);
                ctx.fillRect(screenX + s * 0.2, screenY + s * 0.4, s * 0.15, s * 0.3);
            }
        }

        function drawDrones() {
            drones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;

                // Simple drone representation (e.g., a small square with a propeller)
                ctx.fillStyle = '#00FFFF'; // Cyan for drone
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s); // Body
                ctx.fillStyle = '#666666'; // Grey for propeller
                ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); // Horizontal propeller
                ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); // Vertical propeller
            });
        }

        function drawBoomerangs() {
            boomerangs.forEach(b => {
                const screenX = b.x - camera.x;
                const screenY = b.y - camera.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                // Rotate to face direction of movement, adding a slight offset for banana curve
                ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 8); 
                
                ctx.fillStyle = b.color; // Yellow for boomerang
                const bananaWidth = b.size * 0.6; // Thicker part
                const bananaLength = b.size * 2; // Overall length

                ctx.beginPath();
                // Start at one end of the banana
                ctx.moveTo(0, -bananaWidth / 2);
                // Curve to the other end
                ctx.bezierCurveTo(
                    bananaLength * 0.5, -bananaWidth * 1.5, // Control point 1 (outward curve)
                    bananaLength * 0.5, bananaWidth * 1.5,  // Control point 2 (inward curve)
                    0, bananaWidth / 2                      // End point
                );
                // Close the shape to form the other side of the banana
                ctx.bezierCurveTo(
                    -bananaLength * 0.5, bananaWidth * 1.5, // Control point 3
                    -bananaLength * 0.5, -bananaWidth * 1.5, // Control point 4
                    0, -bananaWidth / 2                     // Back to start
                );
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }
        
        function drawUltimateEffect() {
            ctx.beginPath();
            const pulseSize = player.size * (1 + 0.5 * Math.sin(survivalTime * 10));
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.arc(screenX, screenY, pulseSize * 2, 0, Math.PI * 2);
            // Updated to use ultimateDuration/3 for correct fade
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.5 * (ultimateDuration/3)})`; // Fade in/out
            ctx.lineWidth = 10;
            ctx.stroke();

            // Updated to use ultimateDuration/3 for correct fade
            ctx.fillStyle = `rgba(255, 102, 0, ${0.1 * (ultimateDuration/3)})`; // Fade in/out
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); // Fill background scaled
        }

        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `Time: ${minutes}:${seconds}`;
            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
            ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;

            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateButton.classList.add('ready');
            } else {
                ultimateButton.classList.remove('ready');
            }

            // Update mute music button text
            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }
        
        function showDamageNumber(damage, x, y) {
            damageNumbers.push({
                x: x,
                y: y,
                text: Math.round(damage),
                lifetime: 1
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const screenX = d.x - camera.x;
                const screenY = d.y - camera.y;
                ctx.fillStyle = `rgba(255, 50, 50, ${d.lifetime})`;
                ctx.font = `14px 'Chakra Petch'`;
                ctx.textAlign = 'center';
                ctx.fillText(d.text, screenX, screenY);
            });
        }

        // New function to draw particles
        function drawParticles(x, y, colorInput) {
            let r, g, b;

            // Check if colorInput is an object (like {r: 255, g: 100, b: 0})
            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                // Parse enemy color string (e.g., '#777777') to RGB
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                // Default to white if colorInput is neither a string nor a valid object
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); // More particles
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; // Slower initial speed
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, // Smaller particles
                    alpha: 1,
                    color: { r: r, g: g, b: b } // Use the parsed/provided RGB color
                });
            }
        }

        function drawMiniMap() {
            miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            // Draw mini-map background
            miniMapCtx.fillStyle = '#1a1a1a';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            // Draw obstacles on mini-map
            miniMapCtx.fillStyle = '#444444'; // Darker grey for obstacles
            obstacles.forEach(obstacle => {
                const miniX = obstacle.x * miniMapScale;
                const miniY = obstacle.y * miniMapScale;
                if (obstacle.type === 'pillar') {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(miniX, miniY, obstacle.width / 2 * miniMapScale, 0, Math.PI * 2);
                    miniMapCtx.fill();
                } else {
                    miniMapCtx.fillRect(miniX, miniY, obstacle.width * miniMapScale, obstacle.height * miniMapScale);
                }
            });

            // Draw enemies on mini-map
            enemies.forEach(enemy => {
                const miniX = enemy.x * miniMapScale;
                const miniY = enemy.y * miniMapScale;
                miniMapCtx.fillStyle = enemy.controlled ? '#00ff66' : '#ff0000'; // Green for allied, red for hostile
                miniMapCtx.beginPath();
                miniMapCtx.arc(miniX, miniY, enemy.size / 2 * miniMapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            // Draw player on mini-map
            const miniPlayerX = player.x * miniMapScale;
            const miniPlayerY = player.y * miniMapScale;
            miniMapCtx.fillStyle = '#00ffff'; // Cyan for player
            miniMapCtx.beginPath();
            miniMapCtx.arc(miniPlayerX, miniPlayerY, player.size / 2 * miniMapScale, 0, Math.PI * 2);
            miniMapCtx.fill();

            // Draw chests on mini-map
            chests.forEach(chest => {
                const miniX = chest.x * miniMapScale;
                const miniY = chest.y * miniMapScale;
                miniMapCtx.fillStyle = '#FFD700'; // Gold for chests
                miniMapCtx.fillRect(miniX - chest.size / 2 * miniMapScale, miniY - chest.size / 2 * miniMapScale, chest.size * miniMapScale, chest.size * miniMapScale);
            });
        }

        function drawStartMenu() {
            startMenu.style.display = 'block';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden
        }
        
        function drawGameOverMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'block';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden
        }
        
        function updatePlayer(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            player.isMoving = distance > 5;
            if (player.isMoving) {
                const angle = Math.atan2(dy, dx);
                // Apply playerSpeedModifier if ultimate is active
                const currentSpeed = player.speed * (ultimateActive ? playerSpeedModifier : 1);
                player.vx = Math.cos(angle) * currentSpeed;
                player.vy = Math.sin(angle) * currentSpeed;
            } else {
                player.vx = 0; // Reset velocity if not actively moving
                player.vy = 0; // Reset velocity if not actively moving
            }

            // Calculate potential new position
            let newX = player.x + player.vx * effectiveDt;
            let newY = player.y + player.vy * effectiveDt;

            // Create a temporary object for collision checking and resolution
            let tempPlayer = {
                x: newX,
                y: newY,
                size: player.size,
                vx: player.vx,
                vy: player.vy
            };
            
            // Resolve collisions with obstacles
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'pillar') {
                    // Pillar is treated as a circle for collision
                    let pillarCircle = {
                        x: obstacle.x,
                        y: obstacle.y,
                        size: obstacle.width // obstacle.width is its diameter
                    };
                    circleCircleCollideAndResolve(tempPlayer, pillarCircle);
                } else { // desk or chair (rectangle)
                    circleRectCollideAndResolve(tempPlayer, obstacle);
                }
            });

            // Apply resolved position and velocity back to player
            player.x = tempPlayer.x;
            player.y = tempPlayer.y;
            player.vx = tempPlayer.vx; 
            player.vy = tempPlayer.vy;

            // Boundary checks (applied after collision resolution)
            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
            
            // Animation frame update
            if (player.isMoving) {
                player.animationFrame = (player.animationFrame + effectiveDt * 10) % 4;
            } else {
                player.animationFrame = 0;
            }
        
            player.health += player.stats.healthRegen * effectiveDt;
            player.health = Math.min(player.health + player.stats.healthRegen * effectiveDt, player.maxHealth);
        
            // Burst Charge (formerly Circular Wave) - now automatic
            if (player.upgrades.burstCharge > 0 && player.burstChargeTimer <= 0) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; // Update shoot angle for arms
                    const numProjectiles = player.stats.burstChargeProjectileCount;
                    const arcSpread = 0.8; // Radians, about 45 degrees
                    const angleStep = arcSpread / (numProjectiles > 1 ? (numProjectiles - 1) : 1);
                    const startAngle = angle - arcSpread / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const projectileAngle = startAngle + i * angleStep;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), // 50% slower
                            vy: Math.sin(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), // 50% slower
                            size: 5, // Slightly larger projectile for visual distinction
                            damage: ultimateActive ? player.stats.burstChargeDamage * 3 : player.stats.burstChargeDamage,
                            color: ultimateActive ? '#ff9933' : '#00ffff', // Orange-ish for ultimate, Cyan for normal
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    player.burstChargeTimer = player.burstChargeCooldown;
                    playSound('playerShot'); // Re-use player shot sound
                }
            }
        
            if (shootTimer >= 1 / player.stats.attackSpeed) {
                const closestEnemy = findClosestEnemy();
                
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; // Update shoot angle for arms
                    
                    let currentMultiShot = player.stats.multiShot;
                    let currentProjectileSpeed = player.stats.projectileSpeed;
                    let currentDamage = player.stats.damage;

                    // Apply temporary spread gun effect
                    if (temporaryPowerupType === 'spreadGun') {
                        currentMultiShot = 5; // Fixed spread for temporary spread gun
                        currentProjectileSpeed = 300; // Slightly slower projectiles for spread
                        currentDamage = player.stats.damage * 0.75; // Slightly reduced damage per projectile
                    }

                    for (let i = 0; i < currentMultiShot; i++) {
                        const spread = (i - (currentMultiShot - 1) / 2) * 0.1; 
                        const projectileAngle = angle + spread;
                        
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            vy: Math.sin(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            size: 3,
                            damage: ultimateActive ? currentDamage * 3 : currentDamage,
                            color: ultimateActive ? '#ff6600' : '#d1d1d1',
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    if (survivalTime - lastShotSoundTime >= 5) {
                        playSound('playerShot'); 
                        lastShotSoundTime = survivalTime;
                    }
                }
                
                shootTimer = 0;
            }

            if (player.stats.burstDamage > 0 && player.burstTimer >= player.burstCooldown) {
                const closestEnemy = findClosestEnemy(); // Find enemy for arm direction
                if (closestEnemy) {
                    player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); // Update shoot angle for arms
                }
                const numProjectiles = player.stats.burstProjectileCount;
                const angleStep = (Math.PI * 2) / numProjectiles;
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = i * angleStep;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        vy: Math.sin(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        size: 3,
                        damage: player.stats.burstDamage,
                        color: ultimateActive ? '#ff6600' : '#d1d1d1',
                        pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                        hits: 0
                    });
                }
                player.burstTimer = 0;
                if (survivalTime - lastShotSoundTime >= 5) {
                    playSound('playerShot'); 
                    lastShotSoundTime = survivalTime;
                }
            }

            // Shotgun firing logic
            if (player.upgrades.shotgun > 0) {
                player.shotgunTimer += effectiveDt;
                const shotgunCooldown = 0.8 / (1 + player.upgrades.shotgun * 0.1); // Faster with levels
                if (player.shotgunTimer >= shotgunCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy && dist(player, closestEnemy) < 200) { // Shotgun short range
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; // Update shoot angle for arms
                        for (let i = 0; i < player.stats.shotgunPellets; i++) {
                            const spread = (i - (player.stats.shotgunPellets - 1) / 2) * player.stats.shotgunSpread;
                            const projectileAngle = angle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 300, // Fixed shotgun pellet speed
                                vy: Math.sin(projectileAngle) * 300,
                                size: 5,
                                damage: player.stats.shotgunDamage,
                                color: '#FFA500', // Orange for shotgun pellets
                                pierce: 0, // Shotgun pellets don't pierce
                                hits: 0,
                                lifetime: 0.3, // Short lifetime for quick falloff
                                maxLifetime: 0.3 // For tracking remaining lifetime
                            });
                        }
                        playSound('playerShot'); // Re-use player shot sound for now
                        player.shotgunTimer = 0;
                    }
                }
            }

            // Dual Uzi firing logic
            if (player.stats.dualUziActive) {
                player.dualUziTimer += effectiveDt;
                const uziCooldown = 1 / player.stats.dualUziFireRate;
                if (player.dualUziTimer >= uziCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; // Update shoot angle for arms
                        const offset = 10; // Offset for dual barrels
                        
                        // Left Uzi
                        projectiles.push({
                            x: player.x + Math.cos(angle - Math.PI/2) * offset,
                            y: player.y + Math.sin(angle - Math.PI/2) * offset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', // Green for Uzi bullets
                            pierce: 0,
                            hits: 0
                        });
                        // Right Uzi
                        projectiles.push({
                            x: player.x + Math.cos(angle + Math.PI/2) * offset,
                            y: player.y + Math.sin(angle + Math.PI/2) * offset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', // Green for Uzi bullets
                            pierce: 0,
                            hits: 0
                        });
                        // Play Uzi sound with cooldown
                        if (survivalTime - lastUziSoundTime >= UZI_SOUND_COOLDOWN) {
                            playSound('playerShot'); 
                            lastUziSoundTime = survivalTime;
                        }
                    }
                    player.dualUziTimer = 0;
                }
            }

            // Boomerang firing logic
            if (player.stats.boomerangCount > 0) {
                player.boomerangTimer += effectiveDt;
                if (player.boomerangTimer >= player.stats.boomerangCooldown) {
                    const closestEnemy = findClosestEnemy(); // Find enemy for arm direction
                    if (closestEnemy) {
                        player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); // Update shoot angle for arms
                    }
                    const numBoomerangs = player.stats.boomerangCount;
                    const angleStep = (Math.PI * 2) / numBoomerangs; 
                    for (let i = 0; i < numBoomerangs; i++) {
                        const initialAngle = Math.random() * Math.PI * 2; // Random initial direction
                        boomerangs.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(initialAngle) * player.stats.boomerangSpeed,
                            vy: Math.sin(initialAngle) * player.stats.boomerangSpeed,
                            size: 15, // Slightly larger size for boomerang
                            damage: player.stats.boomerangDamage,
                            color: '#FFFF00', // Yellow for boomerang
                            distanceTraveled: 0,
                            returning: false,
                            hitEnemies: new Set(), // To prevent hitting same enemy multiple times per launch
                            maxOutwardDistance: player.stats.boomerangRange,
                            speed: player.stats.boomerangSpeed
                        });
                    }
                    player.boomerangTimer = 0;
                }
            }
        }

        function findClosestEnemy() {
            let closest = null;
            let minDistance = Infinity;

            enemies.forEach(enemy => {
                const distance = dist(player, enemy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function activateUltimate() {
            ultimateActive = true;
            ultimateDuration = 3; // Wicked mode now lasts 3 seconds
            player.color = '#ff6600'; 
            ultimateCharge = 0;
            playSound('ultimateActivate');

            // Activate Bullet Time effect
            gameSpeedMultiplier = 0.25; // Everything else moves at 25% speed
            playerSpeedModifier = 3; // Player and player projectiles move at 75% speed (0.25 * 3 = 0.75)
            projectileSpeedModifier = 3;
            if (!isMusicMuted) Tone.Transport.playbackRate = 0.5; // Slow down music only if not muted
        }
        
        function updateEnemies(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier

            // Faster enemy appearance
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            // Adjusted spawn rate factor for smoother difficulty build-up (max at 10 mins)
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            // Increase spawn rate significantly for the first minute
            if (survivalTime < 60) {
                spawnInterval *= 0.33; // Reduce interval by 67% to increase spawn rate by 3x (1 / 3 = 0.33)
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: // Top
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: // Right
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: // Bottom
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: // Left
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes < 0.5) { // First 30 seconds: basic, enemyDog, enemyDrone, robotDrone
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; // New: Robot Drone
                } else if (timeInMinutes < 2) { // First 2 minutes: mostly basic, some tanks, drones, dogs, robotDrones
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; // New: Robot Drone
                } else if (timeInMinutes < 5) { // From 2 to 5 minutes: still basic and tank, but more variety in distribution, introduce cobra, more robotDrones
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; // Still high chance of basic
                    else if (rand < 0.7) enemyType = 'tank'; // Increased chance of tank
                    else if (rand < 0.8) enemyType = 'car'; // Small chance of car (non-shooter)
                    else if (rand < 0.9) enemyType = 'cobra'; // Introduce cobra
                    else enemyType = 'robotDrone'; // Increased chance of Robot Drone
                } else if (timeInMinutes < 8) { // From 5 to 8 minutes: introduce shooters, all types
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; // Shooter
                    else if (rand < 0.4) enemyType = 'gunner'; // Shooter
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; // Shooter
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; // Still present
                } else { // After 8 minutes: all enemy types, including ninjas, and robotDrones, and yellowSkull
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; // Shooter
                    else if (rand < 0.25) enemyType = 'gunner'; // Shooter
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; // Shooter
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; // Melee, but high level
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; // Still present
                    else enemyType = 'yellowSkull'; // New: Yellow Skull
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, // Initialize animation frame for enemies
                        stuckTimer: 0, // Initialize stuck timer
                        ghostModeActive: false, // Initialize ghost mode flag
                        ghostModeTimer: 0, // Initialize ghost mode timer
                        lastX: x, // For stuck detection
                        lastY: y, // For stuck detection
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        
            enemies = enemies.filter(enemy => {
                let angle;

                // Store current position before movement and collision resolution
                const prevX = enemy.x;
                const prevY = enemy.y;

                if (enemy.controlled) {
                    const closestEnemy = enemies
                        .filter(e => !e.controlled)
                        .sort((a, b) => dist(enemy, a) - dist(enemy, b))[0];
                    if (closestEnemy) {
                        angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - closestEnemy.x);
                    } else {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        // Controlled enemy stays on screen if no targets
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    }
                } else if (enemy.type === 'cobra') {
                    // Cobra segment movement
                    if (enemy.segmentIndex === 0) { // Head segment
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        // Cobras move primarily horizontally
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed; // Allow vertical movement for head
                    } else { // Body segments follow previous segment
                        const prevSegment = enemies.find(e => e.snakeId === enemy.snakeId && e.segmentIndex === enemy.segmentIndex - 1);
                        if (prevSegment) {
                            const dx = prevSegment.x - enemy.x;
                            const dy = prevSegment.y - enemy.y;
                            const segmentDistance = Math.sqrt(dx*dx + dy*dy);
                            const minSegmentDistance = enemy.size * 1.2; // Keep segments slightly spaced
                            
                            if (segmentDistance > minSegmentDistance) {
                                angle = Math.atan2(dy, dx);
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0;
                                enemy.vy = 0;
                            }
                        } else {
                            // If previous segment is gone, this segment becomes a new head or despawns
                            // For simplicity, if previous is gone, this segment stops for now.
                            enemy.vx = 0;
                            enemy.vy = 0;
                        }
                    }
                } else if (enemy.type === 'robotDrone') {
                    // Robot drones move directly to player
                    angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                    // If close enough, explode
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2 + 10)) { // Add a small buffer
                        explodeRobotDrone(enemy);
                        return false; // Remove drone
                    }
                } else { 
                    const distance = dist(player, enemy);
                    // Modified condition to include 'fast' and 'drone' enemies for shooting
                    if ((enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone' || enemy.type === 'enemyDrone') && distance < enemy.attackRange) {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.shootTimer += effectiveDt; 
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            // Determine if it's a bazooka shot
                            const isBazooka = survivalTime > 300 || player.level > 5; // Example condition for bazooka upgrade
                            
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * enemy.projectileSpeed,
                                vy: Math.sin(angle) * enemy.projectileSpeed,
                                size: isBazooka ? 15 : enemy.projectileSize, // Larger for bazooka
                                damage: isBazooka ? enemy.projectileDamage * 2 : enemy.projectileDamage, // More damage for bazooka
                                color: isBazooka ? '#FF4500' : enemy.projectileColor, // Orange for bazooka
                                hits: 0,
                                isAoE: isBazooka, // New property for AoE
                                aoeRadius: isBazooka ? 70 : 0, // AoE radius for bazooka
                                lifetime: isBazooka ? 1 : 0, // For fading AoE indicator
                                maxLifetime: isBazooka ? 1 : 0 // For fading AoE indicator
                            });
                            enemy.shootTimer = 0;
                        }
                        enemy.vx = 0; // Shooter enemy stops when attacking
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        
                        if (enemy.type !== 'gunner' && Math.random() < 0.01) { 
                            enemy.flankAngle = (Math.random() - 0.5) * Math.PI / 2;
                        }
                        if (enemy.flankAngle !== undefined) {
                            angle += enemy.flankAngle;
                        }
                    }
                }

                // Calculate enemy's desired velocity
                if (enemy.type !== 'cobra' || enemy.segmentIndex === 0) { // Only apply to non-cobra or cobra head
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                }
                

                // Create a temporary object for collision checking and resolution
                let tempEnemy = {
                    x: enemy.x + enemy.vx * effectiveDt, 
                    y: enemy.y + enemy.vy * effectiveDt, 
                    size: enemy.size,
                    vx: enemy.vx,
                    vy: enemy.vy
                };

                // Apply collision resolution ONLY if not in ghost mode
                if (!enemy.ghostModeActive) {
                    // Resolve collisions with obstacles
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar') {
                            let pillarCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempEnemy, pillarCircle);
                        } else {
                            circleRectCollideAndResolve(tempEnemy, obstacle);
                        }
                    });
                }


                // Apply resolved position and velocity back to enemy
                enemy.x = tempEnemy.x;
                enemy.y = tempEnemy.y;
                enemy.vx = tempEnemy.vx; 
                enemy.vy = tempEnemy.vy;

                // Check if the enemy is stuck and manage ghost mode
                const movedDistance = dist({x: prevX, y: prevY}, {x: enemy.x, y: enemy.y});
                const stuckThreshold = 1; // A small distance to consider it stuck

                if (movedDistance < stuckThreshold) {
                    enemy.stuckTimer += effectiveDt;
                    if (enemy.stuckTimer >= 2 && !enemy.ghostModeActive) { // Stuck for 2 seconds
                        enemy.ghostModeActive = true;
                        enemy.ghostModeTimer = 1; // Ghost for 1 second
                        enemy.stuckTimer = 0; // Reset stuck timer
                        console.log(`Enemy ${enemy.type} entered ghost mode!`);
                    }
                } else {
                    enemy.stuckTimer = 0; // Reset if moving
                }

                if (enemy.ghostModeActive) {
                    enemy.ghostModeTimer -= effectiveDt;
                    if (enemy.ghostModeTimer <= 0) {
                        enemy.ghostModeActive = false;
                        enemy.stuckTimer = 0; // Reset stuck timer when exiting ghost mode
                        console.log(`Enemy ${enemy.type} exited ghost mode.`);
                    }
                }


                // Update enemy animation frame
                if (Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0) {
                    enemy.animationFrame = (enemy.animationFrame + effectiveDt * 10) % 4;
                } else {
                    enemy.animationFrame = 0;
                }

                // Boundary checks for enemies
                enemy.x = Math.max(-100, Math.min(gameWorld.width + 100, enemy.x)); // Increased boundary for enemies
                enemy.y = Math.max(-100, Math.min(gameWorld.height + 100, enemy.y));
        
                return enemy.x > -150 && enemy.x < gameWorld.width + 150 && // Filter out further off-screen
                       enemy.y > -150 && enemy.y < gameWorld.height + 150;
            });

            // After filtering, re-index cobra segments if any were removed
            const cobraIds = new Set(enemies.filter(e => e.type === 'cobra').map(e => e.snakeId));
            cobraIds.forEach(id => {
                let segments = enemies.filter(e => e.snakeId === id).sort((a, b) => a.segmentIndex - b.segmentIndex);
                segments.forEach((segment, index) => {
                    segment.segmentIndex = index; // Re-assign indices
                });
            });
        }
        
        function updateProjectiles(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier
            projectiles = projectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                // New: Decrease lifetime for shotgun projectiles
                if (p.lifetime !== undefined) {
                    p.lifetime -= effectiveDt;
                }
                
                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && p.hits <= p.pierce && (p.lifetime === undefined || p.lifetime > 0); // Check lifetime
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.isAoE) {
                    p.lifetime -= effectiveDt;
                }

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && (!p.isAoE || p.lifetime > 0);
            });
        }
        
        function updatePowerups(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier
            powerups = powerups.filter(p => {
                const distance = dist(player, p);
                if (distance < player.stats.magnet) {
                    const angle = Math.atan2(player.y - p.y, player.x - p.x);
                    p.x += Math.cos(angle) * p.speed * effectiveDt; 
                    p.y += Math.sin(angle) * p.speed * effectiveDt; 
                }
                return true;
            });
        }

        function updateChests(dt) {
            chests = chests.filter(chest => {
                // Chests don't move, just check collision
                return true;
            });
        }
        
        function updateDamageNumbers(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier
            damageNumbers = damageNumbers.filter(d => {
                d.y -= 20 * effectiveDt; 
                d.lifetime -= effectiveDt; 
                return d.lifetime > 0;
            });
        }

        // New function to update particles
        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha -= dt * 2; // Fade out over 0.5 seconds
                p.size -= dt * 5; // Shrink over time
                return p.alpha > 0 && p.size > 0;
            });
        }

        // New function to update spinning knives position and properties
        function updateSpinningKnivesEffect() {
            // Clear existing knives and recreate based on upgrade level
            spinningKnives = [];
            const numKnives = player.stats.spinningKnivesCount;
            const radius = player.size * 2; // Orbit radius
            const knifeSize = 5;
            const knifeDamage = player.stats.spinningKnivesDamage;
            const rotationSpeed = 5; // How fast they orbit

            for (let i = 0; i < numKnives; i++) {
                spinningKnives.push({
                    angle: (Math.PI * 2 / numKnives) * i, // Initial angle
                    radius: radius,
                    size: knifeSize,
                    damage: knifeDamage,
                    rotationSpeed: rotationSpeed,
                    hitEnemies: new Set() // Track enemies hit per cycle
                });
            }
        }

        function updateFriendlyDog(dt) {
            if (friendlyDog) {
                const effectiveDt = dt * gameSpeedMultiplier;
                const closestEnemy = enemies.find(e => !e.controlled); // Find closest non-controlled enemy
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - friendlyDog.y, closestEnemy.x - friendlyDog.x);
                    friendlyDog.x += Math.cos(angle) * friendlyDog.speed * effectiveDt;
                    friendlyDog.y += Math.sin(angle) * friendlyDog.speed * effectiveDt;

                    // Dog attacks enemies on collision
                    if (dist(friendlyDog, closestEnemy) < (friendlyDog.size / 2 + closestEnemy.size / 2)) {
                        closestEnemy.health -= friendlyDog.damage;
                        showDamageNumber(friendlyDog.damage, closestEnemy.x, closestEnemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit'); 
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        if (closestEnemy.health <= 0) {
                            gainXp(closestEnemy.xp);
                            score += 10;
                            spawnParticles(closestEnemy.x, closestEnemy.y, closestEnemy.color); // Spawn particles on death
                            enemies = enemies.filter(e => e !== closestEnemy); // Remove defeated enemy
                        }
                    }
                } else {
                    // If no enemies, dog follows player
                    const angle = Math.atan2(player.y - friendlyDog.y, player.x - friendlyDog.x);
                    friendlyDog.x += Math.cos(angle) * friendlyDog.speed * effectiveDt;
                    friendlyDog.y += Math.sin(angle) * friendlyDog.speed * effectiveDt;
                }
            }
        }

        function updateDrones(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            drones.forEach(drone => {
                const closestEnemy = enemies.find(e => !e.controlled); // Each drone targets the closest non-controlled enemy
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                    // Drones orbit the player if no target, or move towards target
                    if (dist(drone, player) > 150) { // Orbit distance
                        drone.x += Math.cos(angle) * drone.speed * effectiveDt;
                        drone.y += Math.sin(angle) * drone.speed * effectiveDt;
                    } else {
                        // Simple orbit around player
                        drone.orbitAngle += effectiveDt * 2; // Orbit speed
                        drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                        drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                    }

                    drone.shootTimer += effectiveDt;
                    if (drone.shootTimer >= 1 / drone.attackSpeed) {
                        projectiles.push({
                            x: drone.x,
                            y: drone.y,
                            vx: Math.cos(angle) * 500, // Drone projectile speed
                            vy: Math.sin(angle) * 500,
                            size: 4,
                            damage: drone.damage,
                            color: '#00FFFF', // Cyan for drone projectiles
                            pierce: 0,
                            hits: 0
                        });
                        drone.shootTimer = 0;
                    }
                } else {
                    // If no enemies, drones orbit the player
                    drone.orbitAngle += effectiveDt * 2; 
                    drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                    drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                }
            });
        }

        function updateDronesEffect() {
            // Ensure we have the correct number of drones
            while (drones.length < player.stats.droneCount) {
                const newDrone = {
                    x: player.x,
                    y: player.y,
                    size: 10,
                    speed: 200, // Base speed for drones
                    damage: player.stats.droneDamage,
                    attackSpeed: player.stats.droneAttackSpeed,
                    shootTimer: 0,
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitRadius: 50 + drones.length * 10 // Stagger orbit radius
                };
                drones.push(newDrone);
            }
            // Update existing drones' stats if they have changed
            drones.forEach(drone => {
                drone.damage = player.stats.droneDamage;
                drone.attackSpeed = player.stats.droneAttackSpeed;
            });
        }

        function updateBoomerangs(dt) {
            boomerangs = boomerangs.filter(b => {
                if (!b.returning) {
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.distanceTraveled += b.speed * dt;

                    if (b.distanceTraveled >= b.maxOutwardDistance) {
                        b.returning = true;
                    }
                } else {
                    const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                    b.vx = Math.cos(angleToPlayer) * b.speed;
                    b.vy = Math.sin(angleToPlayer) * b.speed;
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;

                    // Check if boomerang has returned to player
                    if (dist(player, b) < player.size / 2 + b.size / 2) {
                        return false; // Remove boomerang
                    }
                }
                // Keep boomerang on screen
                return b.x > -100 && b.x < gameWorld.width + 100 && b.y > -100 && b.y < gameWorld.height + 100;
            });
        }
        
        function checkCollisions() {
            enemies.forEach(enemy => {
                if (!enemy.controlled) {
                    // Melee collision for basic, tank, car, ninja, enemyDog, cobra, yellowSkull
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2) && 
                        (enemy.type === 'basic' || enemy.type === 'tank' || enemy.type === 'car' || enemy.type === 'ninja' || enemy.type === 'enemyDog' || enemy.type === 'cobra' || enemy.type === 'yellowSkull')) {
                        let damageTaken = enemy.damage;
                        // Apply bulletproof suit damage reduction
                        damageTaken = damageTaken * (1 - player.stats.damageReduction);
                        
                        // Reduce damage by 50% if ultimate is active
                        if (ultimateActive) {
                            damageTaken *= 0.5;
                        }
                        damageTaken = Math.max(0, damageTaken); // Ensure damage is not negative
                        player.health -= damageTaken;
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
        
            // Iterate backwards to safely remove projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    if (!enemy.controlled && dist(p, enemy) < (p.size + enemy.size / 2)) {
                        // If it's a robot drone and hit, explode it
                        if (enemy.type === 'robotDrone') {
                            explodeRobotDrone(enemy);
                            enemies.splice(j, 1); // Remove drone after explosion
                            projectileRemoved = true; // Remove projectile too
                            break;
                        }
                        
                        // Apply damage
                        const damageDealt = p.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit'); 
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        p.hits++;
        
                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            spawnParticles(enemy.x, enemy.y, enemy.color);
                            // Powerups (XP coins) still drop from enemies
                            if (Math.random() < 0.1) {
                                spawnPowerup(enemy.x, enemy.y);
                            }
                            enemies.splice(j, 1); // Remove defeated enemy
                        }

                        if (p.hits > p.pierce) {
                            projectiles.splice(i, 1);
                            projectileRemoved = true;
                            break; // Break inner loop, move to next projectile
                        }
                    }
                }
            }

            // Enemy projectile collision with player and other enemies (for AoE)
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    let damageTaken = p.damage;
                    // Apply bulletproof suit damage reduction
                    damageTaken = damageTaken * (1 - player.stats.damageReduction);

                    // Reduce damage by 50% if ultimate is active
                    if (ultimateActive) {
                        damageTaken *= 0.5;
                    }
                    damageTaken = Math.max(0, damageTaken); // Ensure damage is not negative
                    player.health -= damageTaken;
                    if (player.health <= 0) {
                        gameOver();
                    }

                    if (p.isAoE) {
                        // Apply AoE damage to other enemies around the player
                        enemies.forEach(otherEnemy => {
                            // Ensure it's not the enemy that fired the projectile and it's not a controlled enemy
                            if (otherEnemy !== p.sourceEnemy && !otherEnemy.controlled && dist(player, otherEnemy) < p.aoeRadius) {
                                otherEnemy.health -= p.damage * 0.5; // Reduced damage for AoE splash
                                showDamageNumber(p.damage * 0.5, otherEnemy.x, otherEnemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                                if (otherEnemy.health <= 0) {
                                    gainXp(otherEnemy.xp);
                                    score += 10;
                                    spawnParticles(otherEnemy.x, otherEnemy.y, otherEnemy.color);
                                }
                            }
                        });
                        playSound('explosion'); // Play explosion sound for AoE hit
                        spawnParticles(p.x, p.y, {r: 255, g: 100, b: 0}); // Orange explosion particles
                    }
                    enemyProjectiles.splice(i, 1); // Remove projectile after hit
                    i--; // Decrement index as array length changed
                }
            }

            // Spinning knives collision with enemies
            spinningKnives.forEach(knife => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !knife.hitEnemies.has(enemy) && dist(knife, enemy) < (knife.size + enemy.size / 2)) {
                        const damageDealt = knife.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        knife.hitEnemies.add(enemy); // Mark enemy as hit by this knife in this cycle

                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            spawnParticles(enemy.x, enemy.y, enemy.color); // Spawn particles on death
                        }
                    }
                });
                // Reset hit enemies for the next update cycle
                knife.hitEnemies.clear();
            });

            // Boomerang collision with enemies
            boomerangs.forEach(b => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !b.hitEnemies.has(enemy) && dist(b, enemy) < (b.size + enemy.size / 2)) {
                        const damageDealt = b.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        b.hitEnemies.add(enemy); // Mark enemy as hit by this boomerang

                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            spawnParticles(enemy.x, enemy.y, enemy.color);
                        }
                    }
                });
            });
        
            enemies.forEach(controlledEnemy => {
                if (controlledEnemy.controlled) {
                    enemies.forEach(targetEnemy => {
                        if (!targetEnemy.controlled && controlledEnemy !== targetEnemy) {
                            if (dist(controlledEnemy, targetEnemy) < (controlledEnemy.size / 2 + targetEnemy.size / 2)) {
                                targetEnemy.health -= controlledEnemy.damage;
                                showDamageNumber(controlledEnemy.damage, targetEnemy.x, targetEnemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit'); 
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                                if (targetEnemy.health <= 0) {
                                    gainXp(targetEnemy.xp);
                                    score += 10;
                                    spawnParticles(targetEnemy.x, targetEnemy.y, targetEnemy.color); // Spawn particles on death
                                }
                            }
                        }
                    });
                }
            });
        
            powerups.forEach(p => {
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    gainXp(p.xpValue);
                    powerups = powerups.filter(item => item !== p);
                }
            });

            // Chest collision
            for (let i = chests.length - 1; i >= 0; i--) {
                const chest = chests[i];
                if (dist(player, chest) < (player.size / 2 + chest.size / 2)) {
                    activateTemporaryPowerup();
                    chests.splice(i, 1);
                }
            }
        
            enemies = enemies.filter(enemy => enemy.health > 0);
        }
        
        function spawnEnemy() {
            // Spawn rate adjustments
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            // Adjusted spawn rate factor for smoother difficulty build-up (max at 10 mins)
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            // Increase spawn rate significantly for the first minute
            if (survivalTime < 60) {
                spawnInterval *= 0.33; // Reduce interval by 67% to increase spawn rate by 3x (1 / 3 = 0.33)
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: // Top
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: // Right
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: // Bottom
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: // Left
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                if (timeInMinutes < 0.5) { // First 30 seconds: basic, enemyDog, enemyDrone, robotDrone
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; // New: Robot Drone
                } else if (timeInMinutes < 2) { // First 2 minutes: mostly basic, some tanks, drones, dogs, robotDrones
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; // New: Robot Drone
                } else if (timeInMinutes < 5) { // From 2 to 5 minutes: still basic and tank, but more variety in distribution, introduce cobra, more robotDrones
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; // Still high chance of basic
                    else if (rand < 0.7) enemyType = 'tank'; // Increased chance of tank
                    else if (rand < 0.8) enemyType = 'car'; // Small chance of car (non-shooter)
                    else if (rand < 0.9) enemyType = 'cobra'; // Introduce cobra
                    else enemyType = 'robotDrone'; // Increased chance of Robot Drone
                } else if (timeInMinutes < 8) { // From 5 to 8 minutes: introduce shooters, all types
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; // Shooter
                    else if (rand < 0.4) enemyType = 'gunner'; // Shooter
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; // Shooter
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; // Still present
                } else { // After 8 minutes: all enemy types, including ninjas, and robotDrones, and yellowSkull
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; // Shooter
                    else if (rand < 0.25) enemyType = 'gunner'; // Shooter
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; // Shooter
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; // Melee, but high level
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; // Still present
                    else enemyType = 'yellowSkull'; // New: Yellow Skull
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, // Initialize animation frame for enemies
                        stuckTimer: 0, // Initialize stuck timer
                        ghostModeActive: false, // Initialize ghost mode flag
                        ghostModeTimer: 0, // Initialize ghost mode timer
                        lastX: x, // For stuck detection
                        lastY: y, // For stuck detection
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        }

        function spawnCobra(x, y) {
            const numSegments = 5 + Math.floor(Math.random() * 3); // 5 to 7 segments
            const segmentSize = 25;
            const snakeId = Date.now(); // Unique ID for this snake instance

            for (let i = 0; i < numSegments; i++) {
                const segmentX = x - i * segmentSize * 1.5; // Spawn segments horizontally
                const segmentY = y;
                enemies.push({
                    x: segmentX,
                    y: segmentY,
                    type: 'cobra',
                    controlled: false, // Cobras are not controlled by player
                    snakeId: snakeId,
                    segmentIndex: i,
                    stuckTimer: 0, // Initialize stuck timer
                    ghostModeActive: false, // Initialize ghost mode flag
                    ghostModeTimer: 0, // Initialize ghost mode timer
                    lastX: segmentX, // For stuck detection
                    lastY: segmentY, // For stuck detection
                    ...getEnemyStats('cobra')
                });
            }
        }
        
        function getEnemyStats(type) {
            const base = {
                size: 25, speed: 30, health: 50, damage: 10, xp: 10,
                // Default projectile stats for shooting enemies
                projectileSize: 8, projectileDamage: 15, projectileSpeed: 100, projectileColor: '#FF4500', attackRange: 250, attackSpeed: 0.8
            };
        
            switch (type) {
                case 'fast':
                    base.size = 20; base.speed = 50; base.health = 30; base.xp = 15; base.color = '#ff4444';
                    base.attackRange = 200; base.attackSpeed = 2; base.projectileSpeed = 150; // Slower projectiles
                    break;
                case 'tank':
                    base.size = 40; base.speed = 15; base.health = 200; base.xp = 50; base.color = '#9966ff';
                    // Tanks don't shoot by default
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'elite':
                    base.size = 30; base.speed = 40; base.health = 500; base.damage = 20; base.xp = 200; base.color = '#ff0000';
                    // Elites don't shoot by default
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'gunner':
                    base.size = 25; base.speed = 20; base.health = 40; base.damage = 0; base.xp = 20; base.color = '#3399ff';
                    base.attackRange = 400; base.attackSpeed = 1; base.projectileSpeed = 100; // Slower projectiles
                    break;
                case 'drone':
                    base.size = 15; base.speed = 40; base.health = 20; base.xp = 12; base.color = '#888888';
                    base.attackRange = 150; base.attackSpeed = 2.5; base.projectileSpeed = 125; base.projectileSize = 5; base.projectileColor = '#00FFFF';
                    break;
                case 'car':
                    base.size = 50; base.speed = 70; base.health = 300; base.damage = 25 * 0.8; base.xp = 75; base.color = '#663300'; // Reduced damage by 20%
                    // Cars don't shoot by default
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'ninja':
                    base.size = 22; base.speed = 80; base.health = 60; base.damage = 15; base.xp = 30; base.color = '#333333';
                    // Ninjas don't shoot by default
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'enemyDog':
                    base.size = 20; base.speed = 60; base.health = 35; base.damage = 12; base.xp = 18; base.color = '#A0522D'; // Sienna
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; // Melee
                    break;
                case 'enemyDrone':
                    base.size = 15; base.speed = 45; base.health = 25; base.damage = 0; base.xp = 15; base.color = '#4682B4'; // SteelBlue
                    base.attackRange = 200; base.attackSpeed = 1.5; base.projectileSpeed = 110; base.projectileSize = 6; base.projectileColor = '#ADD8E6'; // LightBlue
                    break;
                case 'cobra':
                    base.size = 25; base.speed = 40; base.health = 70; base.damage = 15; base.xp = 25; base.color = '#228B22'; // ForestGreen
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; // Melee
                    break;
                case 'robotDrone': // New robot drone
                    base.size = 18; base.speed = 70; base.health = 20; base.damage = 25; base.xp = 15; base.color = '#808080'; // Grey
                    base.explosionRadius = 70; // Radius of explosion damage
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; // No projectiles, explodes on contact
                    break;
                case 'yellowSkull': // New yellow skull enemy
                    base.size = 35; // Slightly larger
                    base.speed = 10; // Slower than tank (tank is 15)
                    base.health = 400; // Double the base health of tank (200 * 2)
                    base.damage = 15; // Standard melee damage
                    base.xp = 100; // High XP
                    base.color = '#FFFF00'; // Yellow
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; // Melee
                    break;
                default: // basic enemy
                    base.color = '#777777';
                    // Basic enemies don't shoot by default
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
            }
            
            // Smoother difficulty scaling
            const healthScale = 1 + Math.pow(survivalTime / 60, 0.5); 
            const damageScale = 1 + Math.pow(survivalTime / 90, 0.4); 
            let speedScale = 1 + Math.min(survivalTime / 180, 1.5); 

            // Increase enemy speed by 15% after 2 minutes
            if (survivalTime >= 120) { // 2 minutes = 120 seconds
                speedScale *= 1.15;
            }

            base.health *= healthScale;
            base.damage *= damageScale;
            base.speed *= speedScale;
            // XP gain reduced by 50% (0.5 multiplier)
            base.xp = Math.floor(base.xp * ((healthScale + damageScale) / 2) * 0.5); 

            if (type === 'gunner' || type === 'fast' || type === 'drone' || type === 'enemyDrone') { 
                base.projectileDamage *= damageScale;
                base.attackSpeed *= (1 + Math.min(survivalTime / 180, 1));
            }

            // Reduce health of basic enemies by 25% for the first minute
            if (type === 'basic' && survivalTime < 60) {
                base.health *= 0.75; // 25% reduction
            }

            return base;
        }

        function createControlledEnemy(x, y, enemyType) {
            const baseStats = getEnemyStats(enemyType || 'basic'); // Use original enemy type or basic
            return {
                x: x, y: y, type: enemyType || 'basic', controlled: true,
                size: baseStats.size, speed: baseStats.speed * 1.5,
                health: baseStats.health * 2, damage: baseStats.damage * 2,
                color: baseStats.color, // Allied characters keep their original color for pixel art
                vx: 0, 
                vy: 0, 
                animationFrame: 0, // Initialize animation frame for controlled enemies
                originalType: enemyType, // Store original type to revert
                stuckTimer: 0, // Initialize stuck timer
                ghostModeActive: false, // Initialize ghost mode flag
                ghostModeTimer: 0, // Initialize ghost mode timer
                lastX: x, // For stuck detection
                lastY: y, // For stuck detection
            };
        }

        function explodeRobotDrone(drone) {
            playSound('explosion');
            spawnParticles(drone.x, drone.y, {r: 255, g: 100, b: 0}); // Orange explosion particles

            // Damage player if in radius
            if (dist(player, drone) < (player.size / 2 + drone.explosionRadius)) {
                let damageTaken = drone.damage;
                damageTaken = damageTaken * (1 - player.stats.damageReduction);
                if (ultimateActive) {
                    damageTaken *= 0.5;
                }
                damageTaken = Math.max(0, damageTaken);
                player.health -= damageTaken;
                if (player.health <= 0) {
                    gameOver();
                }
                showDamageNumber(damageTaken, player.x, player.y);
            }

            // Damage other enemies in radius
            enemies.forEach(otherEnemy => {
                if (otherEnemy !== drone && !otherEnemy.controlled && dist(drone, otherEnemy) < (drone.explosionRadius + otherEnemy.size / 2)) {
                    otherEnemy.health -= drone.damage * 0.5; // Half damage to other enemies
                    showDamageNumber(drone.damage * 0.5, otherEnemy.x, otherEnemy.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                    if (otherEnemy.health <= 0) {
                        gainXp(otherEnemy.xp);
                        score += 10;
                        spawnParticles(otherEnemy.x, otherEnemy.y, otherEnemy.color);
                    }
                }
            });
        }
        
        function spawnPowerup(x, y) {
            powerups.push({
                x: x, y: y, size: 10, color: '#ffff00', speed: 300, 
                // XP value increased significantly
                xpValue: Math.floor((50 + Math.floor(Math.random() * 50)) * 2.5) // Increased XP gain by 2.5x
            });
        }

        // Modified spawnChest function to accept coordinates
        function spawnChestAtLocation(x, y) {
            chests.push({
                x: x, y: y, size: 30, type: 'chest'
            });
        }

        function activateTemporaryPowerup() {
            // If a temporary power-up is already active, deactivate it first
            if (temporaryPowerupActive) {
                deactivateTemporaryPowerup();
            }

            // Removed 'extremeBulletTime' from powerupChoices
            const powerupChoices = ['spreadGun', 'friendlyDog', 'enemyConversion']; 
            const chosenPowerup = powerupChoices[Math.floor(Math.random() * powerupChoices.length)];

            temporaryPowerupType = chosenPowerup;
            temporaryPowerupDuration = 10; // All temporary power-ups now last 10 seconds

            switch (chosenPowerup) {
                case 'spreadGun':
                    console.log("Spread Gun Activated!");
                    temporaryPowerupActive = true;
                    // Player's multiShot will be handled in updatePlayer
                    break;
                case 'friendlyDog':
                    console.log("Friendly Dog Summoned!");
                    temporaryPowerupActive = true;
                    friendlyDog = {
                        x: player.x,
                        y: player.y,
                        size: 20,
                        speed: player.speed * 1.2, // Dog is slightly faster than player
                        damage: player.stats.damage * 0.5, // Dog deals half player's damage
                    };
                    break;
                case 'enemyConversion':
                    console.log("Enemy Conversion Activated!");
                    temporaryPowerupActive = true; // This power-up now has a duration
                    temporaryPowerupDuration = 10; // Lasts for 10 seconds

                    const nonControlledEnemies = enemies.filter(e => !e.controlled);
                    const enemiesToConvertCount = Math.floor(nonControlledEnemies.length * 0.5); // 50% chance
                    
                    // Shuffle and select enemies to convert
                    const shuffledEnemies = nonControlledEnemies.sort(() => 0.5 - Math.random());
                    convertedEnemies = shuffledEnemies.slice(0, enemiesToConvertCount); // Store converted enemies

                    convertedEnemies.forEach(enemy => {
                        enemy.controlled = true;
                        enemy.color = getEnemyStats(enemy.type).color; // Allied characters keep their original color for pixel art
                        enemy.speed *= 1.5; // Allies are faster
                        enemy.health = getEnemyStats(enemy.type).health; // Heal them to full health
                        enemy.damage *= 2; // Allies deal more damage
                    });
                    break;
            }
        }

        function deactivateTemporaryPowerup() {
            if (!temporaryPowerupActive) return;

            switch (temporaryPowerupType) {
                case 'spreadGun':
                    console.log("Spread Gun Deactivated!");
                    // No direct change needed as updatePlayer handles default multiShot
                    break;
                case 'friendlyDog':
                    console.log("Friendly Dog Deactivated!");
                    friendlyDog = null; // Remove the dog
                    break;
                case 'enemyConversion':
                    console.log("Enemy Conversion Deactivated!");
                    // Revert converted enemies back to hostile
                    convertedEnemies.forEach(enemy => {
                        enemy.controlled = false;
                        // Revert their stats to original enemy stats (or a scaled version)
                        const originalStats = getEnemyStats(enemy.originalType || 'basic');
                        enemy.speed = originalStats.speed;
                        enemy.health = originalStats.health;
                        enemy.damage = originalStats.damage;
                        enemy.color = originalStats.color;
                    });
                    convertedEnemies = []; // Clear the list of converted enemies
                    break;
            }
            temporaryPowerupActive = false;
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
        }
        
        function gainXp(amount) {
            player.xp += amount;
        }
        
        function levelUp() {
            while (player.xp >= player.nextLevelXp) { // Keep leveling up as long as XP is sufficient
                player.level++;
                player.xp -= player.nextLevelXp; // Deduct only the XP for the current level
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.8); // Increase next level XP
                player.maxHealth += 10;
                player.health = Math.min(player.health + 10, player.maxHealth);
                playSound('levelUp');
                // Show power selection for EACH level gained
                showPowerSelection(); 
                // The game loop will pause here until a power-up is selected
                // The selectPower function will then resume the game loop
                return; // Exit after showing one power selection, so the loop can continue only after selection
            }
        }
        
        function showPowerSelection() {
            gameRunning = false;
            isPaused = true; // Pause game when level up
            Tone.Transport.stop(Tone.now()); // Stop music
            messageBox.style.display = 'block';
            powerSelectionDiv.innerHTML = '';
        
            const availablePowers = POWER_OPTIONS.filter(p => player.upgrades[p.id] < MAX_UPGRADE_LEVEL);
            const selectedPowers = [];
        
            const existingUpgrades = availablePowers.filter(p => player.upgrades[p.id] > 0);
            const newUpgrades = availablePowers.filter(p => player.upgrades[p.id] === 0);

            for (let i = 0; i < Math.min(2, existingUpgrades.length); i++) {
                const randomIndex = Math.floor(Math.random() * existingUpgrades.length);
                selectedPowers.push(existingUpgrades[randomIndex]);
                existingUpgrades.splice(randomIndex, 1);
            }

            while(selectedPowers.length < 3 && newUpgrades.length > 0) {
                const randomIndex = Math.floor(Math.random() * newUpgrades.length);
                selectedPowers.push(newUpgrades[randomIndex]);
                newUpgrades.splice(randomIndex, 1);
            }
            
            while(selectedPowers.length < 3 && availablePowers.length > 0) {
                const randomIndex = Math.floor(Math.random() * availablePowers.length);
                selectedPowers.push(availablePowers[randomIndex]);
                availablePowers.splice(randomIndex, 1);
            }

            selectedPowers.forEach(power => {
                const card = document.createElement('div');
                card.className = 'power-card';
                card.innerHTML = `
                    <h4>${power.name} <span>Lvl ${power.level() + 1}</span></h4>
                    <p>${power.next()}</p>
                `;
                card.addEventListener('click', () => selectPower(power));
                powerSelectionDiv.appendChild(card);
            });
        }
        
        function selectPower(power) {
            power.effect();
            player.upgrades[power.id]++;
            messageBox.style.display = 'none';
            isPaused = false; // Unpause game after selection
            gameRunning = true;
            if (!isMusicMuted) Tone.Transport.start(Tone.now()); // Resume music if not muted
            lastTime = performance.now(); 
            requestAnimationFrame(gameLoop); // Request next frame to continue game loop
        }

        function resetGame() {
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            powerups.length = 0;
            damageNumbers.length = 0;
            particles = []; // Clear particles
            spinningKnives = []; 
            chests = []; // Reset chests
            friendlyDog = null; // Reset friendly dog
            drones = []; // Reset drones
            boomerangs = []; // Reset boomerangs
            convertedEnemies = []; // Clear converted enemies
            
            survivalTime = 0;
            shootTimer = 0;
            spawnTimer = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; // Reset random chest spawn timer
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; // Reset player speed modifier
            projectileSpeedModifier = 1; // Reset projectile speed modifier
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; 
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
            lastUziSoundTime = 0;


            updateMusicPatterns(currentMusicPatternIndex);
        }

        function handleRetry() {
            startGame();
        }

        function updateCamera() {
            // Center camera on player, but clamp to world boundaries
            camera.x = player.x - (camera.width / camera.zoom) / 2;
            camera.y = player.y - (camera.height / camera.zoom) / 2;

            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(camera.x, gameWorld.width - (camera.width / camera.zoom)));
            camera.y = Math.max(0, Math.min(camera.y, gameWorld.height - (camera.height / camera.zoom)));
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused || isMenuOpen) return; // Stop loop if paused or menu is open
        
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            survivalTime += deltaTime;
        
            update(deltaTime);
            draw();
        
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; // Apply game speed multiplier

            shootTimer += effectiveDt;
            spawnTimer += effectiveDt;
            musicPatternTimer += effectiveDt;
            randomChestSpawnTimer += effectiveDt; // Update random chest spawn timer

            // Check for random chest spawn
            if (randomChestSpawnTimer >= RANDOM_CHEST_SPAWN_INTERVAL) {
                if (Math.random() < RANDOM_CHEST_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnChestAtLocation(x, y);
                }
                randomChestSpawnTimer = 0;
            }

            if (musicPatternTimer >= MUSIC_PATTERN_CHANGE_INTERVAL) {
                musicPatternTimer = 0;
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * BACKGROUND_MUSIC_PATTERNS.length);
                } while (newIndex === currentMusicPatternIndex);
                currentMusicPatternIndex = newIndex;
                updateMusicPatterns(currentMusicPatternIndex);
            }

            // Update burstChargeTimer
            if (player.upgrades.burstCharge > 0) {
                player.burstChargeTimer -= effectiveDt;
            }

            if (player.stats.burstDamage > 0) {
                player.burstTimer += effectiveDt;
            }
            if (player.upgrades.shotgun > 0) { // Update shotgun timer
                player.shotgunTimer += effectiveDt;
            }
            if (player.stats.dualUziActive) { // Update dual Uzi timer
                player.dualUziTimer += effectiveDt;
            }
            if (player.stats.boomerangCount > 0) { // Update boomerang timer
                player.boomerangTimer += effectiveDt;
            }

            // Update spinning knives position
            spinningKnives.forEach(knife => {
                knife.angle += knife.rotationSpeed * effectiveDt;
                knife.x = player.x + Math.cos(knife.angle) * knife.radius;
                knife.y = player.y + Math.sin(knife.angle) * knife.radius;
            });

            if (player.xp >= player.nextLevelXp) {
                levelUp();
            }

            if (ultimateActive) {
                ultimateDuration -= effectiveDt;
                if (ultimateDuration <= 0) {
                    ultimateActive = false;
                    player.color = '#6A808C'; // Revert to blue-grey
                    ultimateCharge = 0;
                    // Deactivate Bullet Time effect
                    gameSpeedMultiplier = 1; // Reset speed
                    playerSpeedModifier = 1; // Reset player speed modifier
                    projectileSpeedModifier = 1; // Reset projectile speed modifier
                    if (!isMusicMuted) Tone.Transport.playbackRate = 1; // Reset music speed only if not muted
                }
            } else if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += effectiveDt * 5 * (1 + player.upgrades.ultimateRecharge * 0.2); 
                ultimateCharge = Math.min(ultimateCharge, ultimateMaxCharge);
            }

            // Handle Temporary Power-ups (Spread Gun, Friendly Dog, Enemy Conversion)
            if (temporaryPowerupActive) {
                temporaryPowerupDuration -= dt; // Duration now decreases based on real time
                if (temporaryPowerupDuration <= 0) {
                    deactivateTemporaryPowerup();
                }
            }


            updatePlayer(effectiveDt);
            updateCamera();
            updateEnemies(effectiveDt);
            updateProjectiles(effectiveDt);
            updatePowerups(effectiveDt);
            updateChests(effectiveDt); // Update chests
            updateFriendlyDog(effectiveDt); // Update friendly dog
            updateDrones(effectiveDt); // Update drones
            updateBoomerangs(effectiveDt); // Update boomerangs
            checkCollisions();
            updateDamageNumbers(effectiveDt);
            updateParticles(effectiveDt); // Update particles
        }
        
        async function gameOver() {
            gameRunning = false;
            isPaused = true; // Ensure game is paused on game over
            playSound('gameOver');
            
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); // Pass Tone.now()
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); // Pass Tone.now()
            }
            Tone.Transport.stop(Tone.now()); // Pass Tone.now()

            gameOverMenu.style.display = 'block';
            document.getElementById('final-score').textContent = `Score: ${score}`;
            document.getElementById('final-time').textContent = `Time Survived: ${survivalTime.toFixed(1)}s`;
            document.getElementById('final-level').textContent = `Level Reached: ${player.level}`;

            const currentHighScores = await window.getHighScoresFirebase();
            const isHighScore = currentHighScores.length < 10 || score > Math.min(...currentHighScores.map(s => s.score));

            if (isHighScore) {
                highScoreModal.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                displayHighScores();
            }
        }

        async function saveAndDisplayHighScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                await window.saveHighScoreFirebase(playerName, score, survivalTime.toFixed(1), player.level);
                highScoreModal.style.display = 'none';
                displayHighScores();
            } else {
                console.warn("Please enter a name to save your high score.");
            }
        }

        async function displayHighScores() {
            const highScores = await window.getHighScoresFirebase();
            highScoresList.innerHTML = '';
            
            if (highScores.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No high scores yet. Be the first!';
                highScoresList.appendChild(li);
                return;
            }

            highScores.forEach((s, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${index + 1}. ${s.name}</span>
                    <span>Score: ${s.score} | Time: ${s.survivalTime}s | Lvl: ${s.level}</span>
                `;
                highScoresList.appendChild(li);
            });
        }

        // --- New Pause/Menu/Music Functions ---
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = 'Resume';
                Tone.Transport.stop(Tone.now()); // Stop music when paused
            } else {
                pauseButton.textContent = 'Pause';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); // Resume music if not muted
                lastTime = performance.now(); // Reset lastTime to prevent large deltaTime jump
                requestAnimationFrame(gameLoop); // Restart game loop
            }
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            if (isMenuOpen) {
                gameMenu.style.display = 'block';
                Tone.Transport.stop(Tone.now()); // Stop music when menu is open
            } else {
                gameMenu.style.display = 'none';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); // Resume music if not muted
                lastTime = performance.now(); // Reset lastTime to prevent large deltaTime jump
                requestAnimationFrame(gameLoop); // Restart game loop
            }
        }

        function toggleMusic() {
            isMusicMuted = !isMusicMuted;
            Tone.Destination.mute = isMusicMuted; // Mute/unmute all Tone.js output
            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }
        // --- End New Pause/Menu/Music Functions ---

        // Function to create particles at a given position and color
        function spawnParticles(x, y, colorInput) {
            let r, g, b;

            // Check if colorInput is an object (like {r: 255, g: 100, b: 0})
            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                // Parse enemy color string (e.g., '#777777') to RGB
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                // Default to white if colorInput is neither a string nor a valid object
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); // More particles
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; // Slower initial speed
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, // Smaller particles
                    alpha: 1,
                    color: { r: r, g: g, b: b } // Use the parsed/provided RGB color
                });
            }
        }
        
        function init() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            // Adjust camera width/height based on zoom
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;

            // Initialize mini-map canvas size and scale
            miniMapCanvas.width = miniMapCanvas.clientWidth;
            miniMapCanvas.height = miniMapCanvas.clientHeight;
            miniMapScale = miniMapCanvas.width / gameWorld.width; // Assuming square mini-map and world

            window.addEventListener('resize', () => {
                canvas.width = gameContainer.clientWidth;
                canvas.height = gameContainer.clientHeight;
                camera.width = canvas.width / camera.zoom; // Recalculate based on zoom
                camera.height = canvas.height / camera.zoom; // Recalculate based on zoom

                // Re-initialize mini-map size and scale on resize
                miniMapCanvas.width = miniMapCanvas.clientWidth;
                miniMapCanvas.height = miniMapCanvas.clientHeight;
                miniMapScale = miniMapCanvas.width / gameWorld.width;

                if (!gameRunning) {
                    drawStartMenu();
                }
            });
        
            document.getElementById('startButton').addEventListener('click', () => {
                Tone.start(); 
                setupAudio();
                startGame();
            });
            document.getElementById('restartButton').addEventListener('click', handleRetry);
            saveScoreButton.addEventListener('click', saveAndDisplayHighScore);

            // New event listeners for pause, menu, and music buttons
            pauseButton.addEventListener('click', togglePause);
            menuButton.addEventListener('click', toggleMenu);
            muteMusicButton.addEventListener('click', toggleMusic);
            resumeFromMenuButton.addEventListener('click', toggleMenu); // Resume game from menu

            canvas.addEventListener('mousedown', handlePointerEvent);
            canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
            
            function handlePointerEvent(e) {
                e.preventDefault();
                // Only allow player movement input if game is running and not paused/menu open
                if (!gameRunning || isPaused || isMenuOpen) return; 

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Adjust input coordinates based on camera zoom
                const inputX = (clientX - rect.left) / camera.zoom;
                const inputY = (clientY - rect.top) / camera.zoom;
                
                player.targetX = camera.x + inputX;
                player.targetY = camera.y + inputY;
            }

            ultimateButton.addEventListener('click', () => {
                if (ultimateCharge >= ultimateMaxCharge && !ultimateActive) {
                    activateUltimate();
                }
            });
        
            // Removed 'e' key listener as Burst Charge is now automatic
            // document.addEventListener('keydown', (e) => {
            //     const key = e.key.toLowerCase();
            //     if (keys.hasOwnProperty(key)) {
            //         keys[key] = true;
            //     }
            // });
        
            // document.addEventListener('keyup', (e) => {
            //     const key = e.key.toLowerCase();
            //     if (keys.hasOwnProperty(key)) {
            //         keys[key] = false;
            //     }
            // });

            generateObstacles();
        
            drawStartMenu();

            if (typeof window.initFirebase === 'function') {
                window.initFirebase();
            } else {
                console.error("Firebase initialization function not found.");
            }
        }

        let obstacles = []; // Define obstacles globally

        function generateObstacles() {
            // Clear existing obstacles before generating new ones
            obstacles = []; 

            // Pillars (circular obstacles) - Increased from 10 to 20
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 50, height: 50, color: '#3c3c3c', type: 'pillar'
                });
            }

            // Desks (rectangular obstacles) - Increased from 5 to 10
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 200, height: 50, color: '#4d4d4d', type: 'desk'
                });
            }

            // Chairs (smaller rectangular obstacles) - Increased from 15 to 30
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 30, height: 30, color: '#2d2d2d', type: 'chair'
                });
            }
        }
        
        function startGame() {
            gameRunning = true;
            isPaused = false;
            isMenuOpen = false;
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            player.health = 100;
            player.maxHealth = 100;
            player.xp = 0;
            player.level = 1;
            player.nextLevelXp = 100;
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.targetX = player.x;
            player.targetY = player.y;
            player.vx = 0; 
            player.vy = 0; 

            player.stats = {
                damage: 20, attackSpeed: 10, projectileSpeed: 400, pierce: 0, multiShot: 1, 
                healthRegen: 0.1, magnet: 50, damageReduction: 0, 
                spinningKnivesDamage: 0, spinningKnivesCount: 0, 
                burstDamage: 0, burstProjectileCount: 0,
                droneCount: 0, droneDamage: 0, droneAttackSpeed: 0,
                shotgunPellets: 0, shotgunDamage: 0, shotgunSpread: 0,
                dualUziActive: false, dualUziFireRate: 0, dualUziDamage: 0,
                boomerangDamage: 0, boomerangCount: 0, boomerangCooldown: 4, boomerangRange: 150, boomerangSpeed: 400,
                burstChargeDamage: 0, burstChargeProjectileCount: 0
            };
            player.upgrades = {
                damage: 0, attackSpeed: 0, health: 0, speed: 0, pierce: 0, multiShot: 0, 
                healthRegen: 0, magnet: 0, bulletproofSuit: 0, 
                ultimateRecharge: 0, burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, shotgun: 0, dualUzi: 0,
                boomerang: 0, burstCharge: 0
            };
            player.burstChargeCooldown = 5; // Initial cooldown for burst charge
            player.burstChargeTimer = 0; // Timer for burst charge
            player.burstCooldown = 1;
            player.burstTimer = 0;
            player.shotgunTimer = 0; // Reset shotgun timer
            player.dualUziTimer = 0; // Reset dual Uzi timer
            player.boomerangTimer = 0; // Reset boomerang timer
            player.currentShootAngle = 0; // Reset shoot angle for arms
            ultimateChargePerHit = 0.5; 
            lastShotSoundTime = 0;
            lastEnemyHitSoundTime = 0;
            lastUziSoundTime = 0; // Reset Uzi sound cooldown

            currentMusicPatternIndex = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; // Reset random chest spawn timer
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; 
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            particles = []; // Clear particles
            spinningKnives = []; 
            chests = []; // Clear chests
            friendlyDog = null; // Clear friendly dog
            drones = []; // Clear drones
            boomerangs = []; // Clear boomerangs
            convertedEnemies = []; // Clear converted enemies
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            player.color = '#6A808C'; // Ensure player color is reset to blue-grey
            
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            messageBox.style.display = 'none';
            highScoreModal.style.display = 'none';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden
            
            updateMusicPatterns(currentMusicPatternIndex);
            if (!isMusicMuted) Tone.Transport.start(Tone.now()); // Start music only if not muted
        
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    </script>
</body>
</html>
