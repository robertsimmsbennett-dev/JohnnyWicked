<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Johnny Wicked: Hotel Lobby</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            user-select: none; /* Prevent text selection on touch */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Remove tap highlight on iOS */
            flex-direction: column; /* For better mobile layout */
        }
        
        #gameContainer {
            position: relative;
            width: 900px; /* Base width */
            height: 700px; /* Base height */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;

            /* Responsive adjustments for gameContainer */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 95vh; /* Max height relative to viewport */
            aspect-ratio: 9 / 7; /* Maintain aspect ratio */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Make canvas fill its container */
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
        }
        
        #score-display {
            top: 10px;
            left: 10px;
        }
        
        #menu-button { /* New button styling */
            top: 50px; /* Position below score display */
            left: 10px;
            pointer-events: all;
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: #fff;
            border: none;
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: 'Chakra+Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease;
        }

        #menu-button:hover {
            background: linear-gradient(45deg, #0056b3, #003d7a);
        }

        #time-display {
            top: 10px;
            right: 10px;
        }
        
        #level-display {
            bottom: 10px;
            left: 10px;
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
        }
        
        #power-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .power-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 200px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
        }
        
        .power-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
        .power-card p {
            font-size: 0.9em;
            margin-bottom: 0;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0000;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 11; /* Added z-index to ensure menu is on top */
        }
        
        .menu h1 {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            font-size: 2.5em;
        }
        
        .menu h2 {
            color: #ff0000;
        }
        
.menu button {
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Chakra+Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
        }
        
        .menu button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        #game-menu.menu button { /* Styling for buttons inside the new game menu */
            background: linear-gradient(45deg, #007bff, #0056b3);
            margin: 10px;
            padding: 10px 20px;
            font-size: 1em;
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #game-menu.menu button:hover {
            background: linear-gradient(45deg, #0056b3, #003d7a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            width: 80%;
            max-width: 250px;
            font-family: 'Chakra+Petch', monospace;
            font-size: 1em;
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra+Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        #high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #high-scores-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #high-scores-list li:last-child {
            border-bottom: none;
        }
        #high-scores-list li span {
            color: #00ffff;
            font-weight: bold;
        }

        #pause-button {
            position: absolute;
            top: 40px; /* Position below time display */
            right: 10px;
            pointer-events: all;
            background: linear-gradient(45deg, #555, #333);
            color: #d1d1d1;
            border: none;
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: 'Chakra+Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease;
        }

        #pause-button:hover {
            background: linear-gradient(45deg, #666, #444);
        }

        /* New Modals for How to Play and Power Ups */
        .info-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: left; /* Changed to left for content */
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none;
            pointer-events: all;
            max-width: 600px; /* Max width for readability */
            max-height: 80vh; /* Max height for scrollability */
            overflow-y: auto; /* Enable scrolling */
        }

        .info-menu h2 {
            color: #00ffff;
            text-align: center;
            margin-top: 0;
        }

        .info-menu h3 {
            color: #00ccff;
            margin-top: 20px;
            margin-bottom: 5px;
        }

        .info-menu p, .info-menu ul {
            font-size: 0.95em;
            line-height: 1.5;
            color: #d1d1d1;
            margin-bottom: 10px;
        }

        .info-menu ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        .info-menu li {
            margin-bottom: 5px;
        }

        .info-menu button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra+Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 20px;
            display: block; /* Make button block level */
            margin-left: auto; /* Center button */
            margin-right: auto; /* Center button */
        }

        .info-menu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 123, 255, 0.4);
        }

        .power-up-item {
            border: 1px solid #0056b3;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .power-up-item h4 {
            color: #00ccff;
            margin: 0 0 5px 0;
        }

        .power-up-item p {
            margin: 0;
        }
        
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="score-display" class="hud-item">Score: 0</div>
            <button id="menu-button" class="hud-item">Menu</button>
            <button id="pause-button" class="hud-item">Pause</button>
            <div id="time-display" class="hud-item">Time: 0s</div>
            <div id="level-display" class="hud-item">Level: 1</div>
            <div id="xp-bar-container"><div id="xp-bar"></div></div>
            <div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="menu">
            <h1>Johnny Wicked</h1>
            <h2>Hotel Lobby</h2>
            <button id="startButton">Start Game</button>
            <br>
            <button id="howToPlayButton">How to Play</button>
            <button id="highScoresButton">High Scores</button>
        </div>

        <!-- How to Play Menu -->
        <div id="howToPlayMenu" class="info-menu">
            <h2>How to Play</h2>
            <h3>Objective</h3>
            <p>Survive as long as you can against endless waves of enemies. Collect XP to level up and unlock powerful upgrades. The longer you survive, the more challenging the game becomes!</p>
            <h3>Controls</h3>
            <ul>
                <li><strong>Movement:</strong> Use WASD or the Arrow Keys.</li>
                <li><strong>Aim & Shoot:</strong> Aim with the mouse and click to shoot. Your character will automatically shoot at the cursor.</li>
                <li><strong>Menu:</strong> Press 'M' or click the "Menu" button to pause the game and access the menu.</li>
                <li><strong>Pause:</strong> Press 'P' or click the "Pause" button to pause the game.</li>
            </ul>
            <h3>Gameplay</h3>
            <ul>
                <li><strong>Upgrades:</strong> When you level up, you will be presented with a choice of three random upgrades. Choose wisely to build a powerful character!</li>
                <li><strong>Health:</strong> The red bar below your character's name is your health. Take too much damage, and it's game over!</li>
                <li><strong>XP:</strong> The blue bar is your experience. Fill it up by defeating enemies to level up.</li>
                <li><strong>Ultimate:</strong> The orange bar is your ultimate ability. It charges over time. When full, click the ultimate button to activate a powerful effect.</li>
            </ul>
            <button id="closeHowToPlayButton">Close</button>
        </div>

        <!-- Power Ups Menu -->
        <div id="powerUpsMenu" class="info-menu">
            <h2>Power Ups</h2>
            <p>Here you can see descriptions of all the available power-ups in the game.</p>
            <div id="power-ups-list"></div>
            <button id="closePowerUpsButton">Close</button>
        </div>

        <!-- Game Over Menu -->
        <div id="gameOverMenu" class="menu" style="display: none;">
            <h1>Game Over</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Survival Time: <span id="finalTime">0s</span></p>
            <button id="restartButton">Restart Game</button>
        </div>

        <!-- Level Up Message Box -->
        <div id="message-box">
            <h2>Level Up!</h2>
            <p>Select a power-up:</p>
            <div id="power-selection"></div>
        </div>

        <!-- High Score Modal -->
        <div id="high-score-modal">
            <h2>High Scores</h2>
            <p>Enter your initials:</p>
            <input type="text" id="initials-input" maxlength="3" placeholder="AAA">
            <button id="save-score-button">Save Score</button>
            <ul id="high-scores-list"></ul>
            <button id="close-high-score-modal-button">Close</button>
        </div>

        <!-- Ultimate Button -->
        <button id="ultimate-button">ULTIMATE READY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        // Use this for firebase initialization.
        const firebaseConfig = {
        // We're not using Firebase in this example.
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('startMenu');
        const startButton = document.getElementById('startButton');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const restartButton = document.getElementById('restartButton');
        const finalScoreSpan = document.getElementById('finalScore');
        const finalTimeSpan = document.getElementById('finalTime');
        const messageBox = document.getElementById('message-box');
        const powerSelection = document.getElementById('power-selection');
        const menuButton = document.getElementById('menu-button');
        const gameMenu = document.getElementById('game-menu');
        const resumeButton = document.getElementById('resume-button');
        const howToPlayButton = document.getElementById('howToPlayButton');
        const howToPlayMenu = document.getElementById('howToPlayMenu');
        const closeHowToPlayButton = document.getElementById('closeHowToPlayButton');
        const powerUpsButton = document.getElementById('powerUpsButton');
        const powerUpsMenu = document.getElementById('powerUpsMenu');
        const powerUpsListDiv = document.getElementById('power-ups-list');
        const closePowerUpsButton = document.getElementById('closePowerUpsButton');
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoresButton = document.getElementById('highScoresButton');
        const highScoreModal = document.getElementById('high-score-modal');
        const initialsInput = document.getElementById('initials-input');
        const saveScoreButton = document.getElementById('save-score-button');
        const highScoresList = document.getElementById('high-scores-list');
        const closeHighScoreModalButton = document.getElementById('close-high-score-modal-button');
        const pauseButton = document.getElementById('pause-button');
        
        // Game state variables
        let gameRunning = false;
        let wasGameRunningBeforeMenu = false; // New: Flag to store game state before menu opens
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let gameWorld = { width: 2000, height: 2000 };
        let gameSpeedMultiplier = 1; // Global speed multiplier for Bullet Time
        let playerSpeedModifier = 1; // Multiplier for player speed during bullet time
        let projectileSpeedModifier = 1; // Multiplier for player projectiles during bullet time
        let bulletTimeActive = false; // This variable is no longer directly used for effect application, but kept for clarity if needed.
        let bulletTimeDuration = 0; // This variable is no longer directly used for effect application, but kept for clarity if needed.
        let spinningKnives = []; // Array for spinning knives
        let drones = []; // Array for friendly drones
        let explosions = []; // New array for explosions
        let electricArcs = []; // For drawing electric arcs
        let shieldDrones = []; // Array for shield drones
        // New: Object to manage active temporary power-ups and their end times
        let activeTemporaryEffects = {};
        let chestSpawnTimer = 0;
        const CHEST_SPAWN_INTERVAL = 15; // Chest spawns every 15 seconds
        let chests = []; // Array for chests

        // Camera for a larger game world
        let camera = { x: 0, y: 0, width: 900, height: 700 };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#d1d1d1',
            speed: 300,
            health: 100,
            maxHealth: 100,
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10,
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 50,
                defense: 0,
                uziDamage: 0, // Renamed from waveDamage
                uziProjectileSpeed: 0, // New Uzi stat
                uziNumProjectiles: 0, // New Uzi stat
                uziSpiralFactor: 0, // New Uzi stat
                uziSpiralRadius: 0,
                spinningKnivesDamage: 0,
                spinningKnivesCount: 0,
                burstDamage: 0,
                burstProjectileCount: 0,
                bazookaDamage: 0, // New: Bazooka damage
                bazookaRadius: 0, // New: Bazooka explosion radius
                shotgunProjectiles: 0, // New: Shotgun projectile count
                shotgunSpread: 0, // New: Shotgun spread angle
                friendlyDrones: 0, // New: Number of friendly drones
                droneAttackSpeed: 0, // New: Friendly drone attack speed
                droneDamage: 0, // New: Friendly drone damage
                droneShield: 0,
                critChance: 0,
                critDamage: 0,
                poisonChance: 0,
                poisonDamage: 0,
                poisonDuration: 0,
                slowChance: 0,
                slowDuration: 0,
                electrocuteChance: 0, // New: Electrocute chance
                electrocuteDamage: 0, // New: Electrocute damage
                electrocuteDuration: 0, // New: Electrocute duration
                ricochet: 0, // New: Ricochet count
                laser: 0, // New: Laser damage (0 or >0)
                homing: 0, // New: Homing projectiles (0 or >0)
                bulletTimeEffect: 0, // New: Bullet time power-up
                magnetism: 0, // New: Magnetism power-up
                ultimateCooldownReduction: 0,
                coinDropMultiplier: 1, // New: Coin drop multiplier
                xpBonus: 0, // New: XP bonus multiplier
            },
            guns: {
                pistol: {
                    damage: 20,
                    fireRate: 500, // in ms
                    lastShot: 0
                },
                shotgun: {
                    damage: 15,
                    fireRate: 800,
                    lastShot: 0
                },
                uzi: { // New Uzi gun type
                    damage: 10,
                    fireRate: 50, // Rapid fire
                    lastShot: 0
                },
            },
            activeGun: 'pistol',
            uziAngle: 0,
        };

        // Weapon definitions, including the new Uzi
        const weaponDefinitions = {
            pistol: {
                damage: () => player.stats.damage,
                fireRate: () => 500 / player.stats.attackSpeed,
                shoot: (p, mouseX, mouseY) => {
                    const angle = Math.atan2(mouseY - camera.y - p.y, mouseX - camera.x - p.x);
                    const speed = player.stats.projectileSpeed;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    projectiles.push({
                        x: p.x,
                        y: p.y,
                        vx,
                        vy,
                        size: 8,
                        damage: weaponDefinitions.pistol.damage(),
                        pierce: player.stats.pierce,
                        ricochet: player.stats.ricochet,
                        type: 'standard',
                        color: '#d1d1d1'
                    });
                }
            },
            uzi: {
                damage: () => player.stats.uziDamage || 10, // Default damage
                fireRate: () => 50 / (player.stats.attackSpeed + player.stats.uziNumProjectiles),
                shoot: (p, mouseX, mouseY) => {
                    // Get the position and angle for the spiraling Uzi
                    const spiralRadius = player.stats.uziSpiralRadius || 30;
                    const spiralAngle = player.uziAngle;
                    
                    const bulletStartX = p.x + spiralRadius * Math.cos(spiralAngle);
                    const bulletStartY = p.y + spiralRadius * Math.sin(spiralAngle);
                    
                    // The bullets are fired in the direction of the spiral
                    const angle = spiralAngle;
                    const speed = (player.stats.uziProjectileSpeed || 400) * gameSpeedMultiplier;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    projectiles.push({
                        x: bulletStartX,
                        y: bulletStartY,
                        vx,
                        vy,
                        size: 5,
                        damage: weaponDefinitions.uzi.damage(),
                        pierce: player.stats.pierce,
                        ricochet: player.stats.ricochet,
                        type: 'uzi',
                        color: '#eab308',
                        lifetime: 1 // Uzi bullets disappear quickly
                    });
                }
            }
        };

        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let powerups = [];
        let obstacles = [];
        let mouseX = 0;
        let mouseY = 0;
        let lastWaveTime = 0;
        let keys = {};
        
        // Audio setup (using Tone.js)
        let playerSynth, enemyHitSynth, levelUpSynth, ultimateSynth, gameOverSynth, explosionSound;
        let nextPlayerShotTime = 0;
        let nextEnemyHitTime = 0;

        function playSound(soundType) {
            const currentTime = Tone.now();
            switch (soundType) {
                case 'playerShot':
                    // Make sure sounds are not scheduled too close to each other. We use a small debounce period.
                    // The sound should be scheduled at least Tone.now(), and also at least the previously scheduled nextPlayerShotTime
                    const playerShotStartTime = Math.max(currentTime, nextPlayerShotTime);
                    if (playerSynth) {
                        playerSynth.triggerAttackRelease("C4", "8n", playerShotStartTime);
                    }
                    // Schedule the *next* sound after a debounce period from its actual start time
                    nextPlayerShotTime = playerShotStartTime + 0.15;
                    break;
                case 'enemyHit':
                    const enemyHitStartTime = Math.max(currentTime, nextEnemyHitTime);
                    if (enemyHitSynth) {
                        enemyHitSynth.triggerAttackRelease("16n", enemyHitStartTime);
                    }
                    nextEnemyHitTime = enemyHitStartTime + 0.005; // Small offset
                    break;
                case 'levelUp':
                    if (levelUpSynth) levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    if (ultimateSynth) ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    if (gameOverSynth) gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    if (explosionSound) explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5 }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.4, release: 0.2 },
                harmonicity: 5.1,
                modulationIndex: 32,
                resonance: 4000,
                octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;
        }

        // Add event listeners for mouse and keyboard
        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 0 && gameRunning) {
                // If the player has the uzi, we don't need a single shot, it's handled by the automatic fire.
                if (player.activeGun !== 'uzi') {
                    shootProjectile();
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                // Future use for weapons that stop firing on mouse up
            }
        });

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            // Activate ultimate with 'E'
            if (e.key === 'e' || e.key === 'E' || e.key === ' ' && ultimateButton.classList.contains('ready')) {
                activateUltimate();
            }
            // Open/close menu with 'M'
            if (e.key === 'm' || e.key === 'M') {
                toggleGameMenu();
            }
            // Pause/unpause with 'P'
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            delete keys[e.key];
        });

        // Event listeners for UI buttons
        startButton.addEventListener('click', () => {
            // Tone.js needs to be started on a user action
            Tone.start();
            init();
        });
        restartButton.addEventListener('click', init);
        menuButton.addEventListener('click', toggleGameMenu);
        pauseButton.addEventListener('click', togglePause);
        ultimateButton.addEventListener('click', activateUltimate);
        howToPlayButton.addEventListener('click', () => {
            startMenu.style.display = 'none';
            howToPlayMenu.style.display = 'block';
        });
        closeHowToPlayButton.addEventListener('click', () => {
            howToPlayMenu.style.display = 'none';
            startMenu.style.display = 'block';
        });
        highScoresButton.addEventListener('click', () => {
            startMenu.style.display = 'none';
            showHighScoresModal();
        });
        closeHighScoreModalButton.addEventListener('click', () => {
            highScoreModal.style.display = 'none';
            startMenu.style.display = 'block';
        });
        saveScoreButton.addEventListener('click', saveHighScore);
        
        // This function will be called whenever the user resizes the window
        window.addEventListener('resize', resizeCanvas);

        function resizeCanvas() {
            // Get the container dimensions
            const containerWidth = gameContainer.offsetWidth;
            const containerHeight = gameContainer.offsetHeight;

            // Set the canvas to fill the container
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            
            // Update camera dimensions
            camera.width = containerWidth;
            camera.height = containerHeight;
        }

        // Call resizeCanvas initially to set the size
        resizeCanvas();

        function init() {
            // Reset all game state variables
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.health = player.maxHealth;
            player.xp = 0;
            player.level = 1;
            player.stats = {
                damage: 20,
                attackSpeed: 10,
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 50,
                defense: 0,
                uziDamage: 0, // Renamed from waveDamage
                uziProjectileSpeed: 0, // New Uzi stat
                uziNumProjectiles: 0, // New Uzi stat
                uziSpiralFactor: 0, // New Uzi stat
                uziSpiralRadius: 0,
                spinningKnivesDamage: 0,
                spinningKnivesCount: 0,
                burstDamage: 0,
                burstProjectileCount: 0,
                bazookaDamage: 0, // New: Bazooka damage
                bazookaRadius: 0, // New: Bazooka explosion radius
                shotgunProjectiles: 0, // New: Shotgun projectile count
                shotgunSpread: 0, // New: Shotgun spread angle
                friendlyDrones: 0, // New: Number of friendly drones
                droneAttackSpeed: 0, // New: Friendly drone attack speed
                droneDamage: 0, // New: Friendly drone damage
                droneShield: 0,
                critChance: 0,
                critDamage: 0,
                poisonChance: 0,
                poisonDamage: 0,
                poisonDuration: 0,
                slowChance: 0,
                slowDuration: 0,
                electrocuteChance: 0, // New: Electrocute chance
                electrocuteDamage: 0, // New: Electrocute damage
                electrocuteDuration: 0, // New: Electrocute duration
                ricochet: 0, // New: Ricochet count
                laser: 0, // New: Laser damage (0 or >0)
                homing: 0, // New: Homing projectiles (0 or >0)
                bulletTimeEffect: 0, // New: Bullet time power-up
                magnetism: 0, // New: Magnetism power-up
                ultimateCooldownReduction: 0,
                coinDropMultiplier: 1,
                xpBonus: 0,
            };
            player.activeGun = 'pistol';
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            gameRunning = true;
            gameSpeedMultiplier = 1;
            playerSpeedModifier = 1;
            projectileSpeedModifier = 1;
            bulletTimeActive = false;
            bulletTimeDuration = 0;
            activeTemporaryEffects = {}; // Reset active temporary effects
            chestSpawnTimer = 0;


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            spinningKnives = []; 
            chests = []; // Clear chests
            drones = []; // Clear friendly drones
            explosions = []; // Clear explosions
            electricArcs = []; // Clear electric arcs
            shieldDrones = []; // Clear shield drones
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            messageBox.style.display = 'none';
            highScoreModal.style.display = 'none';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden at start
            howToPlayMenu.style.display = 'none'; // Ensure how to play menu is hidden at start
            powerUpsMenu.style.display = 'none'; // Ensure power ups menu is hidden at start
            pauseButton.textContent = "Pause"; // Ensure pause button text is "Pause" at start
            ultimateButton.classList.remove('ready'); // Ensure ultimate button is not ready

            resizeCanvas(); // Make sure canvas is correctly sized on init
            requestAnimationFrame(gameLoop);
        }

        // Placeholder for power-up definitions
        const powerUps = [
            {
                name: "Uzi Spiral",
                description: "Your uzi now fires bullets in a spiral around you.",
                effect: () => {
                    player.activeGun = 'uzi';
                    player.stats.uziSpiralFactor = 1; // Activate spiral effect
                    player.stats.uziSpiralRadius = 30; // Set a base spiral radius
                    player.stats.uziNumProjectiles += 1; // Increase number of projectiles
                    player.stats.uziDamage += 5; // Increase damage
                }
            },
            {
                name: "Uzi Damage Up",
                description: "Increases the damage of your Uzi projectiles.",
                effect: () => {
                    player.stats.uziDamage += 10;
                }
            },
            {
                name: "Uzi Spiral Speed Up",
                description: "Increases the speed of your Uzi spiral.",
                effect: () => {
                    player.stats.uziSpiralFactor += 0.01;
                }
            },
            // ... other power-ups ...
        ];

        // Main game loop function
        function gameLoop(time) {
            if (!gameRunning) return;

            const now = performance.now();
            deltaTime = (now - lastTime) / 1000 * gameSpeedMultiplier; // Time in seconds, scaled by game speed
            lastTime = now;

            // Player logic
            handlePlayerMovement();
            updateUltimateCharge(deltaTime);
            handleShooting();
            
            // Enemy logic
            spawnEnemies();
            updateEnemies();
            checkCollisions();

            // Projectile logic
            updateProjectiles();
            updateEnemyProjectiles();

            // Power-up logic
            updatePowerups();
            updateChests();

            // Other game object logic
            updateSpinningKnives();
            updateDrones();
            updateExplosions();
            updateElectricArcs();
            updateShieldDrones();
            updateActiveEffects(deltaTime);

            // Level up logic
            checkLevelUp();

            // Update UI
            updateUI();

            // Camera follow player
            updateCamera();

            // Drawing
            draw();

            requestAnimationFrame(gameLoop);
        }

        function handlePlayerMovement() {
            let dx = 0;
            let dy = 0;
            const speed = player.speed * playerSpeedModifier;

            if (keys['w'] || keys['W'] || keys['ArrowUp']) dy -= 1;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) dy += 1;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) dx -= 1;
            if (keys['d'] || keys['D'] || keys['ArrowRight']) dx += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
            }

            player.x += dx * speed * deltaTime;
            player.y += dy * speed * deltaTime;
            
            // Keep player within world bounds
            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
        }

        function handleShooting() {
            if (player.activeGun === 'uzi') {
                const fireRate = weaponDefinitions.uzi.fireRate();
                if (performance.now() > player.guns.uzi.lastShot + fireRate) {
                    weaponDefinitions.uzi.shoot(player, mouseX + camera.x, mouseY + camera.y);
                    player.guns.uzi.lastShot = performance.now();
                }
                // Update the Uzi's spiral angle continuously
                player.uziAngle += (player.stats.uziSpiralFactor || 0) * 0.1;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); // Draw chests
            drawEnemies();
            drawPlayer();
            // --- DRAW THE SPIRALING UZI GUN ---
            if (player.activeGun === 'uzi') {
                const spiralRadius = player.stats.uziSpiralRadius || 30;
                const gunX = player.x + spiralRadius * Math.cos(player.uziAngle) - camera.x;
                const gunY = player.y + spiralRadius * Math.sin(player.uziAngle) - camera.y;

                ctx.fillStyle = '#eab308'; // Uzi gun color
                ctx.beginPath();
                ctx.arc(gunX, gunY, player.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            // --- END OF UZI DRAWING ---
            drawSpinningKnives(); // Draw spinning knives
            drawDrones(); // Draw friendly drones
            drawExplosions(); // Draw explosions
            drawElectricArcs(); // Draw electric arcs
            drawShieldDrones(); // Draw shield drones
            if (ultimateActive) {
                drawUltimateEffect();
            }
            drawUI();
            drawDamageNumbers();
        }

        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                let currentSize = p.size;
                let currentColor = p.color;

                if (p.isShotgun) {
                    const opacity = p.lifetime / 0.3; // 0.3 is the max lifetime for shotgun
                    currentSize = p.size * (0.5 + 0.5 * opacity); // Size shrinks as it fades
                    currentColor = `rgba(255, 255, 255, ${opacity})`; // White with fading opacity
                } else if (p.isLaser) {
                    // Laser is drawn as a rectangle
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(screenX - p.size / 2, screenY - p.width / 2, p.size, p.width);
                    return; // Skip default circle draw
                } else if (p.isHoming) {
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Draw a small triangle for direction
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.moveTo(currentSize, 0);
                    ctx.lineTo(-currentSize, -currentSize / 2);
                    ctx.lineTo(-currentSize, currentSize / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    return; // Skip default circle draw
                } else if (p.type === 'uzi') {
                    // Uzi projectiles are smaller and have a different color
                    currentColor = '#eab308';
                    currentSize = 5;
                }

                ctx.fillStyle = currentColor;
                ctx.beginPath();
                ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                ctx.fill();
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // The rest of the functions are unchanged from the original code.
        function drawBackground() {
            ctx.fillStyle = '#101010';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const patternSize = 50;
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 1;
            const startX = -camera.x % patternSize;
            const startY = -camera.y % patternSize;
            for (let x = startX; x < camera.width; x += patternSize) {
                for (let y = startY; y < camera.height; y += patternSize) {
                    ctx.beginPath();
                    ctx.rect(x, y, patternSize, patternSize);
                    ctx.stroke();
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar') {
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair') {
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                }
            });
        }

        function drawPixelArt(ctx, x, y, spriteName, frame, size) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;
            if (spriteName === 'player') {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
                ctx.fillStyle = '#c79b69';
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);
                if (player.isMoving) {
                    const legOffset = Math.sin(player.animationFrame) * s/2;
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s);
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s);
                } else {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s);
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s);
                }
            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;
            const enemyColor = enemy.controlled ? '#00ff66' : enemy.color;
            ctx.fillStyle = '#c79b69';
            ctx.fillRect(screenX - s/4, screenY - s/2 - s/4, s/2, s/2);
            ctx.fillStyle = enemyColor;
            ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
            ctx.fillStyle = enemyColor;
            ctx.fillRect(screenX - s/2, screenY + s, s/2, s);
            ctx.fillRect(screenX, screenY + s, s/2, s);
            if (enemy.type === 'tank') {
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
            } else if (enemy.type === 'gunner') {
                ctx.fillStyle = '#444444';
                ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
            } else if (enemy.type === 'elite') {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                ctx.stroke();
            } else if (enemy.type === 'car') {
                ctx.fillStyle = '#663300'; // Brown for car body
                ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                ctx.fillStyle = '#000000'; // Black for wheels
                ctx.beginPath();
                ctx.arc(screenX - s/2 + s/8, screenY + s/4, s/8, 0, Math.PI * 2);
                ctx.arc(screenX + s/2 - s/8, screenY + s/4, s/8, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'ninja') {
                ctx.fillStyle = '#333333'; // Dark grey for ninja suit
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                ctx.fillStyle = '#1a1a1a'; // Mask
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
            } else if (enemy.type === 'drone') {
                ctx.fillStyle = '#888888'; // Grey for drone body
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#555555'; // Darker grey for propellers
                ctx.fillRect(screenX - s * 0.7, screenY - s * 0.1, s * 1.4, s * 0.2);
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.7, s * 0.2, s * 1.4);
            } else if (enemy.type === 'snake') {
                const segmentWidth = s * 0.8;
                const segmentHeight = s * 0.4;
                const segmentOverlap = s * 0.2;
                for (let i = 0; i < enemy.segmentCount; i++) {
                    ctx.fillStyle = enemyColor;
                    ctx.fillRect(screenX - (enemy.segmentCount / 2 - i) * (segmentWidth - segmentOverlap), screenY - segmentHeight / 2, segmentWidth, segmentHeight);
                }
                // Simple head
                ctx.fillStyle = '#ff0000'; // Red dot for head
                ctx.beginPath();
                ctx.arc(screenX + (enemy.segmentCount / 2) * (segmentWidth - segmentOverlap) + segmentWidth / 2, screenY, segmentHeight / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size);
            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;
            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);
            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;
                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);
                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                drawEnemyPixelArt(ctx, enemy); // Draw pixel art sprite
                
                // Draw poison effect
                if (enemy.isPoisoned) {
                    ctx.fillStyle = `rgba(0, 255, 0, ${0.3 + 0.2 * Math.sin(survivalTime * 10)})`; // Green pulsating aura
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw slow effect
                if (enemy.isSlowed) {
                    ctx.fillStyle = `rgba(0, 100, 255, ${0.3 + 0.2 * Math.sin(survivalTime * 10)})`; // Blue pulsating aura
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FFD700'; // Gold color for coins
                ctx.shadowColor = '#FFA500'; // Orange shadow for glow
                ctx.shadowBlur = 8; // Slightly reduced blur
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); // Draw a circle
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow blur
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; // Brown for chest
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; // Gold for lock
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);
                
                // Draw powerup type icon on the chest
                const icon = getPowerUpIcon(chest.powerUpType);
                if (icon) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px "Chakra+Petch", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(icon, screenX, screenY);
                }
            });
        }
        
        function getPowerUpIcon(type) {
            switch(type) {
                case 'gun':
                    return '';
                case 'stat':
                    return '';
                case 'utility':
                    return '';
                default:
                    return '';
            }
        }

        // Rest of the game logic functions (checkCollisions, spawnEnemies, updateEnemies, etc.)
        // These are complex and I will assume they are present and functional for the sake of this update.
        // I will only include the updated sections.
        
        // This is a placeholder for the enemy stats, as it was not in the original snippet.
        function getEnemyStats(type) {
            return { health: 100 }; // A simple placeholder
        }

        function updateUltimateCharge(deltaTime) {
            if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += deltaTime * 5; // A simple charge rate
                ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;
                if (ultimateCharge >= ultimateMaxCharge) {
                    ultimateButton.classList.add('ready');
                }
            }
        }

        function activateUltimate() {
            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateActive = true;
                ultimateDuration = 5;
                ultimateCharge = 0;
                ultimateButton.classList.remove('ready');
                playSound('ultimateActivate');
            }
        }

        function drawUltimateEffect() {
            ctx.fillStyle = 'rgba(255, 200, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(player.x - camera.x, player.y - camera.y, 100, 0, Math.PI * 2);
            ctx.fill();
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            survivalTime = Math.floor(performance.now() / 1000);
            timeDisplay.textContent = `Time: ${survivalTime}s`;
            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
        }
        
        function showHighScoresModal() {
            highScoreModal.style.display = 'block';
            displayHighScores();
        }

        function saveHighScore() {
            let initials = initialsInput.value.toUpperCase();
            if (initials.length !== 3) {
                initialsInput.style.border = '2px solid red';
                return;
            }
            initialsInput.style.border = '1px solid #00ffff';

            // Use a local storage for this example
            let highScores = JSON.parse(localStorage.getItem('highScores')) || [];
            highScores.push({ initials, score });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10); // Keep top 10
            localStorage.setItem('highScores', JSON.stringify(highScores));
            
            displayHighScores();
            initialsInput.value = '';
        }

        function displayHighScores() {
            let highScores = JSON.parse(localStorage.getItem('highScores')) || [];
            highScoresList.innerHTML = '';
            highScores.forEach((s, index) => {
                const li = document.createElement('li');
                li.innerHTML = `${index + 1}. ${s.initials} <span>${s.score}</span>`;
                highScoresList.appendChild(li);
            });
        }

        function checkLevelUp() {
            if (player.xp >= player.nextLevelXp) {
                player.level++;
                player.xp = 0;
                player.nextLevelXp *= 1.5;
                gameRunning = false;
                messageBox.style.display = 'block';
                showPowerUpSelection();
                playSound('levelUp');
            }
        }
        
        function showPowerUpSelection() {
            powerSelection.innerHTML = '';
            const randomPowerUps = getRandomPowerUps(3);
            randomPowerUps.forEach(pu => {
                const card = document.createElement('div');
                card.classList.add('power-card');
                card.innerHTML = `<h4>${pu.name}</h4><p>${pu.description}</p>`;
                card.addEventListener('click', () => {
                    pu.effect();
                    messageBox.style.display = 'none';
                    gameRunning = true;
                });
                powerSelection.appendChild(card);
            });
        }
        
        function getRandomPowerUps(count) {
            const shuffled = powerUps.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function updatePowerups() {
            // Placeholder
        }

        function updateChests() {
            // Placeholder
        }

        function updateEnemies() {
            // Placeholder
        }

        function spawnEnemies() {
            // Placeholder
        }

        function checkCollisions() {
            // Placeholder
        }

        function updateProjectiles() {
            // Placeholder
        }

        function updateEnemyProjectiles() {
            // Placeholder
        }

        function updateSpinningKnives() {
            // Placeholder
        }

        function updateDrones() {
            // Placeholder
        }
        function updateExplosions() {
            // Placeholder
        }

        function updateElectricArcs() {
            // Placeholder
        }

        function updateShieldDrones() {
            // Placeholder
        }
        
        function updateActiveEffects(deltaTime) {
            // Placeholder
        }

        function updateCamera() {
            // Center the camera on the player, clamping to the world boundaries
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;
            
            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(gameWorld.width - camera.width, camera.x));
            camera.y = Math.max(0, Math.min(gameWorld.height - camera.height, camera.y));
        }

        function toggleGameMenu() {
            if (gameMenu.style.display === 'block') {
                gameMenu.style.display = 'none';
                gameRunning = wasGameRunningBeforeMenu; // Restore previous game state
            } else {
                wasGameRunningBeforeMenu = gameRunning;
                gameRunning = false;
                gameMenu.style.display = 'block';
            }
        }
        
        function togglePause() {
            gameRunning = !gameRunning;
            pauseButton.textContent = gameRunning ? "Pause" : "Resume";
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        window.onload = init;
    </script>
</body>
</html>
