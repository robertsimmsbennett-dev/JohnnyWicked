<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Johnny Wicked: Hotel Lobby</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            user-select: none; /* Prevent text selection on touch */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Remove tap highlight on iOS */
            flex-direction: column; /* For better mobile layout */
        }
        
        #gameContainer {
            position: relative;
            width: 900px; /* Base width */
            height: 700px; /* Base height */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;

            /* Responsive adjustments for gameContainer */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 95vh; /* Max height relative to viewport */
            aspect-ratio: 9 / 7; /* Maintain aspect ratio */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Make canvas fill its container */
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
        }
        
        #score-display {
            top: 10px;
            left: 10px;
        }
        
        #menu-button { /* New button styling */
            top: 50px; /* Position below score display */
            left: 10px;
            pointer-events: all;
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: #fff;
            border: none;
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease;
        }

        #menu-button:hover {
            background: linear-gradient(45deg, #0056b3, #003d7a);
        }

        #time-display {
            top: 10px;
            right: 10px;
        }
        
        #level-display {
            bottom: 10px;
            left: 10px;
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
        }
        
        #power-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .power-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 200px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
        }
        
        .power-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
        .power-card p {
            font-size: 0.9em;
            margin-bottom: 0;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0000;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 11; /* Added z-index to ensure menu is on top */
        }
        
        .menu h1 {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            font-size: 2.5em;
        }
        
        .menu h2 {
            color: #ff0000;
        }
        
.menu button {
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
        }
        
        .menu button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        #game-menu.menu button { /* Styling for buttons inside the new game menu */
            background: linear-gradient(45deg, #007bff, #0056b3);
            margin: 10px;
            padding: 10px 20px;
            font-size: 1em;
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #game-menu.menu button:hover {
            background: linear-gradient(45deg, #0056b3, #003d7a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            width: 80%;
            max-width: 250px;
            font-family: 'Chakra Petch', monospace;
            font-size: 1em;
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        #high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #high-scores-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #high-scores-list li:last-child {
            border-bottom: none;
        }
        #high-scores-list li span {
            color: #00ffff;
            font-weight: bold;
        }

        #pause-button {
            position: absolute;
            top: 40px; /* Position below time display */
            right: 10px;
            pointer-events: all;
            background: linear-gradient(45deg, #555, #333);
            color: #d1d1d1;
            border: none;
            padding: 8px 15px;
            font-size: 0.9em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease;
        }

        #pause-button:hover {
            background: linear-gradient(45deg, #666, #444);
        }

        /* New Modals for How to Play and Power Ups */
        .info-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: left; /* Changed to left for content */
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none;
            pointer-events: all;
            max-width: 600px; /* Max width for readability */
            max-height: 80vh; /* Max height for scrollability */
            overflow-y: auto; /* Enable scrolling */
        }

        .info-menu h2 {
            color: #00ffff;
            text-align: center;
            margin-top: 0;
        }

        .info-menu h3 {
            color: #00ccff;
            margin-top: 20px;
            margin-bottom: 5px;
        }

        .info-menu p, .info-menu ul {
            font-size: 0.95em;
            line-height: 1.5;
            color: #d1d1d1;
            margin-bottom: 10px;
        }

        .info-menu ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        .info-menu li {
            margin-bottom: 5px;
        }

        .info-menu button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 20px;
            display: block; /* Make button block level */
            margin-left: auto; /* Center button */
            margin-right: auto; /* Center button */
        }

        .info-menu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 123, 255, 0.4);
        }

        .power-up-item {
            border: 1px solid #0056b3;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .power-up-item h4 {
            color: #00ccff;
            margin-top: 0;
            margin-bottom: 5px;
        }
        .power-up-item p {
            font-size: 0.85em;
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="score-display" class="hud-item">Score: 0</div>
            <button id="menu-button" class="hud-item">Menu</button> <!-- New Menu Button -->
            <div id="time-display" class="hud-item">Time: 0s</div>
            <div id="level-display" class="hud-item">Level: 1</div>
            <div id="xp-bar-container"><div id="xp-bar"></div></div>
            <div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
            <button id="ultimate-button">Wicked Mode</button>
            <button id="pause-button">Pause</button>
        </div>
        
        <div id="start-menu" class="menu">
            <h1>JOHNNY WICKED</h1>
            <p>Click or tap anywhere to move. Your character will fire automatically.</p>
            <p>New: Enemies can now shoot back! Be careful of the gunmen.</p>
            <button id="startButton">Start Game</button>
        </div>

        <div id="game-over-menu" class="menu" style="display: none;">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Score: 0</h2>
            <h2 id="final-time">Time Survived: 0s</h2>
            <h2 id="final-level">Level Reached: 1</h2>
            <h3>High Scores</h3>
            <ul id="high-scores-list">
                <!-- High scores will be loaded here -->
            </ul>
            <button id="restartButton">Restart Game</button>
        </div>

        <div id="message-box" class="menu" style="display: none;">
            <h3 id="message-title">Level Up!</h3>
            <p id="message-text">Choose your power-up:</p>
            <div id="power-selection"></div>
        </div>

        <div id="high-score-modal" style="display: none;">
            <h3>New High Score!</h3>
            <p>Enter your name:</p>
            <input type="text" id="playerNameInput" maxlength="15" placeholder="Your Name">
            <button id="saveScoreButton">Save Score</button>
        </div>

        <!-- New Game Menu -->
        <div id="game-menu" class="menu" style="display: none;">
            <h2>Game Menu</h2>
            <button id="how-to-play-button">How to Play</button>
            <button id="power-ups-button">Power Ups</button>
            <button id="restart-game-menu-button">Restart Game</button>
            <button id="close-menu-button">Close Menu</button>
        </div>

        <!-- How to Play Menu -->
        <div id="how-to-play-menu" class="info-menu" style="display: none;">
            <h2>How to Play</h2>
            <h3>Objective</h3>
            <p>Survive as long as possible against endless waves of enemies. Gain XP, level up, and choose powerful upgrades to become unstoppable!</p>
            <h3>Controls</h3>
            <ul>
                <li><strong>Movement:</strong> Click or tap anywhere on the screen to move your character to that location. Your character will automatically navigate to the target.</li>
                <li><strong>Auto-Fire:</strong> Your character fires automatically at the closest enemy.</li>
                <li><strong>Ultimate Ability (Wicked Mode):</strong> Once your ultimate bar is full, press the "Wicked Mode" button (or 'E' key) to activate a temporary burst of power, significantly increasing your damage and reducing incoming damage.</li>
            </ul>
            <h3>Gameplay Mechanics</h3>
            <ul>
                <li><strong>XP & Leveling:</strong> Defeat enemies to gain XP. Collect golden power-ups dropped by enemies to earn more XP. Fill your XP bar to level up and choose from a selection of powerful upgrades.</li>
                <li><strong>Health:</strong> Keep an eye on your health bar. If it drops to zero, it's game over. Some upgrades can restore health or provide regeneration.</li>
                <li><strong>Enemies:</strong> Various enemy types will appear, each with unique behaviors. Some charge you, others shoot, and some explode!</li>
                <li><strong>Obstacles:</strong> The environment contains obstacles like pillars and desks. Use them to your advantage to block enemy projectiles or funnel enemies.</li>
                <li><strong>Chests:</strong> Occasionally, treasure chests will spawn. Pick them up for temporary powerful effects like spread shot or extreme bullet time.</li>
            </ul>
            <button id="close-how-to-play-button">Close</button>
        </div>

        <!-- Power Ups Menu -->
        <div id="power-ups-menu" class="info-menu" style="display: none;">
            <h2>Power Ups & Upgrades</h2>
            <p>Here's a list of all the upgrades you can acquire to enhance your abilities:</p>
            <div id="power-ups-list">
                <!-- Power up details will be dynamically loaded here -->
            </div>
            <button id="close-power-ups-button">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in init function)
        window.fb = {};

        window.initFirebase = async function() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing. High score system will not function.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            window.fb.db = getFirestore(app);
            window.fb.auth = getAuth(app);

            // Sign in anonymously if no custom token is provided
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(window.fb.auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await signInAnonymously(window.fb.auth);
                    console.log("Signed in anonymously instead.");
                }
            } else {
                await signInAnonymously(window.fb.auth);
                console.log("Signed in anonymously.");
            }

            // Listen for auth state changes to ensure user is ready
            onAuthStateChanged(window.fb.auth, (user) => {
                if (user) {
                    window.fb.userId = user.uid;
                    console.log("Firebase user ready:", window.fb.userId);
                } else {
                    console.log("Firebase user not signed in.");
                }
            });
        };

        window.saveHighScoreFirebase = async function(name, score, time, level) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated.");
                return;
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.__app_id}/public/data/highScores`);
            try {
                await addDoc(highScoresCollection, {
                    name: name,
                    score: score,
                    survivalTime: time,
                    level: level,
                    timestamp: Date.now(), // Use server timestamp for consistency
                    userId: window.fb.userId // Store user ID for potential future features
                });
                console.log("High score saved successfully!");
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        };

        window.getHighScoresFirebase = async function() {
            if (!window.fb.db) {
                console.error("Firestore not initialized.");
                return [];
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.__app_id}/public/data/highScores`);
            const q = query(highScoresCollection, orderBy("score", "desc"), limit(10));
            
            try {
                const querySnapshot = await getDocs(q);
                const highScores = [];
                querySnapshot.forEach((doc) => {
                    highScores.push(doc.data());
                });
                    // Sort high scores by score in descending order (Firebase orderBy handles this, but client-side for safety)
                    highScores.sort((a, b) => b.score - a.score);
                return highScores;
            } catch (e) {
                console.error("Error getting documents: ", e);
                return [];
            }
        };
    </script>

    <script>
        // Get canvas and UI elements from the DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const messageBox = document.getElementById('message-box');
        const powerSelectionDiv = document.getElementById('power-selection');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoreModal = document.getElementById('high-score-modal');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const highScoresList = document.getElementById('high-scores-list');
        const pauseButton = document.getElementById('pause-button'); // Get the new pause button
        const menuButton = document.getElementById('menu-button'); // New: Menu button
        const gameMenu = document.getElementById('game-menu'); // New: Game menu div
        const restartGameMenuButton = document.getElementById('restart-game-menu-button'); // New: Restart button in menu
        const closeMenuButton = document.getElementById('close-menu-button'); // New: Close menu button
        
        const howToPlayButton = document.getElementById('how-to-play-button'); // New: How to Play button
        const howToPlayMenu = document.getElementById('how-to-play-menu'); // New: How to Play menu div
        const closeHowToPlayButton = document.getElementById('close-how-to-play-button'); // New: Close How to Play button

        const powerUpsButton = document.getElementById('power-ups-button'); // New: Power Ups button
        const powerUpsMenu = document.getElementById('power-ups-menu'); // New: Power Ups menu div
        const powerUpsListDiv = document.getElementById('power-ups-list'); // New: Div to list power ups
        const closePowerUpsButton = document.getElementById('close-power-ups-button'); // New: Close Power Ups button

        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');

        // Game state variables
        let gameRunning = false;
        let wasGameRunningBeforeMenu = false; // New: Flag to store game state before menu opens
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let gameWorld = {
            width: 2000,
            height: 2000
        };
        let gameSpeedMultiplier = 1; // Global speed multiplier for Bullet Time
        let playerSpeedModifier = 1; // Multiplier for player speed during bullet time
        let projectileSpeedModifier = 1; // Multiplier for player projectiles during bullet time
        let bulletTimeActive = false; // This variable is no longer directly used for effect application, but kept for clarity if needed.
        let bulletTimeDuration = 0; // This variable is no longer directly used for effect application, but kept for clarity if needed.
        let spinningKnives = []; // Array for spinning knives
        let drones = []; // Array for friendly drones
        let explosions = []; // New array for explosions
        let electricArcs = []; // For drawing electric arcs
        let shieldDrones = []; // Array for shield drones

        // New: Object to manage active temporary power-ups and their end times
        let activeTemporaryEffects = {}; 

        let chestSpawnTimer = 0;
        const CHEST_SPAWN_INTERVAL = 15; // Chest spawns every 15 seconds
        let chests = []; // Array for chests

        // Camera for a larger game world
        let camera = {
            x: 0,
            y: 0,
            width: 900,
            height: 700
        };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#d1d1d1',
            speed: 300, 
            health: 100,
            maxHealth: 100,
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10, 
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 50,
                defense: 0,
                uziDamage: 0, // Renamed from waveDamage
                uziProjectileSpeed: 0, // New Uzi stat
                uziNumProjectiles: 0, // New Uzi stat
                uziSpiralFactor: 0, // New Uzi stat
                spinningKnivesDamage: 0, 
                spinningKnivesCount: 0, 
                burstDamage: 0,
                burstProjectileCount: 0,
                bazookaDamage: 0, // New: Bazooka damage
                bazookaRadius: 0, // New: Bazooka explosion radius
                shotgunProjectiles: 0, // New: Shotgun projectile count
                shotgunSpread: 0, // New: Shotgun spread angle
                friendlyDrones: 0, // New: Number of friendly drones
                droneAttackSpeed: 0, // New: Friendly drone attack speed
                droneDamage: 0, // New: Friendly drone damage
                
                // New Gun Varieties Stats
                flamethrowerDamage: 0,
                flamethrowerRange: 0,
                flamethrowerArc: 0,
                laserDamage: 0,
                laserWidth: 0,
                grenadeDamage: 0,
                grenadeRadius: 0,
                electricDamage: 0,
                electricChainCount: 0,
                electricChainRange: 0,
                poisonDamage: 0,
                poisonDuration: 0,
                poisonTickRate: 0,
                ricochetCount: 0,
                homingDamage: 0,
                homingSpeed: 0,
                homingTurnRate: 0,
                shieldDroneCount: 0,
                shieldDroneHealth: 0,
                vampiricHealPercent: 0,
                cryoSlowAmount: 0,
                cryoSlowDuration: 0
            },
            upgrades: {
                damage: 0,
                attackSpeed: 0,
                health: 0,
                speed: 0,
                pierce: 0,
                multiShot: 0,
                healthRegen: 0,
                magnet: 0,
                defense: 0,
                uzi: 0, // Renamed from circularWave
                ultimateRecharge: 0,
                burstShot: 0,
                spinningKnives: 0, 
                // bulletTime: 0, // Removed bulletTime upgrade
                bazooka: 0, // New: Bazooka upgrade level
                shotgun: 0, // New: Shotgun upgrade level
                friendlyDrone: 0, // New: Friendly drone upgrade level

                // New Gun Varieties Upgrades
                flamethrower: 0,
                laserBeam: 0,
                grenadeLauncher: 0,
                electricArc: 0,
                poisonDarts: 0,
                ricochetShot: 0,
                homingMissile: 0,
                shieldDrone: 0,
                vampiricRounds: 0,
                cryoBlast: 0
            },
            uziCooldown: 10, // Renamed from waveCooldown
            uziTimer: 0, // Renamed from waveTimer
            burstCooldown: 1,
            burstTimer: 0,
            flamethrowerCooldown: 0.5, // Cooldown for flamethrower
            flamethrowerTimer: 0,
            laserCooldown: 2, // Cooldown for laser
            laserTimer: 0,
            grenadeCooldown: 1.5, // Cooldown for grenades
            grenadeTimer: 0,
            homingCooldown: 3, // Cooldown for homing missile
            homingTimer: 0,
            lastX: initialPlayerX,
            lastY: initialPlayerY,
            animationFrame: 0,
            isMoving: false,
            vx: 0, // Added velocity X
            vy: 0, // Added velocity Y
        };

        // Input handling
        const keys = {
            e: false 
        };

        // Game entities
        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let powerups = [];
        // Removed waveAttacks array as it's replaced by Uzi projectiles
        let ultimateActive = false;
        let ultimateDuration = 0;
        let obstacles = [];

        // Enemy and power-up configuration
        const ENEMY_TYPES = ['basic', 'fast', 'tank', 'elite', 'gunner', 'drone', 'car', 'ninja', 'snake']; // Added new enemy types
        const MAX_UPGRADE_LEVEL = 8;
        const POWER_OPTIONS = [
            { id: 'damage', name: 'Increase Damage', description: 'Increases projectile damage.',
              level: () => player.upgrades.damage,
              effect: () => player.stats.damage += 10,
              next: () => `Increase projectile damage by 10. (Lvl ${player.upgrades.damage + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'attackSpeed', name: 'Increase Attack Speed', description: 'Increases the number of projectiles fired per second.',
              level: () => player.upgrades.attackSpeed,
              effect: () => player.stats.attackSpeed += 2,
              next: () => `Increase fire rate by 2. (Lvl ${player.upgrades.attackSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'health', name: 'Increase Health', description: 'Increases max health and heals you.', 
              level: () => player.upgrades.health,
              effect: () => { player.maxHealth += 25; player.health = Math.min(player.health + 25, player.maxHealth); },
              next: () => `Increase max health by 25 and heal. (Lvl ${player.upgrades.health + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'speed', name: 'Increase Speed', description: 'Increases player movement speed.',
              level: () => player.upgrades.speed,
              effect: () => player.speed += 50,
              next: () => `Increase speed by 50. (Lvl ${player.upgrades.speed + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'pierce', name: 'Pierce Shot', description: 'Your projectiles can hit multiple enemies.',
              level: () => player.upgrades.pierce,
              effect: () => player.stats.pierce++,
              next: () => `Projectiles can hit one more enemy. (Lvl ${player.upgrades.pierce + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'multiShot', name: 'Multi-shot', description: 'Fire multiple projectiles at once.', 
              level: () => player.upgrades.multiShot,
              effect: () => player.stats.multiShot++,
              next: () => `Fire one more projectile per shot. (Lvl ${player.upgrades.multiShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'healthRegen', name: 'Health Regen', description: 'Gain passive health regeneration.', 
              level: () => player.upgrades.healthRegen,
              effect: () => player.stats.healthRegen += 0.5,
              next: () => `Increase health regen by 0.5/s. (Lvl ${player.upgrades.healthRegen + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'magnet', name: 'Magnet Range', description: 'Increases the range for collecting XP.',
              level: () => player.upgrades.magnet,
              effect: () => player.stats.magnet += 20,
              next: () => `Increase magnet range by 20. (Lvl ${player.upgrades.magnet + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'defense', name: 'Defense', description: 'Reduces damage taken.',
              level: () => player.upgrades.defense,
              effect: () => player.stats.defense += 0.1,
              next: () => `Reduce damage taken by 10%. (Lvl ${player.upgrades.defense + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'uzi', name: 'Uzi Spiral', description: 'Unleashes a spiral of Uzi bullets around you. Press E to use.', 
              level: () => player.upgrades.uzi,
              effect: () => { 
                player.upgrades.uzi++;
                player.stats.uziDamage = 15 + player.upgrades.uzi * 5; // Damage per Uzi bullet
                player.stats.uziProjectileSpeed = 300 + player.upgrades.uzi * 50; // Speed of Uzi bullets
                player.stats.uziNumProjectiles = 12 + player.upgrades.uzi * 2; // Number of bullets in the spiral
                player.stats.uziSpiralFactor = 0.1 + player.upgrades.uzi * 0.02; // How wide the spiral is
                player.uziTimer = 0; 
                player.uziCooldown = 5 / (1 + player.upgrades.uzi * 0.2); // Faster cooldown
                console.log(`Uzi upgraded! Spiral Factor: ${player.stats.uziSpiralFactor}`); // Log the factor
              },
              next: () => `Unleash ${12 + (player.upgrades.uzi + 1) * 2} spiraling Uzi bullets. Damage: ${15 + (player.upgrades.uzi + 1) * 5}. (Lvl ${player.upgrades.uzi + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'ultimateRecharge', name: 'Ultimate Recharge Speed', description: 'The ultimate ability recharges faster.',
              level: () => player.upgrades.ultimateRecharge,
              effect: () => ultimateChargePerHit += 0.2,
              next: () => `Ultimate charges faster per hit. (Lvl ${player.upgrades.ultimateRecharge + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'burstShot', name: 'Multi-shot Burst', description: 'Fires a burst of projectiles in a circle.',
              level: () => player.upgrades.burstShot,
              effect: () => {
                player.stats.burstDamage = 10 + player.upgrades.burstShot * 5;
                player.stats.burstProjectileCount = 8 + player.upgrades.burstShot * 2;
                player.burstCooldown = 1 - (player.upgrades.burstShot * 0.1);
              },
              next: () => `Fires a circle of projectiles. (Lvl ${player.upgrades.burstShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'spinningKnives', name: 'Spinning Blades', description: 'Summon blades that orbit you, damaging enemies.',
              level: () => player.upgrades.spinningKnives,
              effect: () => {
                player.upgrades.spinningKnives++;
                player.stats.spinningKnivesCount++;
                player.stats.spinningKnivesDamage = 15 + player.upgrades.spinningKnives * 5;
                updateSpinningKnivesEffect();
              },
              next: () => `Summon ${player.upgrades.spinningKnives + 1} spinning knives. Damage: ${15 + (player.upgrades.spinningKnives + 1) * 5}. (Lvl ${player.upgrades.spinningKnives + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'bazooka', name: 'Bazooka Add-on', description: 'Your projectiles become larger and deal area damage on impact.',
              level: () => player.upgrades.bazooka,
              effect: () => {
                player.upgrades.bazooka++;
                player.stats.bazookaDamage = 50 + player.upgrades.bazooka * 20;
                player.stats.bazookaRadius = 50 + player.upgrades.bazooka * 10;
              },
              next: () => `Projectiles explode for ${50 + (player.upgrades.bazooka + 1) * 20} area damage. Radius: ${50 + (player.upgrades.bazooka + 1) * 10}. (Lvl ${player.upgrades.bazooka + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'shotgun', name: 'Shotgun', description: 'Fires multiple projectiles in a wide cone.',
              level: () => player.upgrades.shotgun,
              effect: () => {
                player.upgrades.shotgun++;
                player.stats.shotgunProjectiles = 3 + player.upgrades.shotgun * 1; /* Reduced base projectiles and increment */
                player.stats.shotgunSpread = 0.1 + player.upgrades.shotgun * 0.02; /* Reduced base spread and increment for tighter spread */
              },
              next: () => `Fire ${3 + (player.upgrades.shotgun + 1) * 1} projectiles with tighter spread. (Lvl ${player.upgrades.shotgun + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'friendlyDrone', name: 'Friendly Drone', description: 'Summons an orbiting drone that fires at enemies.',
              level: () => player.upgrades.friendlyDrone,
              effect: () => {
                player.upgrades.friendlyDrone++;
                // Initialize/update drone stats based on level
                if (player.upgrades.friendlyDrone === 1) {
                    player.stats.friendlyDrones = 1;
                    player.stats.droneAttackSpeed = 1; // Base attack speed
                    player.stats.droneDamage = 10; // Base damage
                } else if (player.upgrades.friendlyDrone === 3) {
                    player.stats.friendlyDrones = 2;
                } else if (player.upgrades.friendlyDrone === 4) {
                    player.stats.droneAttackSpeed += 0.5; // Increase attack speed
                } else if (player.upgrades.friendlyDrone === 8) {
                    player.stats.friendlyDrones = 3;
                }
                // Update existing drones or create new ones
                updateDroneCount();
              },
              next: () => {
                  let nextLevel = player.upgrades.friendlyDrone + 1;
                  if (nextLevel === 1) return `Summon 1 drone.`;
                  if (nextLevel === 3) return `Summon a second drone.`;
                  if (nextLevel === 4) return `Drones fire more frequently.`;
                  if (nextLevel === 8) return `Summon a third drone.`;
                  return `Improve drone stats. (Lvl ${nextLevel}/${MAX_UPGRADE_LEVEL})`;
              }
            },
            // --- NEW GUN VARIETIES ---
            { id: 'flamethrower', name: 'Flamethrower', description: 'Deals continuous damage in a cone.',
              level: () => player.upgrades.flamethrower,
              effect: () => {
                player.upgrades.flamethrower++;
                player.stats.flamethrowerDamage = 5 + player.upgrades.flamethrower * 3;
                player.stats.flamethrowerRange = 80 + player.upgrades.flamethrower * 10;
                player.stats.flamethrowerArc = Math.PI / 4 + player.upgrades.flamethrower * (Math.PI / 32); // Wider arc
              },
              next: () => `Deal ${5 + (player.upgrades.flamethrower + 1) * 3} continuous damage in a cone. (Lvl ${player.upgrades.flamethrower + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'laserBeam', name: 'Laser Beam', description: 'Fires a powerful, piercing laser.',
              level: () => player.upgrades.laserBeam,
              effect: () => {
                player.upgrades.laserBeam++;
                player.stats.laserDamage = 100 + player.upgrades.laserBeam * 50;
                player.stats.laserWidth = 10 + player.upgrades.laserBeam * 2;
              },
              next: () => `Fire a piercing laser dealing ${100 + (player.upgrades.laserBeam + 1) * 50} damage. (Lvl ${player.upgrades.laserBeam + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'grenadeLauncher', name: 'Grenade Launcher', description: 'Launches grenades that explode on impact.',
              level: () => player.upgrades.grenadeLauncher,
              effect: () => {
                player.upgrades.grenadeLauncher++;
                player.stats.grenadeDamage = 70 + player.upgrades.grenadeLauncher * 30;
                player.stats.grenadeRadius = 60 + player.upgrades.grenadeLauncher * 15;
              },
              next: () => `Launch grenades exploding for ${70 + (player.upgrades.grenadeLauncher + 1) * 30} area damage. (Lvl ${player.upgrades.grenadeLauncher + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'electricArc', name: 'Electric Arc', description: 'Projectiles chain damage to nearby enemies.',
              level: () => player.upgrades.electricArc,
              effect: () => {
                player.upgrades.electricArc++;
                player.stats.electricDamage = 15 + player.upgrades.electricArc * 5;
                player.stats.electricChainCount = 1 + Math.floor(player.upgrades.electricArc / 2); // Every 2 levels, +1 chain
                player.stats.electricChainRange = 100 + player.upgrades.electricArc * 10;
              },
              next: () => `Projectiles chain to ${1 + Math.floor((player.upgrades.electricArc + 1) / 2)} enemies for ${15 + (player.upgrades.electricArc + 1) * 5} damage. (Lvl ${player.upgrades.electricArc + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'poisonDarts', name: 'Poison Darts', description: 'Projectiles apply damage over time.',
              level: () => player.upgrades.poisonDarts,
              effect: () => {
                player.upgrades.poisonDarts++;
                player.stats.poisonDamage = 5 + player.upgrades.poisonDarts * 2; // Damage per tick
                player.stats.poisonDuration = 3 + player.upgrades.poisonDarts * 0.5;
                player.stats.poisonTickRate = 0.5; // Tick every 0.5 seconds
              },
              next: () => `Projectiles apply ${5 + (player.upgrades.poisonDarts + 1) * 2} poison damage per tick for ${3 + (player.upgrades.poisonDarts + 1) * 0.5}s. (Lvl ${player.upgrades.poisonDarts + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'ricochetShot', name: 'Ricochet Shot', description: 'Projectiles bounce off walls.',
              level: () => player.upgrades.ricochetShot,
              effect: () => {
                player.upgrades.ricochetShot++;
                player.stats.ricochetCount = 1 + player.upgrades.ricochetShot;
              },
              next: () => `Projectiles bounce ${1 + (player.upgrades.ricochetShot + 1)} times. (Lvl ${player.upgrades.ricochetShot + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'homingMissile', name: 'Homing Missile', description: 'Fires slow, tracking missiles.',
              level: () => player.upgrades.homingMissile,
              effect: () => {
                player.upgrades.homingMissile++;
                player.stats.homingDamage = 80 + player.upgrades.homingMissile * 40;
                player.stats.homingSpeed = 150 + player.upgrades.homingMissile * 20;
                player.stats.homingTurnRate = 0.05 + player.upgrades.homingMissile * 0.01;
              },
              next: () => `Fire homing missiles dealing ${80 + (player.upgrades.homingMissile + 1) * 40} damage. (Lvl ${player.upgrades.homingMissile + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'shieldDrone', name: 'Shield Drone', description: 'Summons a drone that blocks enemy projectiles.',
              level: () => player.upgrades.shieldDrone,
              effect: () => {
                player.upgrades.shieldDrone++;
                player.stats.shieldDroneCount = 1 + Math.floor(player.upgrades.shieldDrone / 3); // Every 3 levels, +1 drone
                player.stats.shieldDroneHealth = 50 + player.upgrades.shieldDrone * 20;
                updateShieldDroneCount();
              },
              next: () => `Summon ${1 + Math.floor((player.upgrades.shieldDrone + 1) / 3)} shield drones with ${50 + (player.upgrades.shieldDrone + 1) * 20} health. (Lvl ${player.upgrades.shieldDrone + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'vampiricRounds', name: 'Vampiric Rounds', description: 'Heal for a % of damage dealt.',
              level: () => player.upgrades.vampiricRounds,
              effect: () => {
                player.upgrades.vampiricRounds++;
                player.stats.vampiricHealPercent = 0.01 + player.upgrades.vampiricRounds * 0.005; // 0.5% per level
              },
              next: () => `Heal for ${(0.01 + (player.upgrades.vampiricRounds + 1) * 0.005) * 100}% of damage dealt. (Lvl ${player.upgrades.vampiricRounds + 1}/${MAX_UPGRADE_LEVEL})`,
            },
            { id: 'cryoBlast', name: 'Cryo Blast', description: 'Slows enemies on hit.',
              level: () => player.upgrades.cryoBlast,
              effect: () => {
                player.upgrades.cryoBlast++;
                player.stats.cryoSlowAmount = 0.2 + player.upgrades.cryoBlast * 0.05; // Slow by 20% + 5% per level
                player.stats.cryoSlowDuration = 1 + player.upgrades.cryoBlast * 0.2;
              },
              next: () => `Projectiles slow enemies by ${(0.2 + (player.upgrades.cryoBlast + 1) * 0.05) * 100}% for ${1 + (player.upgrades.cryoBlast + 1) * 0.2}s. (Lvl ${player.upgrades.cryoBlast + 1}/${MAX_UPGRADE_LEVEL})`,
            }
        ];
        
        let shootTimer = 0;
        let spawnTimer = 0;
        // Ultimate charge per hit reduced for slower build-up
        let ultimateChargePerHit = 0.5; 
        
        // New variables for sound timing to prevent "strictly greater" error
        let nextPlayerShotTime = 0;
        let nextEnemyHitTime = 0;

        // Tone.js audio setup
        let playerSynth;
        let enemyHitSynth;
        let levelUpSynth;
        let ultimateSynth;
        let gameOverSynth;
        let explosionSound;

        // Helper function to calculate distance
        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // --- New Collision Resolution Functions ---

        // Resolves collision between two circles (e.g., player/enemy and pillar)
        function circleCircleCollideAndResolve(c1, c2) {
            let dx = c1.x - c2.x;
            let dy = c1.y - c2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = c1.size / 2 + c2.size / 2; // c2.size is diameter for pillar, so c2.size/2 is radius

            if (distance < minDistance) {
                if (distance === 0) { // Objects are exactly on top of each other, push randomly to prevent infinite loop
                    c1.x += Math.random() * 0.1 - 0.05;
                    c1.y += Math.random() * 0.1 - 0.05;
                    return true;
                }
                let overlap = minDistance - distance;
                let normalX = dx / distance;
                let normalY = dy / distance;

                // Push c1 out of c2
                c1.x += normalX * overlap;
                c1.y += normalY * overlap;

                // Slide along the surface (project velocity onto tangent)
                let dotProduct = c1.vx * normalX + c1.vy * normalY;
                if (dotProduct < 0) { // Only if moving towards the obstacle
                    c1.vx -= dotProduct * normalX;
                    c1.vy -= dotProduct * normalY;
                }
                return true;
            }
            return false;
        }

        // Resolves collision between a circle and a rectangle (e.g., player/enemy and desk/chair)
        function circleRectCollideAndResolve(circle, rect) {
            // Find the closest point on the rectangle to the center of the circle
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let dx = circle.x - closestX;
            let dy = circle.y - closestY;
            let distanceSquared = (dx * dx) + (dy * dy);
            let radius = circle.size / 2;

            if (distanceSquared < radius * radius) {
                let distance = Math.sqrt(distanceSquared);
                if (distance === 0) { // Circle center is inside rectangle
                    // Push out along the axis with least penetration
                    let overlapX = Math.min(Math.abs(circle.x - rect.x), Math.abs((rect.x + rect.width) - circle.x));
                    let overlapY = Math.min(Math.abs(circle.y - rect.y), Math.abs((rect.y + rect.height) - circle.y));

                    if (overlapX < overlapY) {
                        circle.x += (circle.x > rect.x + rect.width / 2 ? 1 : -1) * (radius - Math.abs(dx));
                    } else {
                        circle.y += (circle.y > rect.y + rect.height / 2 ? 1 : -1) * (radius - Math.abs(dy));
                    }
                } else {
                    let overlap = radius - distance;
                    let normalX = dx / distance;
                    let normalY = dy / distance;

                    // Push circle out of rectangle
                    circle.x += normalX * overlap;
                    circle.y += normalY * overlap;

                    // Slide along the surface
                    let dotProduct = circle.vx * normalX + circle.vy * normalY;
                    if (dotProduct < 0) { // Only if moving into the obstacle
                        circle.vx -= dotProduct * normalX;
                        circle.vy -= dotProduct * normalY;
                    }
                }
                return true;
            }
            return false;
        }

        // --- End Collision Resolution Functions ---

        // Function to play sound effects
        function playSound(type) {
            // Check if Tone.Destination is muted before playing any sound
            if (Tone.Destination.mute) {
                return;
            }
            
            const currentTime = Tone.now(); // Get current Tone.js time

            switch(type) {
                case 'playerShot':
                    // Calculate the earliest time this sound can be played to avoid the error
                    // It should be at least Tone.now(), and also at least the previously scheduled nextPlayerShotTime
                    const playerShotStartTime = Math.max(currentTime, nextPlayerShotTime);
                    if (playerSynth) {
                        playerSynth.triggerAttackRelease("C4", "8n", playerShotStartTime);
                    }
                    // Schedule the *next* sound after a debounce period from its actual start time
                    nextPlayerShotTime = playerShotStartTime + 0.15; 
                    break;
                case 'enemyHit':
                    const enemyHitStartTime = Math.max(currentTime, nextEnemyHitTime);
                    if (enemyHitSynth) {
                        enemyHitSynth.triggerAttackRelease("16n", enemyHitStartTime);
                    }
                    nextEnemyHitTime = enemyHitStartTime + 0.005; // Small offset
                    break;
                case 'levelUp':
                    if (levelUpSynth) levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    if (ultimateSynth) ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    if (gameOverSynth) gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    if (explosionSound) explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5
                }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.1, decay: 0.5, sustain: 0.3, release: 1
                }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001, decay: 0.4, release: 0.2
                },
                harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); // Draw chests
            drawEnemies();
            drawPlayer();
            // Removed drawWaveAttacks as it's replaced by Uzi projectiles
            drawSpinningKnives(); // Draw spinning knives
            drawDrones(); // Draw friendly drones
            drawExplosions(); // Draw explosions
            drawElectricArcs(); // Draw electric arcs
            drawShieldDrones(); // Draw shield drones
            if (ultimateActive) {
                drawUltimateEffect();
            }
            drawUI();
            drawDamageNumbers();
        }
        
        function drawBackground() {
            ctx.fillStyle = '#101010';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const patternSize = 50;
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 1;

            const startX = -camera.x % patternSize;
            const startY = -camera.y % patternSize;

            for (let x = startX; x < camera.width; x += patternSize) {
                for (let y = startY; y < camera.height; y += patternSize) {
                    ctx.beginPath();
                    ctx.rect(x, y, patternSize, patternSize);
                    ctx.stroke();
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar') {
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair') {
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                }
            });
        }
        
        function drawPixelArt(ctx, x, y, spriteName, frame, size) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;

            if (spriteName === 'player') {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
                ctx.fillStyle = '#c79b69';
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                if (player.isMoving) {
                    const legOffset = Math.sin(player.animationFrame) * s/2; 
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s);
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s);
                } else {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s);
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s);
                }
            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;

            const enemyColor = enemy.controlled ? '#00ff66' : enemy.color;

            ctx.fillStyle = '#c79b69';
            ctx.fillRect(screenX - s/4, screenY - s/2 - s/4, s/2, s/2);
            
            ctx.fillStyle = enemyColor;
            ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
            
            ctx.fillStyle = enemyColor;
            ctx.fillRect(screenX - s/2, screenY + s, s/2, s);
            ctx.fillRect(screenX, screenY + s, s/2, s);

            if (enemy.type === 'tank') {
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
            } else if (enemy.type === 'gunner') { 
                ctx.fillStyle = '#444444';
                ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
            } else if (enemy.type === 'elite') {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                ctx.stroke();
            } else if (enemy.type === 'car') {
                ctx.fillStyle = '#663300'; // Brown for car body
                ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                ctx.fillStyle = '#000000'; // Black for wheels
                ctx.beginPath();
                ctx.arc(screenX - s/2 + s/8, screenY + s/4, s/8, 0, Math.PI * 2);
                ctx.arc(screenX + s/2 - s/8, screenY + s/4, s/8, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'ninja') {
                ctx.fillStyle = '#333333'; // Dark grey for ninja suit
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                ctx.fillStyle = '#1a1a1a'; // Mask
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
            } else if (enemy.type === 'drone') {
                ctx.fillStyle = '#888888'; // Grey for drone body
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#555555'; // Darker grey for propellers
                ctx.fillRect(screenX - s * 0.7, screenY - s * 0.1, s * 1.4, s * 0.2);
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.7, s * 0.2, s * 1.4);
            } else if (enemy.type === 'snake') {
                const segmentWidth = s * 0.8;
                const segmentHeight = s * 0.4;
                const segmentOverlap = s * 0.2; 

                for (let i = 0; i < enemy.segmentCount; i++) {
                    ctx.fillStyle = enemyColor;
                    ctx.fillRect(screenX - (enemy.segmentCount / 2 - i) * (segmentWidth - segmentOverlap), screenY - segmentHeight / 2, segmentWidth, segmentHeight);
                }
                // Simple head
                ctx.fillStyle = '#ff0000'; // Red dot for head
                ctx.beginPath();
                ctx.arc(screenX + (enemy.segmentCount / 2) * (segmentWidth - segmentOverlap) + segmentWidth / 2, screenY, segmentHeight / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size);

            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;

            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                
                drawEnemyPixelArt(ctx, enemy);

                // Draw poison effect
                if (enemy.isPoisoned) {
                    ctx.fillStyle = `rgba(0, 255, 0, ${0.3 + 0.2 * Math.sin(survivalTime * 10)})`; // Green pulsating aura
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw slow effect
                if (enemy.isSlowed) {
                    ctx.fillStyle = `rgba(0, 100, 255, ${0.3 + 0.2 * Math.sin(survivalTime * 10)})`; // Blue pulsating aura
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                
                let currentSize = p.size;
                let currentColor = p.color;

                if (p.isShotgun) {
                    // Opacity fades out based on remaining lifetime
                    const opacity = p.lifetime / 0.3; // 0.3 is the max lifetime for shotgun
                    currentSize = p.size * (0.5 + 0.5 * opacity); // Size shrinks as it fades
                    currentColor = `rgba(255, 255, 255, ${opacity})`; // White with fading opacity
                } else if (p.isLaser) {
                    // Laser is drawn as a rectangle
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(screenX - p.size / 2, screenY - p.width / 2, p.size, p.width);
                    return; // Skip default circle draw
                } else if (p.isHoming) {
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Draw a small triangle for direction
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.moveTo(currentSize, 0);
                    ctx.lineTo(-currentSize, -currentSize / 2);
                    ctx.lineTo(-currentSize, currentSize / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    return; // Skip default circle draw
                }

                ctx.fillStyle = currentColor;
                ctx.beginPath();
                ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                ctx.fill();
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FFD700'; // Gold color for coins
                ctx.shadowColor = '#FFA500'; // Orange shadow for glow
                ctx.shadowBlur = 8; // Slightly reduced blur
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); // Draw a circle
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow blur
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; // Brown for chest
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; // Gold for lock
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);

                // Draw powerup indicator
                let indicatorText = '';
                switch (chest.powerupType) {
                    case 'spreadGun': indicatorText = 'S'; break;
                    case 'extremeBulletTime': indicatorText = 'B'; break;
                    case 'experience': indicatorText = 'E'; break; // Added 'E' for experience
                    case 'invincibility': indicatorText = 'I'; break; // New: Invincibility
                    case 'damageBoost': indicatorText = 'D+'; break; // New: Damage Boost
                }

                if (indicatorText) {
                    ctx.fillStyle = '#FFFFFF'; // White text
                    ctx.font = `bold ${chest.size * 0.6}px 'Chakra Petch'`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(indicatorText, screenX, screenY - chest.size * 0.7); // Position above chest
                }
            });
        }

        // Removed drawWaveAttacks as it's replaced by Uzi projectiles
        // function drawWaveAttacks() { ... }

        function drawSpinningKnives() {
            spinningKnives.forEach(knife => {
                const screenX = knife.x - camera.x;
                const screenY = knife.y - camera.y;
                ctx.fillStyle = '#AAAAAA'; // Knife color
                ctx.beginPath();
                ctx.arc(screenX, screenY, knife.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawDrones() { // Renamed from drawFriendlyDog
            drones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;
                
                ctx.fillStyle = '#00FFFF'; // Cyan for drone body
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00AAFF'; // Darker cyan for accents
                ctx.fillRect(screenX - s * 0.7, screenY - s * 0.1, s * 1.4, s * 0.2);
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.7, s * 0.2, s * 1.4);
            });
        }

        function drawExplosions() {
            explosions.forEach(explosion => {
                const screenX = explosion.x - camera.x;
                const screenY = explosion.y - camera.y;
                const opacity = 1 - (explosion.radius / explosion.maxRadius);
                ctx.beginPath();
                ctx.arc(screenX, screenY, explosion.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 100, 0, ${opacity * 0.5})`; // Orange color, fading out
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 150, 0, ${opacity})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }

        function drawElectricArcs() {
            electricArcs.forEach(arc => {
                ctx.strokeStyle = `rgba(0, 200, 255, ${arc.lifetime / 0.1})`; // Fading blue
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(arc.x1 - camera.x, arc.y1 - camera.y);
                ctx.lineTo(arc.x2 - camera.x, arc.y2 - camera.y);
                ctx.stroke();
            });
        }

        function drawShieldDrones() {
            shieldDrones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;
                
                // Drone body
                ctx.fillStyle = '#999999';
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2);
                ctx.fill();

                // Health bar for shield drone
                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 5;
                const currentHealthWidth = (drone.health / player.stats.shieldDroneHealth) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = '#00FF00'; // Green health bar
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);

                // Shield aura
                const auraOpacity = 0.3 + 0.2 * Math.sin(survivalTime * 15);
                ctx.strokeStyle = `rgba(0, 255, 255, ${auraOpacity})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.8, 0, Math.PI * 2);
                ctx.stroke();
            });
        }
        
        function drawUltimateEffect() {
            ctx.beginPath();
            const pulseSize = player.size * (1 + 0.5 * Math.sin(survivalTime * 10));
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.arc(screenX, screenY, pulseSize * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.5 * (1 - ultimateDuration/5)})`;
            ctx.lineWidth = 10;
            ctx.stroke();

            ctx.fillStyle = `rgba(255, 102, 0, ${0.1 * (1 - ultimateDuration/5)})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            
            // Format survivalTime to MM:SS
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60);
            const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            timeDisplay.textContent = `Time: ${formattedTime}`;

            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
            ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;

            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateButton.classList.add('ready');
            } else {
                ultimateButton.classList.remove('ready');
            }
        }
        
        function showDamageNumber(damage, x, y) {
            damageNumbers.push({
                x: x,
                y: y,
                text: Math.round(damage),
                lifetime: 1
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const screenX = d.x - camera.x;
                const screenY = d.y - camera.y;
                ctx.fillStyle = `rgba(255, 50, 50, ${d.lifetime})`;
                ctx.font = `14px 'Chakra Petch'`;
                ctx.textAlign = 'center';
                ctx.fillText(d.text, screenX, screenY);
            });
        }

        function drawStartMenu() {
            startMenu.style.display = 'block';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden
            howToPlayMenu.style.display = 'none'; // Ensure how to play menu is hidden
            powerUpsMenu.style.display = 'none'; // Ensure power ups menu is hidden
        }
        
        function drawGameOverMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'block';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden
            howToPlayMenu.style.display = 'none'; // Ensure how to play menu is hidden
            powerUpsMenu.style.display = 'none'; // Ensure power ups menu is hidden
        }
        
        function updatePlayer(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            let currentProjectileSpeedModifier = 1;
            let currentPlayerSpeedModifier = 1;

            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1; // Enemies move at 10% speed (90% slowdown)
                currentPlayerSpeedModifier = 7.5; // Player moves at 75% of normal speed (0.1 * 7.5 = 0.75)
                currentProjectileSpeedModifier = 7.5; // Player projectiles move at 75% of normal speed
            }
            
            // Apply current global speed multiplier to deltaTime
            const effectiveDt = dt * currentGlobalSpeedMultiplier; 

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            player.isMoving = distance > 5;
            if (player.isMoving) {
                const angle = Math.atan2(dy, dx);
                const currentSpeed = player.speed * currentPlayerSpeedModifier;
                player.vx = Math.cos(angle) * currentSpeed;
                player.vy = Math.sin(angle) * currentSpeed;
            } else {
                player.vx = 0; // Reset velocity if not actively moving
                player.vy = 0; // Reset velocity if not actively moving
            }

            // Calculate potential new position
            let newX = player.x + player.vx * effectiveDt;
            let newY = player.y + player.vy * effectiveDt;

            // Create a temporary object for collision checking and resolution
            let tempPlayer = {
                x: newX,
                y: newY,
                size: player.size,
                vx: player.vx,
                vy: player.vy
            };
            
            // Resolve collisions with obstacles
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'pillar') {
                    // Pillar is treated as a circle for collision
                    let pillarCircle = {
                        x: obstacle.x,
                        y: obstacle.y,
                        size: obstacle.width // obstacle.width is its diameter
                    };
                    circleCircleCollideAndResolve(tempPlayer, pillarCircle);
                } else { // desk or chair (rectangle)
                    circleRectCollideAndResolve(tempPlayer, obstacle);
                }
            });

            // Apply resolved position and velocity back to player
            player.x = tempPlayer.x;
            player.y = tempPlayer.y;
            player.vx = tempPlayer.vx; 
            player.vy = tempPlayer.vy;

            // Boundary checks (applied after collision resolution)
            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
            
            // Animation frame update
            if (player.isMoving) {
                player.animationFrame = (player.animationFrame + effectiveDt * 10) % 4;
            } else {
                player.animationFrame = 0;
            }
        
            player.health += player.stats.healthRegen * effectiveDt;
            player.health = Math.min(player.health, player.maxHealth);
        
            // Uzi Spiral Attack (replaces Circular Wave) - Fibonacci Spiral with spray
            if (keys.e && player.stats.uziDamage > 0 && player.uziTimer <= 0) {
                const numProjectiles = player.stats.uziNumProjectiles;
                const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // Golden angle for Fibonacci spiral
                const baseAngle = Math.random() * Math.PI * 2; // Start at a random angle for visual variety

                for (let i = 0; i < numProjectiles; i++) {
                    // Apply Fibonacci spiral and add a random spray based on uziSpiralFactor
                    const sprayOffset = (Math.random() - 0.5) * player.stats.uziSpiralFactor;
                    const currentAngle = baseAngle + (i * goldenAngle) + sprayOffset; 
                    
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(currentAngle) * player.stats.uziProjectileSpeed * currentProjectileSpeedModifier,
                        vy: Math.sin(currentAngle) * player.stats.uziProjectileSpeed * currentProjectileSpeedModifier,
                        size: 4, // Uzi bullets are small
                        damage: player.stats.uziDamage,
                        color: ultimateActive ? '#00FFFF' : '#00AAFF', // Blueish color for Uzi
                        pierce: 0, // Uzi bullets don't pierce by default, can be upgraded
                        hits: 0,
                        isBazooka: false,
                        isShotgun: false,
                        lifetime: 0.8 // Uzi bullets have a moderate lifetime
                    });
                }
                player.uziTimer = player.uziCooldown;
                playSound('playerShot'); // Use playerShot sound for Uzi
            }

            // Flamethrower
            if (player.upgrades.flamethrower > 0) {
                player.flamethrowerTimer += effectiveDt;
                if (player.flamethrowerTimer >= player.flamethrowerCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angleToEnemy = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        enemies.forEach(enemy => {
                            const angleFromPlayerToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                            const distanceToEnemy = dist(player, enemy);

                            // Check if enemy is within range and arc
                            // Normalize angles to be within a consistent range (e.g., -PI to PI)
                            let normalizedAngleToEnemy = angleToEnemy;
                            let normalizedAngleFromPlayerToEnemy = angleFromPlayerToEnemy;

                            if (normalizedAngleToEnemy - normalizedAngleFromPlayerToEnemy > Math.PI) normalizedAngleFromPlayerToEnemy += 2 * Math.PI;
                            if (normalizedAngleToEnemy - normalizedAngleFromPlayerToEnemy < -Math.PI) normalizedAngleFromPlayerToEnemy -= 2 * Math.PI;

                            if (distanceToEnemy <= player.stats.flamethrowerRange &&
                                Math.abs(normalizedAngleToEnemy - normalizedAngleFromPlayerToEnemy) < player.stats.flamethrowerArc / 2) {
                                enemy.health -= player.stats.flamethrowerDamage * effectiveDt * 5; // Continuous damage
                                showDamageNumber(player.stats.flamethrowerDamage * effectiveDt * 5, enemy.x, enemy.y);
                                playSound('enemyHit');
                            }
                        });
                    }
                    player.flamethrowerTimer = 0;
                }
            }

            // Laser Beam
            if (player.upgrades.laserBeam > 0) {
                player.laserTimer += effectiveDt;
                if (player.laserTimer >= player.laserCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 1000, // Very fast
                            vy: Math.sin(angle) * 1000,
                            size: 1000, // Length of the laser
                            width: player.stats.laserWidth, // Width of the laser
                            damage: player.stats.laserDamage,
                            color: '#FF00FF', // Pink/Purple for laser
                            pierce: Infinity, // Pierces all enemies
                            hits: 0,
                            isLaser: true,
                            lifetime: 0.1 // Very short lifetime for visual flash
                        });
                        playSound('playerShot'); // Use player shot sound
                    }
                    player.laserTimer = 0;
                }
            }

            // Grenade Launcher
            if (player.upgrades.grenadeLauncher > 0) {
                player.grenadeTimer += effectiveDt;
                if (player.grenadeTimer >= player.grenadeCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 200, // Slower projectile
                            vy: Math.sin(angle) * 200,
                            size: 10, // Grenade size
                            damage: player.stats.grenadeDamage, // Base damage, explosion will use this
                            color: '#666666', // Grey for grenade
                            pierce: 0, // Doesn't pierce, explodes on first hit
                            hits: 0,
                            isGrenade: true,
                            grenadeRadius: player.stats.grenadeRadius,
                            lifetime: 2 // Moderate lifetime
                        });
                        playSound('playerShot'); // Use player shot sound
                    }
                    player.grenadeTimer = 0;
                }
            }

            // Homing Missile
            if (player.upgrades.homingMissile > 0) {
                player.homingTimer += effectiveDt;
                if (player.homingTimer >= player.homingCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * player.stats.homingSpeed * currentProjectileSpeedModifier,
                            vy: Math.sin(angle) * player.stats.homingSpeed * currentProjectileSpeedModifier,
                            size: 8, // Missile size
                            damage: player.stats.homingDamage,
                            color: '#FFD700', // Gold for missile
                            pierce: 0,
                            hits: 0,
                            isHoming: true,
                            turnRate: player.stats.homingTurnRate,
                            lifetime: 3 // Long lifetime
                        });
                        playSound('playerShot'); // Use player shot sound
                    }
                    player.homingTimer = 0;
                }
            }
        
            if (shootTimer >= 1 / player.stats.attackSpeed) {
                const closestEnemy = findClosestEnemy();
                
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    
                    // --- Primary Projectiles ---
                    let primaryMultiShot = player.stats.multiShot;
                    let primaryProjectileSpeed = player.stats.projectileSpeed;
                    let primaryDamage = player.stats.damage;
                    let primaryProjectileSize = 3;
                    let primaryProjectileColor = ultimateActive ? '#ff6600' : '#d1d1d1';
                    let primaryPierce = ultimateActive ? player.stats.pierce + 1 : player.stats.pierce;
                    let primaryIsBazooka = false;
                    let primaryIsPoison = player.upgrades.poisonDarts > 0;
                    let primaryIsCryo = player.upgrades.cryoBlast > 0;
                    let primaryRicochetCount = player.upgrades.ricochetShot > 0 ? player.stats.ricochetCount : 0;

                    // Apply temporary spread gun effect to primary fire
                    if (activeTemporaryEffects.spreadGun) {
                        primaryMultiShot = 5; 
                        primaryProjectileSpeed = 300; 
                        primaryDamage = player.stats.damage * 0.75; 
                    }

                    // Apply Bazooka effect to primary fire
                    if (player.upgrades.bazooka > 0) {
                        primaryProjectileSize = 8; 
                        primaryProjectileColor = '#FF4500'; 
                        primaryIsBazooka = true;
                    }

                    for (let i = 0; i < primaryMultiShot; i++) {
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * primaryProjectileSpeed * currentProjectileSpeedModifier,
                            vy: Math.sin(angle) * primaryProjectileSpeed * currentProjectileSpeedModifier,
                            size: primaryProjectileSize,
                            damage: ultimateActive ? primaryDamage * 3 : primaryDamage,
                            color: primaryProjectileColor,
                            pierce: primaryPierce,
                            hits: 0,
                            isBazooka: primaryIsBazooka,
                            isShotgun: false,
                            isPoison: primaryIsPoison,
                            isCryo: primaryIsCryo,
                            ricochetCount: primaryRicochetCount,
                            lifetime: 1
                        });
                    }

                    // --- Shotgun Projectiles (if upgraded) ---
                    if (player.upgrades.shotgun > 0) {
                        const shotgunProjectilesCount = player.stats.shotgunProjectiles;
                        const shotgunSpreadAngle = player.stats.shotgunSpread;
                        const shotgunDamage = player.stats.damage * 0.5; // Base damage for shotgun pellet
                        const shotgunProjectileSize = 5;
                        const shotgunProjectileSpeed = 500; // Shotgun projectiles are faster
                        const shotgunPierce = 0; // Shotgun pellets typically don't pierce
                        const shotgunIsPoison = player.upgrades.poisonDarts > 0;
                        const shotgunIsCryo = player.upgrades.cryoBlast > 0;
                        const shotgunRicochetCount = player.upgrades.ricochetShot > 0 ? player.stats.ricochetCount : 0;


                        for (let i = 0; i < shotgunProjectilesCount; i++) {
                            const spread = (i - (shotgunProjectilesCount - 1) / 2) * shotgunSpreadAngle; 
                            const projectileAngle = angle + spread;
                            
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * shotgunProjectileSpeed * currentProjectileSpeedModifier,
                                vy: Math.sin(projectileAngle) * shotgunProjectileSpeed * currentProjectileSpeedModifier,
                                size: shotgunProjectileSize,
                                damage: ultimateActive ? shotgunDamage * 3 : shotgunDamage,
                                color: '#FFFFFF', // Shotgun projectiles are white
                                pierce: shotgunPierce,
                                hits: 0,
                                isBazooka: false,
                                isShotgun: true,
                                isPoison: shotgunIsPoison,
                                isCryo: shotgunIsCryo,
                                ricochetCount: shotgunRicochetCount,
                                lifetime: 0.3 // Shotgun projectiles have a shorter lifetime
                            });
                        }
                    }
                    playSound('playerShot'); 
                }
                shootTimer = 0;
            }

            // --- Burst Shot Fire (if upgraded, on its own timer) ---
            if (player.stats.burstDamage > 0 && player.burstTimer >= player.burstCooldown) {
                const numProjectiles = player.stats.burstProjectileCount;
                const angleStep = (Math.PI * 2) / numProjectiles;
                const burstIsPoison = player.upgrades.poisonDarts > 0;
                const burstIsCryo = player.upgrades.cryoBlast > 0;
                const burstRicochetCount = player.upgrades.ricochetShot > 0 ? player.stats.ricochetCount : 0;

                for (let i = 0; i < numProjectiles; i++) {
                    const currentAngle = i * angleStep;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(currentAngle) * player.stats.projectileSpeed * currentProjectileSpeedModifier,
                        vy: Math.sin(currentAngle) * player.stats.projectileSpeed * currentProjectileSpeedModifier,
                        size: 3,
                        damage: player.stats.burstDamage,
                        color: ultimateActive ? '#ff6600' : '#d1d1d1',
                        pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                        hits: 0,
                        isBazooka: false,
                        isShotgun: false,
                        isPoison: burstIsPoison,
                        isCryo: burstIsCryo,
                        ricochetCount: burstRicochetCount,
                        lifetime: 1
                    });
                }
                player.burstTimer = 0;
                playSound('playerShot'); 
            }
        }

        function findClosestEnemy() {
            let closest = null;
            let minDistance = Infinity;

            enemies.forEach(enemy => {
                const distance = dist(player, enemy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function activateUltimate() {
            ultimateActive = true;
            ultimateDuration = 5; 
            player.color = '#ff6600'; 
            ultimateCharge = 0;
            playSound('ultimateActivate');
        }
        
        function updateEnemies(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            // Faster enemy appearance
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            // Adjusted spawn rate factor for smoother difficulty build-up (max at 10 mins)
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            const spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0:
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1:
                        x = Math.min(gameWorld.width, camera.x + camera.width + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2:
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height + 50);
                        break;
                    case 3:
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                // --- ENEMY SPAWN LOGIC BASED ON TIME ---
                if (timeInMinutes < 1) { // 0-1 min
                    enemyType = Math.random() < 0.8 ? 'basic' : 'tank';
                } else if (timeInMinutes < 3) { // 1-3 min
                    const rand = Math.random();
                    if (rand < 0.6) enemyType = 'basic';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'fast'; // Introduce fast enemies
                } else if (timeInMinutes < 5) { // 3-5 min
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'tank';
                    else if (rand < 0.85) enemyType = 'fast';
                    else enemyType = 'gunner'; // Introduce gunners
                } else if (timeInMinutes < 7) { // 5-7 min
                    const rand = Math.random();
                    if (rand < 0.2) enemyType = 'basic';
                    else if (rand < 0.4) enemyType = 'tank';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.75) enemyType = 'gunner';
                    else if (rand < 0.85) enemyType = 'drone'; // Introduce drones (exploders)
                    else enemyType = 'car'; // Introduce cars (exploders)
                } else if (timeInMinutes < 10) { // 7-10 min
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.2) enemyType = 'fast';
                    else if (rand < 0.3) enemyType = 'gunner';
                    else if (rand < 0.45) enemyType = 'tank';
                    else if (rand < 0.6) enemyType = 'drone';
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite'; // Introduce elite
                    else enemyType = 'ninja'; // Introduce ninja
                } else if (timeInMinutes < 12) { // 10-12 min
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast';
                    else if (rand < 0.25) enemyType = 'gunner';
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone';
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.7) enemyType = 'elite';
                    else if (rand < 0.8) enemyType = 'ninja';
                    else enemyType = 'snake'; // Introduce snake
                } else { // 12-15+ min (all types, higher density/difficulty)
                    const rand = Math.random();
                    if (rand < 0.03) enemyType = 'basic';
                    else if (rand < 0.13) enemyType = 'fast';
                    else if (rand < 0.23) enemyType = 'gunner';
                    else if (rand < 0.33) enemyType = 'tank';
                    else if (rand < 0.48) enemyType = 'drone';
                    else if (rand < 0.63) enemyType = 'car';
                    else if (rand < 0.78) enemyType = 'elite';
                    else if (rand < 0.88) enemyType = 'ninja';
                    else enemyType = 'snake';
                }
                // --- END ENEMY SPAWN LOGIC ---
                
                const newEnemy = {
                    x: x,
                    y: y,
                    type: enemyType,
                    controlled: false,
                    shootTimer: 0,
                    flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                    vx: 0, 
                    vy: 0, 
                    isPoisoned: false, // New: Poison status
                    poisonTimer: 0,
                    poisonTickTimer: 0,
                    isSlowed: false, // New: Slow status
                    slowTimer: 0,
                    originalSpeed: 0, // Store original speed for slow effect
                    ...getEnemyStats(enemyType)
                };
            
                enemies.push(newEnemy);
                spawnTimer = 0;
            }
        
            enemies = enemies.filter(enemy => {
                // Update poison effect
                if (enemy.isPoisoned) {
                    enemy.poisonTimer -= effectiveDt;
                    enemy.poisonTickTimer += effectiveDt;
                    if (enemy.poisonTickTimer >= player.stats.poisonTickRate) {
                        enemy.health -= player.stats.poisonDamage;
                        showDamageNumber(player.stats.poisonDamage, enemy.x, enemy.y);
                        playSound('enemyHit');
                        enemy.poisonTickTimer = 0;
                    }
                    if (enemy.poisonTimer <= 0) {
                        enemy.isPoisoned = false;
                    }
                }

                // Update slow effect
                if (enemy.isSlowed) {
                    enemy.slowTimer -= effectiveDt;
                    if (enemy.slowTimer <= 0) {
                        enemy.isSlowed = false;
                        enemy.speed = enemy.originalSpeed; // Restore original speed
                    }
                }

                let angle;
                if (enemy.controlled) {
                    const closestEnemy = enemies
                        .filter(e => !e.controlled)
                        .sort((a, b) => dist(enemy, a) - dist(enemy, b))[0];
                    if (closestEnemy) {
                        angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - closestEnemy.x);
                    } else {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        // Controlled enemy stays on screen if no targets
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    }
                } else { 
                    const distance = dist(player, enemy);
                    
                    // Exploding enemies (car, drone)
                    if ((enemy.type === 'car' || enemy.type === 'drone') && distance < enemy.explosionTriggerDistance) {
                        explosions.push({
                            x: enemy.x,
                            y: enemy.y,
                            radius: 0,
                            maxRadius: enemy.explosionRadius,
                            damage: enemy.explosionDamage,
                            speed: 400,
                            lifetime: 0.2,
                            hitEnemies: new Set()
                        });
                        playSound('explosion');
                        enemy.health = 0; // Mark for removal
                        return false; // Remove immediately
                    }
                    
                    // Shooter enemies (gunner, fast)
                    if ((enemy.type === 'gunner' || enemy.type === 'fast') && distance < enemy.attackRange) {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.shootTimer += effectiveDt; 
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * enemy.projectileSpeed,
                                vy: Math.sin(angle) * enemy.projectileSpeed,
                                size: enemy.projectileSize, // Use enemy's specific projectile size
                                damage: enemy.projectileDamage,
                                color: enemy.projectileColor, // Use enemy's specific projectile color
                                hits: 0
                            });
                            enemy.shootTimer = 0;
                        }
                        enemy.vx = 0; // Shooter enemy stops when attacking
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        
                        if (enemy.type !== 'gunner' && Math.random() < 0.01) { 
                            enemy.flankAngle = (Math.random() - 0.5) * Math.PI / 2;
                        }
                        if (enemy.flankAngle !== undefined) {
                            angle += enemy.flankAngle;
                        }
                    }
                }

                // Calculate enemy's desired velocity
                let currentEnemySpeed = enemy.speed;
                if (enemy.isSlowed) {
                    currentEnemySpeed *= (1 - player.stats.cryoSlowAmount); // Apply slow effect
                }
                enemy.vx = Math.cos(angle) * currentEnemySpeed;
                enemy.vy = Math.sin(angle) * currentEnemySpeed;

                // For snake enemy, constrain movement to horizontal
                if (enemy.type === 'snake') {
                    // Only move horizontally towards player's X, or reverse if at bounds
                    if (enemy.x < player.x) enemy.vx = Math.abs(enemy.vx);
                    else enemy.vx = -Math.abs(enemy.vx);
                    enemy.vy = 0; // No vertical movement
                    
                    // Simple boundary check for snake to reverse direction
                    if (enemy.x <= 0 || enemy.x >= gameWorld.width) {
                        enemy.vx *= -1; // Reverse horizontal direction
                    }
                }

                // Create a temporary object for collision checking and resolution
                let tempEnemy = {
                    x: enemy.x + enemy.vx * effectiveDt, 
                    y: enemy.y + enemy.vy * effectiveDt, 
                    size: enemy.size,
                    vx: enemy.vx,
                    vy: enemy.vy
                };

                // Resolve collisions with obstacles
                obstacles.forEach(obstacle => {
                    if (obstacle.type === 'pillar') {
                        let pillarCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                        circleCircleCollideAndResolve(tempEnemy, pillarCircle);
                    } else {
                        circleRectCollideAndResolve(tempEnemy, obstacle);
                    }
                });

                // Apply resolved position and velocity back to enemy
                enemy.x = tempEnemy.x;
                enemy.y = tempEnemy.y;
                enemy.vx = tempEnemy.vx; 
                enemy.vy = tempEnemy.vy;

                // Boundary checks for enemies
                enemy.x = Math.max(-100, Math.min(gameWorld.width + 100, enemy.x)); // Increased boundary for enemies
                enemy.y = Math.max(-100, Math.min(gameWorld.height + 100, enemy.y));
        
                return enemy.x > -150 && enemy.x < gameWorld.width + 150 && // Filter out further off-screen
                       enemy.y > -150 && enemy.y < gameWorld.height + 150;
            });
        }
        
        function updateProjectiles(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            projectiles = projectiles.filter(p => {
                // Homing missile logic
                if (p.isHoming) {
                    const closestEnemy = findClosestEnemy(); // Find closest enemy for homing
                    if (closestEnemy) {
                        const angleToEnemy = Math.atan2(closestEnemy.y - p.y, closestEnemy.x - p.x);
                        const currentAngle = Math.atan2(p.vy, p.vx);
                        let angleDiff = angleToEnemy - currentAngle;

                        // Normalize angle difference to be between -PI and PI
                        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        const turnAmount = p.turnRate * effectiveDt;
                        let newAngle = currentAngle;
                        if (Math.abs(angleDiff) > turnAmount) {
                            newAngle += Math.sign(angleDiff) * turnAmount;
                        } else {
                            newAngle = angleToEnemy;
                        }

                        const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        p.vx = Math.cos(newAngle) * speed;
                        p.vy = Math.sin(newAngle) * speed;
                    }
                }

                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 
                
                // Decrease lifetime for all projectiles, especially shotgun
                p.lifetime -= effectiveDt; 

                // Ricochet logic
                if (p.ricochetCount > 0) {
                    let bounced = false;
                    if (p.x - p.size < 0 || p.x + p.size > gameWorld.width) {
                        p.vx *= -1;
                        bounced = true;
                    }
                    if (p.y - p.size < 0 || p.y + p.size > gameWorld.height) {
                        p.vy *= -1;
                        bounced = true;
                    }
                    if (bounced) {
                        p.ricochetCount--;
                    }
                }

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && p.hits <= p.pierce && p.lifetime > 0;
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100;
            });
        }
        
        function updatePowerups(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            powerups = powerups.filter(p => {
                const distance = dist(player, p);
                if (distance < player.stats.magnet) {
                    const angle = Math.atan2(player.y - p.y, player.x - p.x);
                    p.x += Math.cos(angle) * p.speed * effectiveDt; 
                    p.y += Math.sin(angle) * p.speed * effectiveDt; 
                }
                return true;
            });
        }

        function updateChests(dt) {
            chests = chests.filter(chest => {
                // Chests don't move, just check collision
                return true;
            });
        }
        
        // Removed updateWaveAttacks as it's replaced by Uzi projectiles
        // function updateWaveAttacks(dt) { ... }

        function updateDamageNumbers(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            damageNumbers = damageNumbers.filter(d => {
                d.y -= 20 * effectiveDt; 
                d.lifetime -= effectiveDt; 
                return d.lifetime > 0;
            });
        }

        // New function to update spinning knives position and properties
        function updateSpinningKnivesEffect() {
            // Clear existing knives and recreate based on upgrade level
            spinningKnives = [];
            const numKnives = player.stats.spinningKnivesCount;
            const radius = player.size * 2; // Orbit radius
            const knifeSize = 5;
            const knifeDamage = player.stats.spinningKnivesDamage;
            const rotationSpeed = 5; // How fast they orbit

            for (let i = 0; i < numKnives; i++) {
                spinningKnives.push({
                    angle: (Math.PI * 2 / numKnives) * i, // Initial angle
                    radius: radius,
                    size: knifeSize,
                    damage: knifeDamage,
                    rotationSpeed: rotationSpeed,
                    hitEnemies: new Set() // Track enemies hit per cycle
                });
            }
        }

        function updateDroneCount() {
            // Remove excess drones if level decreased (shouldn't happen in this game)
            while (drones.length > player.stats.friendlyDrones) {
                drones.pop();
            }
            // Add new drones if needed
            while (drones.length < player.stats.friendlyDrones) {
                drones.push({
                    x: player.x,
                    y: player.y,
                    size: 15, // Drone size
                    speed: player.speed * 0.8, // Drones move slightly slower than player
                    damage: player.stats.droneDamage,
                    attackSpeed: player.stats.droneAttackSpeed,
                    shootTimer: Math.random() * (1 / player.stats.droneAttackSpeed), // Stagger initial shots
                    angleOffset: Math.random() * Math.PI * 2, // For orbiting
                    orbitRadius: 50 + drones.length * 10 // Vary orbit radius for multiple drones
                });
            }
            // Update existing drone stats
            drones.forEach(drone => {
                drone.damage = player.stats.droneDamage;
                drone.attackSpeed = player.stats.droneAttackSpeed;
            });
        }

        function updateDrones(dt) { // Renamed from updateFriendlyDog
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            drones.forEach(drone => {
                // Drone orbits player
                drone.angleOffset += effectiveDt * 2; // Orbit speed
                drone.x = player.x + Math.cos(drone.angleOffset) * drone.orbitRadius;
                drone.y = player.y + Math.sin(drone.angleOffset) * drone.orbitRadius;

                // Drone attacks enemies
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    drone.shootTimer += effectiveDt;
                    if (drone.shootTimer >= 1 / drone.attackSpeed) {
                        const angle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                        projectiles.push({
                            x: drone.x,
                            y: drone.y,
                            vx: Math.cos(angle) * 500, // Drone projectile speed
                            vy: Math.sin(angle) * 500,
                            size: 5,
                            damage: drone.damage,
                            color: '#00FFFF', // Drone projectile color
                            pierce: 0,
                            hits: 0,
                            isBazooka: false,
                            isShotgun: false,
                            lifetime: 1
                        });
                        drone.shootTimer = 0;
                        playSound('playerShot'); // Use playerShot sound for drone bullets
                    }
                }
            });
        }

        function updateShieldDroneCount() {
            // Remove excess drones if level decreased (shouldn't happen)
            while (shieldDrones.length > player.stats.shieldDroneCount) {
                shieldDrones.pop();
            }
            // Add new drones if needed
            while (shieldDrones.length < player.stats.shieldDroneCount) {
                shieldDrones.push({
                    x: player.x,
                    y: player.y,
                    size: 20, // Shield drone size
                    health: player.stats.shieldDroneHealth,
                    maxHealth: player.stats.shieldDroneHealth,
                    angleOffset: Math.random() * Math.PI * 2, // For orbiting
                    orbitRadius: 70 + shieldDrones.length * 15 // Vary orbit radius
                });
            }
            // Update existing drone stats
            shieldDrones.forEach(drone => {
                drone.maxHealth = player.stats.shieldDroneHealth;
                drone.health = Math.min(drone.health, drone.maxHealth); // Cap health
            });
        }

        function updateShieldDrones(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier;

            shieldDrones.forEach(drone => {
                // Drone orbits player
                drone.angleOffset += effectiveDt * 1.5; // Orbit speed
                drone.x = player.x + Math.cos(drone.angleOffset) * drone.orbitRadius;
                drone.y = player.y + Math.sin(drone.angleOffset) * drone.orbitRadius;
            });
        }


        function updateExplosions(dt) {
            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            explosions = explosions.filter(explosion => {
                explosion.radius += explosion.speed * effectiveDt;
                explosion.lifetime -= effectiveDt;
                return explosion.lifetime > 0;
            });
        }

        function updateElectricArcs(dt) {
            electricArcs = electricArcs.filter(arc => {
                arc.lifetime -= dt;
                return arc.lifetime > 0;
            });
        }
        
        function checkCollisions() {
            enemies.forEach(enemy => {
                if (!enemy.controlled) {
                    // Melee collision for basic, tank, car, ninja, snake
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2) && 
                        (enemy.type === 'basic' || enemy.type === 'tank' || enemy.type === 'car' || enemy.type === 'ninja' || enemy.type === 'snake')) {
                        let damageTaken = enemy.damage;
                        // Reduce damage by 50% if ultimate is active or invincibility is active
                        if (ultimateActive || activeTemporaryEffects.invincibility) { // Check for invincibility
                            damageTaken *= 0.5; // Still take half damage if invincible, or full immunity? Let's say half.
                        }
                        damageTaken = Math.max(0, damageTaken - player.stats.defense * 10);
                        player.health -= damageTaken;
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
        
            // Iterate backwards to safely remove projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    if (!enemy.controlled && dist(p, enemy) < (p.size + enemy.size / 2)) {
                        // NEW: Shotgun specific range/lifetime check for damage
                        if (p.isShotgun) {
                            // Shotgun projectiles only deal damage if their lifetime is above a very small threshold
                            // This simulates pellets losing effectiveness quickly.
                            if (p.lifetime <= 0.05) { // If lifetime is too low, it has dissipated
                                p.hits = p.pierce + 1; // Mark it as having hit max targets so it's removed
                                continue; // Skip to next enemy for this projectile
                            }
                        }
                        
                        // Grenade explosion logic
                        if (p.isGrenade) {
                            explosions.push({
                                x: p.x,
                                y: p.y,
                                radius: 0,
                                maxRadius: p.grenadeRadius,
                                damage: p.damage,
                                speed: 400,
                                lifetime: 0.2,
                                hitEnemies: new Set()
                            });
                            playSound('explosion');
                            projectiles.splice(i, 1); // Remove grenade projectile
                            projectileRemoved = true;
                            break; // Break inner loop, move to next projectile
                        }

                        // Apply damage
                        let damageDealt = p.damage;
                        if (activeTemporaryEffects.damageBoost) {
                            damageDealt *= 2; // Double damage if boost is active
                        }
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        playSound('enemyHit'); 
                        p.hits++;

                        // Vampiric Rounds effect
                        if (player.upgrades.vampiricRounds > 0) {
                            player.health += damageDealt * player.stats.vampiricHealPercent;
                            player.health = Math.min(player.health, player.maxHealth);
                        }

                        // Poison Darts effect
                        if (p.isPoison) {
                            enemy.isPoisoned = true;
                            enemy.poisonTimer = player.stats.poisonDuration;
                            enemy.poisonTickTimer = 0;
                        }

                        // Cryo Blast effect
                        if (p.isCryo && !enemy.isSlowed) { // Only apply if not already slowed
                            enemy.isSlowed = true;
                            enemy.slowTimer = player.stats.cryoSlowDuration;
                            enemy.originalSpeed = enemy.speed; // Store original speed
                            enemy.speed *= (1 - player.stats.cryoSlowAmount); // Apply slow
                        }

                        // Electric Arc effect
                        if (player.upgrades.electricArc > 0) {
                            let chainedEnemies = [enemy];
                            let currentTarget = enemy;
                            for (let k = 0; k < player.stats.electricChainCount; k++) {
                                const nearbyUnchainedEnemies = enemies.filter(e => 
                                    !e.controlled && 
                                    !chainedEnemies.includes(e) && 
                                    dist(currentTarget, e) < player.stats.electricChainRange
                                ).sort((a,b) => dist(currentTarget, a) - dist(currentTarget, b));

                                if (nearbyUnchainedEnemies.length > 0) {
                                    const nextTarget = nearbyUnchainedEnemies[0];
                                    nextTarget.health -= player.stats.electricDamage;
                                    ultimateCharge += ultimateChargePerHit;
                                    showDamageNumber(player.stats.electricDamage, nextTarget.x, nextTarget.y);
                                    playSound('enemyHit');
                                    electricArcs.push({
                                        x1: currentTarget.x, y1: currentTarget.y,
                                        x2: nextTarget.x, y2: nextTarget.y,
                                        lifetime: 0.1
                                    });
                                    chainedEnemies.push(nextTarget);
                                    currentTarget = nextTarget;
                                } else {
                                    break;
                                }
                            }
                        }

                        if (p.isBazooka) {
                            // Create explosion
                            explosions.push({
                                x: p.x,
                                y: p.y,
                                radius: 0,
                                maxRadius: player.stats.bazookaRadius,
                                damage: player.stats.bazookaDamage,
                                speed: 400, // Speed of explosion expansion
                                lifetime: 0.2, // How long the explosion lasts
                                hitEnemies: new Set()
                            });
                            playSound('explosion');
                        }
        
                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            if (Math.random() < 0.1) {
                                spawnPowerup(enemy.x, enemy.y);
                            }
                            if (enemy.type === 'elite') {
                                enemies.push(createControlledEnemy(enemy.x, enemy.y));
                            }
                            enemies.splice(j, 1); // Remove defeated enemy
                        }

                        if (p.hits > p.pierce && !p.isLaser && p.ricochetCount <= 0) { // Laser always pierces, ricochet handled separately
                            projectiles.splice(i, 1);
                            projectileRemoved = true;
                            break; // Break inner loop, move to next projectile
                        }
                    }
                }
            }

            // Enemy projectiles colliding with player or shield drones
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                let hitShieldDrone = false;

                // Check collision with shield drones first
                for (let k = shieldDrones.length - 1; k >= 0; k--) {
                    const drone = shieldDrones[k];
                    if (dist(drone, p) < (drone.size / 2 + p.size / 2)) {
                        drone.health -= p.damage; // Shield drone takes damage
                        showDamageNumber(p.damage, drone.x, drone.y);
                        playSound('enemyHit'); // Sound for drone hit
                        enemyProjectiles.splice(i, 1); // Remove enemy projectile
                        hitShieldDrone = true;
                        if (drone.health <= 0) {
                            shieldDrones.splice(k, 1); // Remove drone if destroyed
                            updateShieldDroneCount(); // Re-evaluate drone count
                        }
                        break; // Stop checking other drones for this projectile
                    }
                }

                if (hitShieldDrone) continue; // If hit a drone, move to next enemy projectile

                // If not hit by a shield drone, check player collision
                if (ultimateActive || activeTemporaryEffects.invincibility) { // Check for invincibility
                    // If invincible, ignore collision with enemy projectiles
                    if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                        enemyProjectiles.splice(i, 1); // Remove enemy projectile
                    }
                } else if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    let damageTaken = p.damage;
                    damageTaken = Math.max(0, damageTaken - player.stats.defense * 10);
                    player.health -= damageTaken;
                    if (player.health <= 0) {
                        gameOver();
                    }
                    enemyProjectiles.splice(i, 1); // Remove enemy projectile
                }
            }

            // Spinning knives collision with enemies
            spinningKnives.forEach(knife => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !knife.hitEnemies.has(enemy) && dist(knife, enemy) < (knife.size + enemy.size / 2)) {
                        const damageDealt = knife.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        playSound('enemyHit');
                        knife.hitEnemies.add(enemy); // Mark enemy as hit by this knife in this cycle

                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            if (Math.random() < 0.1) {
                                spawnPowerup(enemy.x, enemy.y);
                            }
                            if (enemy.type === 'elite') {
                                enemies.push(createControlledEnemy(enemy.x, enemy.y));
                            }
                            // Enemy removed in the outer filter loop
                        }
                    }
                });
                // Reset hit enemies for the next update cycle
                knife.hitEnemies.clear();
            });
        
            enemies.forEach(controlledEnemy => {
                if (controlledEnemy.controlled) {
                    enemies.forEach(targetEnemy => {
                        if (!targetEnemy.controlled && controlledEnemy !== targetEnemy) {
                            if (dist(controlledEnemy, targetEnemy) < (controlledEnemy.size / 2 + targetEnemy.size / 2)) {
                                targetEnemy.health -= controlledEnemy.damage;
                                showDamageNumber(controlledEnemy.damage, targetEnemy.x, targetEnemy.y);
                                playSound('enemyHit'); 
                                if (targetEnemy.health <= 0) {
                                    gainXp(targetEnemy.xp);
                                    score += 10;
                                    if (Math.random() < 0.1) {
                                        spawnPowerup(targetEnemy.x, targetEnemy.y);
                                    }
                                }
                            }
                        }
                    });
                }
            });

            // Explosion collision with enemies
            explosions.forEach(explosion => {
                enemies.forEach(enemy => {
                    // Check if enemy is within explosion radius and hasn't been hit by this explosion yet
                    if (!enemy.controlled && dist(explosion, enemy) < explosion.radius + enemy.size / 2 && !explosion.hitEnemies.has(enemy)) {
                        const damageDealt = explosion.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        playSound('enemyHit'); 
                        explosion.hitEnemies.add(enemy); // Mark enemy as hit by this explosion

                        if (enemy.health <= 0) {
                            gainXp(enemy.xp);
                            score += 10;
                            if (Math.random() < 0.1) {
                                spawnPowerup(enemy.x, enemy.y);
                            }
                            if (enemy.type === 'elite') {
                                enemies.push(createControlledEnemy(enemy.x, enemy.y));
                            }
                            // Enemy removed in the outer filter loop
                        }
                    }
                });
            });
        
            powerups.forEach(p => {
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    gainXp(p.xpValue);
                    powerups = powerups.filter(item => item !== p);
                }
            });

            // Chest collision
            for (let i = chests.length - 1; i >= 0; i--) {
                const chest = chests[i];
                if (dist(player, chest) < (player.size / 2 + chest.size / 2)) {
                    // Pass the specific powerupType from the chest
                    activateTemporaryPowerup(chest.powerupType); 
                    chests.splice(i, 1);
                }
            }
        
            enemies = enemies.filter(enemy => enemy.health > 0);
        }
        
        function spawnEnemy() {
            // Spawn rate adjustments
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            // Adjusted spawn rate factor for smoother difficulty build-up (max at 10 mins)
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            const spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0:
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1:
                        x = Math.min(gameWorld.width, camera.x + camera.width + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2:
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height + 50);
                        break;
                    case 3:
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                // --- ENEMY SPAWN LOGIC BASED ON TIME ---
                if (timeInMinutes < 1) { // 0-1 min
                    enemyType = Math.random() < 0.8 ? 'basic' : 'tank';
                } else if (timeInMinutes < 3) { // 1-3 min
                    const rand = Math.random();
                    if (rand < 0.6) enemyType = 'basic';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'fast'; // Introduce fast enemies
                } else if (timeInMinutes < 5) { // 3-5 min
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'tank';
                    else if (rand < 0.85) enemyType = 'fast';
                    else enemyType = 'gunner'; // Introduce gunners
                } else if (timeInMinutes < 7) { // 5-7 min
                    const rand = Math.random();
                    if (rand < 0.2) enemyType = 'basic';
                    else if (rand < 0.4) enemyType = 'tank';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.75) enemyType = 'gunner';
                    else if (rand < 0.85) enemyType = 'drone'; // Introduce drones (exploders)
                    else enemyType = 'car'; // Introduce cars (exploders)
                } else if (timeInMinutes < 10) { // 7-10 min
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.2) enemyType = 'fast';
                    else if (rand < 0.3) enemyType = 'gunner';
                    else if (rand < 0.45) enemyType = 'tank';
                    else if (rand < 0.6) enemyType = 'drone';
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite'; // Introduce elite
                    else enemyType = 'ninja'; // Introduce ninja
                } else if (timeInMinutes < 12) { // 10-12 min
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast';
                    else if (rand < 0.25) enemyType = 'gunner';
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone';
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.7) enemyType = 'elite';
                    else if (rand < 0.8) enemyType = 'ninja';
                    else enemyType = 'snake'; // Introduce snake
                } else { // 12-15+ min (all types, higher density/difficulty)
                    const rand = Math.random();
                    if (rand < 0.03) enemyType = 'basic';
                    else if (rand < 0.13) enemyType = 'fast';
                    else if (rand < 0.23) enemyType = 'gunner';
                    else if (rand < 0.33) enemyType = 'tank';
                    else if (rand < 0.48) enemyType = 'drone';
                    else if (rand < 0.63) enemyType = 'car';
                    else if (rand < 0.78) enemyType = 'elite';
                    else if (rand < 0.88) enemyType = 'ninja';
                    else enemyType = 'snake';
                }
                // --- END ENEMY SPAWN LOGIC ---
                
                const newEnemy = {
                    x: x,
                    y: y,
                    type: enemyType,
                    controlled: false,
                    shootTimer: 0,
                    flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                    vx: 0, 
                    vy: 0, 
                    isPoisoned: false, // New: Poison status
                    poisonTimer: 0,
                    poisonTickTimer: 0,
                    isSlowed: false, // New: Slow status
                    slowTimer: 0,
                    originalSpeed: 0, // Store original speed for slow effect
                    ...getEnemyStats(enemyType)
                };
            
                enemies.push(newEnemy);
                spawnTimer = 0;
            }
        }
        
        function getEnemyStats(type) {
            const base = {
                size: 25, speed: 30, health: 50, damage: 10, xp: 10,
                projectileSize: 8, projectileDamage: 15, projectileColor: '#FF4500', // Default projectile stats
                explosionTriggerDistance: 70, explosionDamage: 100, explosionRadius: 80 // Default explosion stats
            };
        
            switch (type) {
                case 'fast':
                    base.size = 20; base.speed = 50; base.health = 30; base.xp = 15; base.color = '#ff4444';
                    base.attackRange = 200; base.attackSpeed = 2; base.projectileSpeed = 150; // Slower projectiles
                    break;
                case 'tank':
                    base.size = 40; base.speed = 15; base.health = 200; base.xp = 50; base.color = '#9966ff';
                    break;
                case 'elite':
                    base.size = 30; base.speed = 40; base.health = 500; base.damage = 20; base.xp = 200; base.color = '#ff0000';
                    break;
                case 'gunner':
                    base.size = 25; base.speed = 20; base.health = 40; base.damage = 0; base.xp = 20; base.color = '#3399ff';
                    base.attackRange = 400; base.attackSpeed = 1; base.projectileSpeed = 100; // Slower projectiles
                    break;
                case 'drone':
                    base.size = 15; base.speed = 40; base.health = 20; base.xp = 12; base.color = '#888888';
                    base.damage = 0; // Drones don't melee, they explode
                    base.explosionTriggerDistance = 50; // Smaller trigger distance for drones
                    base.explosionDamage = 50; // Less damage than car
                    base.explosionRadius = 60;
                    break;
                case 'car':
                    base.size = 50; base.speed = 70; base.health = 300; base.damage = 0; base.xp = 75; base.color = '#663300';
                    base.explosionTriggerDistance = 100; // Larger trigger distance for cars
                    base.explosionDamage = 150; // More damage
                    base.explosionRadius = 100;
                    break;
                case 'ninja':
                    base.size = 22; base.speed = 80; base.health = 60; base.damage = 15; base.xp = 30; base.color = '#333333';
                    break;
                case 'snake': // New snake enemy
                    base.size = 20; // Represents segment height/width
                    base.segmentCount = 5; // Number of segments
                    base.speed = 60; // Moderate speed
                    base.health = 80;
                    base.damage = 12; // Melee damage
                    base.xp = 25;
                    base.color = '#4CAF50'; // Greenish-brown for snake
                    break;
                default: // basic enemy
                    base.color = '#777777';
                    break;
            }
            
            // Smoother difficulty scaling
            const healthScale = 1 + Math.pow(survivalTime / 60, 0.5); 
            const damageScale = 1 + Math.pow(survivalTime / 90, 0.4); 
            const speedScale = 1 + Math.min(survivalTime / 180, 1.5); 

            base.health *= healthScale;
            base.damage *= damageScale;
            base.speed *= speedScale;
            // XP gain reduced by 50% (0.5 multiplier)
            base.xp = Math.floor(base.xp * ((healthScale + damageScale) / 2) * 0.5); 

            if (type === 'gunner' || type === 'fast') { 
                base.projectileDamage *= damageScale;
                base.attackSpeed *= (1 + Math.min(survivalTime / 180, 1));
            }
            if (type === 'car' || type === 'drone') {
                base.explosionDamage *= damageScale;
            }

            return base;
        }

        function createControlledEnemy(x, y) {
            const baseStats = getEnemyStats('basic');
            return {
                x: x, y: y, type: 'basic', controlled: true,
                size: baseStats.size, speed: baseStats.speed * 1.5,
                health: baseStats.health * 2, damage: baseStats.damage * 2,
                color: '#00ff66',
                vx: 0, 
                vy: 0, 
            };
        }
        
        function spawnPowerup(x, y) {
            powerups.push({
                x: x, y: y, size: 10, color: '#FFD700', speed: 300, 
                // XP value reduced by 50% (0.5 multiplier)
                xpValue: Math.floor((20 + Math.floor(Math.random() * 30)) * 0.5)
            });
        }

        function spawnChest() {
            const x = Math.random() * gameWorld.width;
            const y = Math.random() * gameWorld.height;
            // Removed friendlyDrone from chest powerup options
            const powerupChoices = ['spreadGun', 'extremeBulletTime', 'experience', 'invincibility', 'damageBoost']; 
            const chosenPowerup = powerupChoices[Math.floor(Math.random() * powerupChoices.length)];

            chests.push({
                x: x, y: y, size: 30, type: 'chest', powerupType: chosenPowerup
            });
        }

        // Modified to accept a specific powerup type
        function activateTemporaryPowerup(chosenPowerup) {
            console.log(`Activating temporary powerup: ${chosenPowerup}`);
            // Set the end time for the chosen power-up
            activeTemporaryEffects[chosenPowerup] = { endTime: survivalTime + 5 }; // All temporary power-ups now last 5 seconds

            switch (chosenPowerup) {
                case 'spreadGun':
                    // Effect handled in updatePlayer
                    break;
                case 'extremeBulletTime':
                    // Effect handled in updatePlayer/updateEnemies
                    break;
                case 'experience':
                    gainXp(100); // Give a fixed XP boost
                    break;
                case 'invincibility':
                    player.color = '#00FF00'; // Green tint for invincibility
                    break;
                case 'damageBoost':
                    // Effect handled in checkCollisions
                    break;
            }
        }

        // Modified to deactivate a specific powerup type
        function deactivateTemporaryPowerup(powerupType) {
            console.log(`Deactivating temporary powerup: ${powerupType}`);
            delete activeTemporaryEffects[powerupType]; // Remove from active effects

            switch (powerupType) {
                case 'extremeBulletTime':
                    // No explicit reset needed here as updatePlayer/updateEnemies will check activeTemporaryEffects
                    break;
                case 'invincibility':
                    player.color = '#d1d1d1'; // Reset player color
                    break;
                case 'spreadGun':
                    // No explicit reset needed as updatePlayer handles default multiShot
                    break;
                case 'damageBoost':
                    // No explicit reset needed
                    break;
                case 'experience':
                    // No explicit reset needed
                    break;
            }
        }
        
        function gainXp(amount) {
            player.xp += amount;
        }
        
        function levelUp() {
            player.level++;
            player.xp = player.xp - player.nextLevelXp;
            // Adjusted leveling curve: from 1.8 to 1.5 for a smoother progression
            player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5); 
            player.maxHealth += 10;
            player.health = Math.min(player.health + 10, player.maxHealth);
            playSound('levelUp');
            showPowerSelection();
        }
        
        function showPowerSelection() {
            gameRunning = false;
            messageBox.style.display = 'block';
            powerSelectionDiv.innerHTML = '';
        
            const availablePowers = POWER_OPTIONS.filter(p => player.upgrades[p.id] < MAX_UPGRADE_LEVEL);
            const selectedPowers = [];
        
            const existingUpgrades = availablePowers.filter(p => player.upgrades[p.id] > 0);
            const newUpgrades = availablePowers.filter(p => player.upgrades[p.id] === 0);

            for (let i = 0; i < Math.min(2, existingUpgrades.length); i++) {
                const randomIndex = Math.floor(Math.random() * existingUpgrades.length);
                selectedPowers.push(existingUpgrades[randomIndex]);
                existingUpgrades.splice(randomIndex, 1);
            }

            while(selectedPowers.length < 3 && newUpgrades.length > 0) {
                const randomIndex = Math.floor(Math.random() * newUpgrades.length);
                selectedPowers.push(newUpgrades[randomIndex]);
                newUpgrades.splice(randomIndex, 1);
            }
            
            while(selectedPowers.length < 3 && availablePowers.length > 0) {
                const randomIndex = Math.floor(Math.random() * availablePowers.length);
                selectedPowers.push(availablePowers[randomIndex]);
                availablePowers.splice(randomIndex, 1);
            }

            selectedPowers.forEach(power => {
                const card = document.createElement('div');
                card.className = 'power-card';
                card.innerHTML = `
                    <h4>${power.name} <span>Lvl ${power.level() + 1}</span></h4>
                    <p>${power.next()}</p>
                `;
                card.addEventListener('click', () => selectPower(power));
                powerSelectionDiv.appendChild(card);
            });
        }
        
        function selectPower(power) {
            power.effect();
            player.upgrades[power.id]++;
            messageBox.style.display = 'none';
            gameRunning = true;
            lastTime = performance.now(); 
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            powerups.length = 0;
            damageNumbers.length = 0;
            spinningKnives = []; 
            chests = []; // Reset chests
            drones = []; // Reset friendly drones
            explosions = []; // Reset explosions
            electricArcs = []; // Reset electric arcs
            shieldDrones = []; // Reset shield drones
            
            survivalTime = 0;
            shootTimer = 0;
            spawnTimer = 0;
            gameSpeedMultiplier = 1; // Reset global speed multiplier
            playerSpeedModifier = 1; // Reset player speed modifier
            projectileSpeedModifier = 1; // Reset projectile speed multiplier
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            activeTemporaryEffects = {}; // Reset active temporary effects
            chestSpawnTimer = 0;

            // Re-setup audio (only sound effects remain)
            setupAudio();
        }

        function handleRetry() {
            startGame();
        }

        function updateCamera() {
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;

            camera.x = Math.max(0, Math.min(camera.x, gameWorld.width - camera.width));
            camera.y = Math.max(0, Math.min(camera.y, gameWorld.height - camera.height));
        }

        function togglePause() {
            gameRunning = !gameRunning;
            if (gameRunning) {
                pauseButton.textContent = "Pause";
                lastTime = performance.now(); // Reset lastTime to prevent large deltaTime on resume
                requestAnimationFrame(gameLoop);
            } else {
                pauseButton.textContent = "Resume";
            }
        }

        // New: Function to open the game menu
        function openGameMenu() {
            wasGameRunningBeforeMenu = gameRunning; // Store current game running state
            gameRunning = false; // Pause the game
            gameMenu.style.display = 'block'; // Show the game menu
            howToPlayMenu.style.display = 'none'; // Ensure how to play menu is hidden
            powerUpsMenu.style.display = 'none'; // Ensure power ups menu is hidden
        }

        // New: Function to close the game menu
        function closeGameMenu() {
            gameMenu.style.display = 'none'; // Hide the game menu
            if (wasGameRunningBeforeMenu) { // Resume game only if it was running before
                gameRunning = true;
                lastTime = performance.now(); // Reset lastTime to prevent large deltaTime on resume
                requestAnimationFrame(gameLoop);
            }
        }

        // New: Function to open How to Play menu
        function openHowToPlayMenu() {
            gameRunning = false; // Pause game
            gameMenu.style.display = 'none'; // Hide main game menu
            howToPlayMenu.style.display = 'block'; // Show How to Play menu
        }

        // New: Function to close How to Play menu
        function closeHowToPlayMenu() {
            howToPlayMenu.style.display = 'none'; // Hide How to Play menu
            gameMenu.style.display = 'block'; // Show main game menu again
        }

        // New: Function to open Power Ups menu
        function openPowerUpsMenu() {
            gameRunning = false; // Pause game
            gameMenu.style.display = 'none'; // Hide main game menu
            powerUpsMenu.style.display = 'block'; // Show Power Ups menu
            populatePowerUpsList(); // Populate the list when opened
        }

        // New: Function to close Power Ups menu
        function closePowerUpsMenu() {
            powerUpsMenu.style.display = 'none'; // Hide Power Ups menu
            gameMenu.style.display = 'block'; // Show main game menu again
        }

        // New: Function to dynamically populate the Power Ups list
        function populatePowerUpsList() {
            powerUpsListDiv.innerHTML = ''; // Clear previous content

            POWER_OPTIONS.forEach(power => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'power-up-item';
                itemDiv.innerHTML = `
                    <h4>${power.name}</h4>
                    <p>${power.description}</p>
                    <p>Current Level: ${power.level()}</p>
                    <p>Next Level Effect: ${power.next()}</p>
                `;
                powerUpsListDiv.appendChild(itemDiv);
            });
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning) return;
        
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            survivalTime += deltaTime;
        
            update(deltaTime);
            draw();
        
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            // Update and deactivate temporary power-ups based on real time
            for (const powerupType in activeTemporaryEffects) {
                if (survivalTime >= activeTemporaryEffects[powerupType].endTime) {
                    deactivateTemporaryPowerup(powerupType);
                }
            }

            // Determine effective game speed based on active Bullet Time
            let currentGlobalSpeedMultiplier = 1;
            if (activeTemporaryEffects.extremeBulletTime) {
                currentGlobalSpeedMultiplier = 0.1;
            }
            const effectiveDt = dt * currentGlobalSpeedMultiplier; // Apply game speed multiplier

            shootTimer += effectiveDt;
            spawnTimer += effectiveDt;
            chestSpawnTimer += dt; // Chest timer uses real time

            if (chestSpawnTimer >= CHEST_SPAWN_INTERVAL) {
                spawnChest();
                chestSpawnTimer = 0;
            }

            // Uzi timer update (replaces wave timer)
            if (player.stats.uziDamage > 0) {
                player.uziTimer -= effectiveDt;
            }
            if (player.stats.burstDamage > 0) {
                player.burstTimer += effectiveDt;
            }
            if (player.upgrades.flamethrower > 0) {
                player.flamethrowerTimer += effectiveDt;
            }
            if (player.upgrades.laserBeam > 0) {
                player.laserTimer += effectiveDt;
            }
            if (player.upgrades.grenadeLauncher > 0) {
                player.grenadeTimer += effectiveDt;
            }
            if (player.upgrades.homingMissile > 0) {
                player.homingTimer += effectiveDt;
            }

            // Update spinning knives position (unaffected by bullet time)
            spinningKnives.forEach(knife => {
                knife.angle += knife.rotationSpeed * dt; // Use raw dt for consistent speed
                knife.x = player.x + Math.cos(knife.angle) * knife.radius;
                knife.y = player.y + Math.sin(knife.angle) * knife.radius;
            });

            if (player.xp >= player.nextLevelXp) {
                levelUp();
            }

            if (ultimateActive) {
                ultimateDuration -= effectiveDt;
                if (ultimateDuration <= 0) {
                    ultimateActive = false;
                    player.color = '#d1d1d1';
                    ultimateCharge = 0;
                }
            } else if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += effectiveDt * 5 * (1 + player.upgrades.ultimateRecharge * 0.2); 
                ultimateCharge = Math.min(ultimateCharge, ultimateMaxCharge);
            }

            updatePlayer(dt); // Player update uses real dt for movement input, but internal speed is scaled by effectiveDt
            updateCamera();
            updateEnemies(dt); // Enemies update uses real dt, but their speed is scaled by effectiveDt
            updateProjectiles(dt); // Projectiles update uses real dt, but their speed is scaled by effectiveDt
            updatePowerups(dt); // Powerups update uses real dt, but their speed is scaled by effectiveDt
            updateChests(dt); // Update chests
            updateDrones(dt); // Friendly drone update uses real dt, but its speed is scaled by effectiveDt
            updateShieldDrones(dt); // Update shield drones
            updateExplosions(dt); // Update explosions
            updateElectricArcs(dt); // Update electric arcs
            checkCollisions();
            updateDamageNumbers(dt);
        }
        
        async function gameOver() {
            gameRunning = false;
            playSound('gameOver');
            
            gameOverMenu.style.display = 'block';
            document.getElementById('final-score').textContent = `Score: ${score}`;
            
            // Format survivalTime to MM:SS for game over screen
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60);
            const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('final-time').textContent = `Time Survived: ${formattedTime}`;

            document.getElementById('final-level').textContent = `Level Reached: ${player.level}`;

            const currentHighScores = await window.getHighScoresFirebase();
            const isHighScore = currentHighScores.length < 10 || score > Math.min(...currentHighScores.map(s => s.score));

            if (isHighScore) {
                highScoreModal.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                displayHighScores();
            }
        }

        async function saveAndDisplayHighScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                await window.saveHighScoreFirebase(playerName, score, survivalTime.toFixed(1), player.level);
                highScoreModal.style.display = 'none';
                displayHighScores();
            } else {
                console.warn("Please enter a name to save your high score.");
            }
        }

        async function displayHighScores() {
            const highScores = await window.getHighScoresFirebase();
            highScoresList.innerHTML = '';
            
            if (highScores.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No high scores yet. Be the first!';
                highScoresList.appendChild(li);
                return;
            }

            highScores.forEach((s, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${index + 1}. ${s.name}</span>
                    <span>Score: ${s.score} | Time: ${s.survivalTime}s | Lvl: ${s.level}</span>
                `;
                highScoresList.appendChild(li);
            });
        }
        
        function init() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            camera.width = canvas.width;
            camera.height = canvas.height;
        
            window.addEventListener('resize', () => {
                canvas.width = gameContainer.clientWidth;
                canvas.height = gameContainer.clientHeight;
                camera.width = canvas.width;
                camera.height = canvas.height;
                if (!gameRunning) {
                    drawStartMenu();
                }
            });
        
            document.getElementById('startButton').addEventListener('click', () => {
                // Initialize audio synths once
                setupAudio(); 
                // Start Tone.js audio context and then the game
                Tone.start().then(() => { 
                    startGame();
                });
            });
            document.getElementById('restartButton').addEventListener('click', handleRetry);
            saveScoreButton.addEventListener('click', saveAndDisplayHighScore);
            pauseButton.addEventListener('click', togglePause); // Add event listener for the pause button
            menuButton.addEventListener('click', openGameMenu); // New: Menu button event listener
            restartGameMenuButton.addEventListener('click', () => { // New: Restart button in menu
                closeGameMenu(); // Close menu first
                startGame(); // Then restart game
            });
            closeMenuButton.addEventListener('click', closeGameMenu); // New: Close menu button

            howToPlayButton.addEventListener('click', openHowToPlayMenu); // New: How to Play button listener
            closeHowToPlayButton.addEventListener('click', closeHowToPlayMenu); // New: Close How to Play button listener

            powerUpsButton.addEventListener('click', openPowerUpsMenu); // New: Power Ups button listener
            closePowerUpsButton.addEventListener('click', closePowerUpsMenu); // New: Close Power Ups button listener

            canvas.addEventListener('mousedown', handlePointerEvent);
            canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
            
            function handlePointerEvent(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const inputX = clientX - rect.left;
                const inputY = clientY - rect.top;
                
                player.targetX = camera.x + inputX;
                player.targetY = camera.y + inputY;
            }

            ultimateButton.addEventListener('click', () => {
                if (ultimateCharge >= ultimateMaxCharge && !ultimateActive) {
                    activateUltimate();
                }
            });
        
            document.addEventListener('keydown', (e) => {
                // Ensure e and e.key exist before proceeding
                if (e && e.key !== undefined) {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = true;
                    }
                }
            });
        
            document.addEventListener('keyup', (e) => {
                // Ensure e and e.key exist before proceeding
                if (e && e.key !== undefined) {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = false;
                    }
                }
            });

            generateObstacles();
        
            drawStartMenu();

            if (typeof window.initFirebase === 'function') {
                window.initFirebase();
            } else {
                console.error("Firebase initialization function not found.");
            }
        }

        function generateObstacles() {
            // Clear existing obstacles before generating new ones
            obstacles = []; 

            // Pillars (circular obstacles)
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 50, height: 50, color: '#3c3c3c', type: 'pillar'
                });
            }

            // Desks (rectangular obstacles)
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 200, height: 50, color: '#4d4d4d', type: 'desk'
                });
            }

            // Chairs (smaller rectangular obstacles)
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * gameWorld.width;
                const y = Math.random() * gameWorld.height;
                obstacles.push({
                    x: x, y: y, width: 30, height: 30, color: '#2d2d2d', type: 'chair'
                });
            }
        }
        
        function startGame() {
            gameRunning = true;
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            player.health = 100;
            player.maxHealth = 100;
            player.xp = 0;
            player.level = 1;
            player.nextLevelXp = 100;
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.targetX = player.x;
            player.targetY = player.y;
            player.vx = 0; 
            player.vy = 0; 

            player.stats = {
                damage: 20, attackSpeed: 10, projectileSpeed: 400, pierce: 0, multiShot: 1, 
                healthRegen: 0.1, magnet: 50, defense: 0, 
                uziDamage: 0, uziProjectileSpeed: 0, uziNumProjectiles: 0, uziSpiralFactor: 0, // Reset Uzi stats
                spinningKnivesDamage: 0, spinningKnivesCount: 0, 
                burstDamage: 0, burstProjectileCount: 0,
                bazookaDamage: 0,
                bazookaRadius: 0,
                shotgunProjectiles: 0,
                shotgunSpread: 0,
                friendlyDrones: 0, // Reset drone count
                droneAttackSpeed: 0, // Reset drone attack speed
                droneDamage: 0, // Reset drone damage

                // New Gun Varieties Stats
                flamethrowerDamage: 0,
                flamethrowerRange: 0,
                flamethrowerArc: 0,
                laserDamage: 0,
                laserWidth: 0,
                grenadeDamage: 0,
                grenadeRadius: 0,
                electricDamage: 0,
                electricChainCount: 0,
                electricChainRange: 0,
                poisonDamage: 0,
                poisonDuration: 0,
                poisonTickRate: 0,
                ricochetCount: 0,
                homingDamage: 0,
                homingSpeed: 0,
                homingTurnRate: 0,
                shieldDroneCount: 0,
                shieldDroneHealth: 0,
                vampiricHealPercent: 0,
                cryoSlowAmount: 0,
                cryoSlowDuration: 0
            };
            player.upgrades = {
                damage: 0, attackSpeed: 0, health: 0, speed: 0, pierce: 0, multiShot: 0, 
                healthRegen: 0, magnet: 0, defense: 0, 
                uzi: 0, // Reset Uzi upgrade
                ultimateRecharge: 0, burstShot: 0,
                spinningKnives: 0, bazooka: 0, shotgun: 0, friendlyDrone: 0, // Reset friendly drone upgrade

                // New Gun Varieties Upgrades
                flamethrower: 0,
                laserBeam: 0,
                grenadeLauncher: 0,
                electricArc: 0,
                poisonDarts: 0,
                ricochetShot: 0,
                homingMissile: 0,
                shieldDrone: 0,
                vampiricRounds: 0,
                cryoBlast: 0
            };
            player.uziCooldown = 10; // Reset Uzi cooldown
            player.uziTimer = 0; // Reset Uzi timer
            player.burstCooldown = 1;
            player.burstTimer = 0;
            player.flamethrowerTimer = 0;
            player.laserTimer = 0;
            player.grenadeTimer = 0;
            player.homingTimer = 0;
            ultimateChargePerHit = 0.5; 
            nextPlayerShotTime = 0; // Reset sound timers
            nextEnemyHitTime = 0;


            gameSpeedMultiplier = 1; // Reset global speed multiplier
            playerSpeedModifier = 1; // Reset player speed modifier
            projectileSpeedModifier = 1; // Reset projectile speed multiplier
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            activeTemporaryEffects = {}; // Reset active temporary effects
            chestSpawnTimer = 0;


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            spinningKnives = []; 
            chests = []; // Clear chests
            drones = []; // Clear friendly drones
            explosions = []; // Clear explosions
            electricArcs = []; // Clear electric arcs
            shieldDrones = []; // Clear shield drones
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            messageBox.style.display = 'none';
            highScoreModal.style.display = 'none';
            gameMenu.style.display = 'none'; // Ensure game menu is hidden at start
            howToPlayMenu.style.display = 'none'; // Ensure how to play menu is hidden at start
            powerUpsMenu.style.display = 'none'; // Ensure power ups menu is hidden at start
            pauseButton.textContent = "Pause"; // Ensure pause button text is "Pause" at start
        
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    </script>
</body>
</html>
