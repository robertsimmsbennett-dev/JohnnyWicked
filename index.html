<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Johnny Wicked Survivors</title>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            color: #d1d1d1;
            font-family: 'Chakra Petch', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            user-select: none; /* Prevent text selection on touch */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Remove tap highlight on iOS */
            flex-direction: column; /* For better mobile layout */
        }
        
        #gameContainer {
            position: relative;
            width: 900px; /* Base width */
            height: 700px; /* Base height */
            background: #0a0a0a;
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;

            /* Responsive adjustments for gameContainer */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 95vh; /* Max height relative to viewport */
            aspect-ratio: 9 / 7; /* Maintain aspect ratio */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
            width: 100%; /* Make canvas fill its container */
            height: 100%; /* Make canvas fill its container */
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            border: 1px solid #333;
        }
        
        /* Top Left Controls: Score and Pause Button */
        #top-left-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: all; /* Allow interaction */
        }

        /* Bottom Left Controls: Time, Menu, and Level */
        #bottom-left-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: all; /* Allow interaction */
        }

        #score-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between score and pause button */
        }
        
        /* Time display now part of bottom-left-controls */
        #time-display {
            position: static; /* Remove absolute positioning from here */
            margin-bottom: 5px; /* Space between time and menu button */
            display: block; /* Ensure it's visible */
        }
        
        #level-display {
            position: static; /* Remove absolute positioning from here */
            /* No margin-bottom needed as it's the last item */
        }
        
        #xp-bar-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 7.5px;
            overflow: hidden;
        }
        
        #xp-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #66ccff, #3399ff);
            transition: width 0.2s ease-out;
        }

        #ultimate-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #ultimate-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
        }

        #message-box, .menu, #level-select-menu, #character-select-menu { /* Apply menu styles to message-box, game-menu, level-select-menu, and character-select-menu */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none;
            pointer-events: all;
            z-index: 11; /* Ensure menus are on top */
        }
        
        #power-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .power-card, .character-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 160px; /* Reduced width */
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: left;
            pointer-events: all;
        }
        
        .power-card:hover, .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .power-card h4, .character-card h3 {
            margin-top: 0;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
        }
        
        .power-card p, .character-card p {
            font-size: 0.8em;
            margin-bottom: 0;
        }

        /* General menu button styles */
        .menu button, .control-button, #level-select-menu button, #character-select-menu button { 
            background: linear-gradient(45deg, #ff0000, #990000);
            color: #d1d1d1;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }
        
        .menu button:hover, .control-button:hover, #level-select-menu button:hover, #character-select-menu button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.6);
        }

        /* Specific styles for the new control buttons */
        #pauseButton, #menuButton, #muteMusicButton, #resumeFromMenuButton, #backToMainMenuButtonFromGame { 
            padding: 8px 15px; /* Smaller padding for control buttons */
            font-size: 1em; /* Smaller font size */
            margin-top: 0; /* Remove top margin */
            background: linear-gradient(45deg, #007bff, #0056b3); /* Blue gradient */
            box-shadow: 0 3px 10px rgba(0, 123, 255, 0.4);
        }

        #pauseButton:hover, #menuButton:hover, #muteMusicButton:hover, #resumeFromMenuButton:hover, #backToMainMenuButtonFromGame:hover {
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.6);
        }

        #ultimate-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
            transition: all 0.3s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        #ultimate-button.ready {
            background: linear-gradient(45deg, #ffcc00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            transform: scale(1);
            opacity: 1;
        }

        .damage-number {
            position: absolute;
            color: #ff0000;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
            animation: fadeOutUp 1s forwards;
            pointer-events: none;
        }

        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Particle effect styles */
        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8); /* White with some transparency */
            border-radius: 50%; /* Make them circular */
            pointer-events: none; /* Do not block mouse events */
            animation: fadeOutAndShrink 0.8s forwards; /* Animation for fading and shrinking */
        }

        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0);
            }
        }

        #high-score-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #high-score-modal input {
            background-color: #1a1a1a;
            border: 1px solid #00ffff;
            color: #d1d1d1;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            width: 80%;
            max-width: 250px;
            font-family: 'Chakra Petch', monospace;
            font-size: 1em;
        }

        #high-score-modal button {
            background: linear-gradient(45deg, #00ffff, #009999);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Chakra Petch', monospace;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        #high-score-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        #high-scores-list, #start-menu-high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #high-scores-list li, #start-menu-high-scores-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #high-scores-list li:last-child, #start-menu-high-scores-list li:last-child {
            border-bottom: none;
        }
        #high-scores-list li span, #start-menu-high-scores-list li span {
            color: #00ffff;
            font-weight: bold;
        }

        /* Level Select Menu Styles */
        .level-card {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 15px;
            width: 250px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            pointer-events: all;
            margin-bottom: 15px; /* Space between cards */
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card.locked:hover {
            transform: none;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .level-card h3 {
            margin-top: 0;
            color: #00ffff;
            font-size: 1.5em;
        }

        .level-card p {
            font-size: 1em;
            margin-bottom: 5px;
        }

        .level-card .unlock-info {
            color: #ffdd00;
            font-size: 0.8em;
            font-weight: bold;
        }

        /* Mini-map styles */
        #miniMapContainer {
            position: absolute;
            top: 10px;
            right: 10px; /* Position in top right */
            width: 150px; /* Fixed width */
            height: 150px; /* Fixed height to make it square */
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            pointer-events: none; /* Only for display, not interaction */
        }

        #miniMapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    
/* Knife icon update pending: replace with SVG or better representation */</style>
</head>
<body>
<div id="gameContainer">
<canvas id="gameCanvas"></canvas>
<div id="ui">
<!-- Top Left Controls: Score and Pause Button -->
<div id="top-left-controls">
<div class="hud-item" id="score-display">Score: 0</div>
<button class="control-button" id="pauseButton">Pause</button>
</div>
<!-- Bottom Left Controls: Time, Menu, and Level -->
<div id="bottom-left-controls">
<div class="hud-item" id="time-display">Time: 0s</div>
<button class="control-button" id="menuButton">Menu</button>
<div class="hud-item" id="level-display">Level: 1</div>
</div>
<!-- Mini-map container -->
<div id="miniMapContainer">
<canvas id="miniMapCanvas"></canvas>
</div>
<div id="xp-bar-container"><div id="xp-bar"></div></div>
<div id="ultimate-bar-container"><div id="ultimate-bar"></div></div>
<button id="ultimate-button">Wicked Mode</button>
</div>
<div class="menu" id="start-menu">
<h1>JOHNNY WICKED SURVIVORS</h1>
<p>Click or tap anywhere to move. Your character will fire automatically.</p>
<p>New: Enemies can now shoot back! Be careful of the gunmen.</p>
<button id="startButton">Start Game</button>
<button id="levelSelectButton">Level Select</button>
<h3>Global High Scores</h3>
<ul id="start-menu-high-scores-list">
<!-- High scores will be loaded here -->
</ul>
</div>
<div class="menu" id="game-over-menu" style="display: none;">
<h1>GAME OVER</h1>
<h2 id="final-score">Score: 0</h2>
<h2 id="final-time">Time Survived: 0s</h2>
<h2 id="final-level">Level Reached: 1</h2>
<h3>High Scores</h3>
<ul id="high-scores-list">
<!-- High scores will be loaded here -->
</ul>
<button id="restartButton">Restart Game</button>
<button id="backToMainMenuButtonGameOver">Return to Main Menu</button> <!-- New button -->
</div>
<div class="menu" id="message-box" style="display: none;">
<h3 id="message-title">Level Up!</h3>
<p id="message-text">Choose your power-up:</p>
<div id="power-selection"></div>
</div>
<!-- Game Menu -->
<div class="menu" id="game-menu" style="display: none;">
<h1>Game Menu</h1>
<button class="control-button" id="muteMusicButton">Mute Music</button>
<button class="control-button" id="resumeFromMenuButton">Resume Game</button>
<button class="control-button" id="backToMainMenuButtonFromGame">Back to Main Menu</button>
</div>
<div id="high-score-modal" style="display: none;">
<h3>New High Score!</h3>
<p>Enter your name:</p>
<input id="playerNameInput" maxlength="15" placeholder="Your Name" type="text"/>
<button id="saveScoreButton">Save Score</button>
</div>
<!-- Level Select Menu -->
<div class="menu" id="level-select-menu" style="display: none;">
<h1>Select Level</h1>
<div id="level-options">
<!-- Levels will be dynamically loaded here -->
</div>
<button id="backToMainMenuButton">Back</button>
</div>
<!-- Character Select Menu -->
<div class="menu" id="character-select-menu" style="display: none;">
<h1>Select Your Survivor</h1>
<div id="character-options" style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-top: 20px;">
<div class="character-card" data-character="johnny">
<h3>Johnny Wicked</h3>
<p>Classic survivor, balanced abilities.</p>
<p>Starting Weapon: Pistol</p>
</div>
<div class="character-card" data-character="dixie">
<h3>Dixie</h3>
<p>Dog whisperer, commands loyal companions.</p>
<p>Starting Weapon: Twin Uzis + 1 Dog Ally</p>
</div>
</div>
<button id="backToStartMenuFromCharSelect">Back</button>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<!-- Firebase SDKs -->
<script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in init function)
        window.fb = {};

        window.initFirebase = async function() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing. High score system will not function.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            window.fb.db = getFirestore(app);
            window.fb.auth = getAuth(app);
            window.fb.appId = appId; // Store appId for later use

            // Sign in anonymously if no custom token is provided
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(window.fb.auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await signInAnonymously(window.fb.auth);
                    console.log("Signed in anonymously instead.");
                }
            } else {
                await signInAnonymously(window.fb.auth);
                console.log("Signed in anonymously.");
            }

            // Listen for auth state changes to ensure user is ready
            onAuthStateChanged(window.fb.auth, (user) => {
                if (user) {
                    window.fb.userId = user.uid;
                    console.log("Firebase user ready:", window.fb.userId);
                    // Load user's level scores once authenticated
                    window.loadUserLevelScore('hotel_lobby').then(score => {
                        window.highestHotelLobbyScore = score;
                        console.log("Loaded highest Hotel Lobby score:", window.highestHotelLobbyScore);
                    });
                    // Load 'the_park' score
                    window.loadUserLevelScore('the_park').then(score => {
                        window.highestTheParkScore = score;
                        console.log("Loaded highest The Park score:", window.highestTheParkScore);
                    });
                    // Display high scores on start menu after Firebase is initialized
                    window.displayHighScores('start-menu-high-scores-list');
                } else {
                    console.log("Firebase user not signed in.");
                    window.fb.userId = null; // Ensure userId is null if not authenticated
                }
            });
        };

        window.saveHighScoreFirebase = async function(name, score, time, level, levelId) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated.");
                return;
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.fb.appId}/public/data/highScores`);
            try {
                console.log(`[Firebase Save] Attempting to save score for name: ${name}, score: ${score}, levelId: ${levelId}`); // Added levelId
                await addDoc(highScoresCollection, {
                    name: name,
                    score: score,
                    survivalTime: time,
                    level: level,
                    levelId: levelId, // Save the level ID
                    timestamp: Date.now(),
                    userId: window.fb.userId
                });
                console.log("High score saved successfully to public high scores!");
            } catch (e) {
                console.error("Error adding document to public high scores: ", e);
            }
        };

        window.getHighScoresFirebase = async function() {
            if (!window.fb.db) {
                console.error("Firestore not initialized.");
                return [];
            }

            const highScoresCollection = collection(window.fb.db, `artifacts/${window.fb.appId}/public/data/highScores`);
            const q = query(highScoresCollection, orderBy("score", "desc"), limit(10));
            
            try {
                const querySnapshot = await getDocs(q);
                const highScores = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    console.log("[Firebase Get] Fetched high score data:", data);
                    highScores.push(data);
                });
                highScores.sort((a, b) => b.score - a.score); // Client-side sort just in case
                return highScores;
            } catch (e) {
                console.error("Error getting documents from public high scores: ", e);
                return [];
            }
        };

        window.saveUserLevelScore = async function(levelId, score) {
            if (!window.fb.db || !window.fb.userId) {
                console.error("Firestore not initialized or user not authenticated for private data.");
                return;
            }

            const userLevelScoreRef = doc(window.fb.db, `artifacts/${window.fb.appId}/users/${window.fb.userId}/levelScores`, levelId);
            try {
                const docSnap = await getDoc(userLevelScoreRef);
                let currentBestScore = 0;
                if (docSnap.exists()) {
                    currentBestScore = docSnap.data().highestScore || 0;
                }

                if (score > currentBestScore) {
                    await setDoc(userLevelScoreRef, { highestScore: score, timestamp: Date.now() });
                    console.log(`User's highest score for ${levelId} updated to ${score}.`);
                    // Update the global variable if it's for hotel lobby
                    if (levelId === 'hotel_lobby') {
                        window.highestHotelLobbyScore = score;
                    } else if (levelId === 'the_park') { // Update for 'the_park'
                        window.highestTheParkScore = score;
                    }
                } else {
                    console.log(`Current score ${score} is not higher than existing best ${currentBestScore} for ${levelId}.`);
                }
            } catch (e) {
                console.error(`Error saving user level score for ${levelId}: `, e);
            }
        };

        window.loadUserLevelScore = async function(levelId) {
            if (!window.fb.db || !window.fb.userId) {
                console.warn("Firestore not initialized or user not authenticated for private data. Returning 0 for level score.");
                return 0;
            }

            const userLevelScoreRef = doc(window.fb.db, `artifacts/${window.fb.appId}/users/${window.fb.userId}/levelScores`, levelId);
            try {
                const docSnap = await getDoc(userLevelScoreRef);
                if (docSnap.exists()) {
                    return docSnap.data().highestScore || 0;
                }
                return 0;
            } catch (e) {
                console.error(`Error loading user level score for ${levelId}: `, e);
            }
        };
    </script>
<script>
        // Get canvas and UI elements from the DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameContainer = document.getElementById('gameContainer');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const messageBox = document.getElementById('message-box');
        const powerSelectionDiv = document.getElementById('power-selection');
        const ultimateButton = document.getElementById('ultimate-button');
        const highScoreModal = document.getElementById('high-score-modal');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const highScoresList = document.getElementById('high-scores-list');
        const startMenuHighScoresList = document.getElementById('start-menu-high-scores-list'); // New element for start menu
        const pauseButton = document.getElementById('pauseButton'); 
        const menuButton = document.getElementById('menuButton');     
        const gameMenu = document.getElementById('game-menu');       
        const muteMusicButton = document.getElementById('muteMusicButton'); 
        const resumeFromMenuButton = document.getElementById('resumeFromMenuButton'); 
        const levelSelectButton = document.getElementById('levelSelectButton'); 
        const levelSelectMenu = document.getElementById('level-select-menu'); 
        const levelOptionsDiv = document.getElementById('level-options'); 
        const backToMainMenuButton = document.getElementById('backToMainMenuButton'); 
        const backToMainMenuButtonFromGame = document.getElementById('backToMainMenuButtonFromGame'); 
        const characterSelectMenu = document.getElementById('character-select-menu'); 
        const characterOptionsDiv = document.getElementById('character-options'); 
        const backToStartMenuFromCharSelect = document.getElementById('backToStartMenuFromCharSelect'); 
        const backToMainMenuButtonGameOver = document.getElementById('backToMainMenuButtonGameOver'); // New button

        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const ultimateBar = document.getElementById('ultimate-bar');

        // Mini-map elements
        const miniMapCanvas = document.getElementById('miniMapCanvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        let miniMapScale = 1; // Will be calculated in init

        // Game state variables
        let gameRunning = false;
        let lastTime = 0;
        let deltaTime = 0;
        let score = 0;
        let survivalTime = 0;
        let ultimateCharge = 0;
        const ultimateMaxCharge = 100;
        let damageNumbers = [];
        let particles = []; 
        let gameWorld = {
            width: 3000, 
            height: 3000 
        };
        let gameSpeedMultiplier = 1; 
        let playerSpeedModifier = 1; 
        let projectileSpeedModifier = 1; 
        let bulletTimeActive = false; 
        let bulletTimeDuration = 0; 
        let spinningKnives = []; 
        
        let randomChestSpawnTimer = 0; 
        const RANDOM_CHEST_SPAWN_INTERVAL = 3; 
        const RANDOM_CHEST_SPAWN_CHANCE = 0.05; 

        let randomHeartSpawnTimer = 0; 
        const HEART_SPAWN_START_TIME = 180; 
        const HEART_SPAWN_INTERVAL = 60; 
        const HEART_SPAWN_CHANCE = 0.2; 

        let chests = []; 
        let drones = []; 
        let boomerangs = []; 

        // Camera for a larger game world
        let camera = {
            x: 0,
            y: 0,
            width: 900,
            height: 700,
            zoom: 0.8 
        };

        // Player object with stats and upgrades
        const initialPlayerX = gameWorld.width / 2;
        const initialPlayerY = gameWorld.height / 2;
        let player = {
            x: initialPlayerX,
            y: initialPlayerY,
            targetX: initialPlayerX,
            targetY: initialPlayerY,
            size: 20,
            color: '#6A808C', 
            baseColor: '#6A808C', 
            speed: 300, 
            health: 100, // This will be set based on character in startGame
            maxHealth: 100, // This will be set based on character in startGame
            xp: 0,
            nextLevelXp: 100,
            level: 1,
            stats: {
                damage: 20,
                attackSpeed: 10, 
                projectileSpeed: 400,
                pierce: 0,
                multiShot: 1,
                healthRegen: 0.1,
                magnet: 160, 
                damageReduction: 0, 
                spinningKnivesDamage: 0, 
                spinningKnivesCount: 0, 
                burstDamage: 0,
                burstProjectileCount: 0,
                droneCount: 0, 
                droneDamage: 0, 
                droneAttackSpeed: 0, 
                shotgunPellets: 0, 
                shotgunDamage: 0, 
                shotgunSpread: 0, 
                dualUziActive: false, 
                dualUziFireRate: 0, 
                dualUziDamage: 0, 
                boomerangDamage: 0, 
                boomerangCount: 0, 
                boomerangCooldown: 4, 
                boomerangRange: 150, 
                boomerangSpeed: 400, 
                burstChargeDamage: 0, 
                burstChargeProjectileCount: 0,
                forcefieldActive: false, 
                forcefieldDamage: 0,     
                forcefieldRadius: 0,     
                leashWhipDamage: 0,      
                knifeDamage: 0, // New: Knife damage
                knifeCount: 0,  // New: Number of knives thrown
                knifeCooldown: 1.5, // New: Cooldown for knife throw
                swordDamage: 0, // New: Sword damage
                swordPierce: 0, // New: Sword pierce
                swordCooldown: 3, // New: Cooldown for sword throw
            },
            upgrades: {
                damage: 0,
                attackSpeed: 0,
                health: 0,
                speed: 0,
                pierce: 0,
                multiShot: 0,
                healthRegen: 0,
                magnet: 0,
                bulletproofSuit: 0, 
                ultimateRecharge: 0,
                burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, 
                shotgun: 0, 
                dualUzi: 0,
                boomerang: 0, 
                burstCharge: 0, 
                forcefield: 0,           
                dogPack: 0,              
                dogBones: 0,             
                leashWhip: 0,            
                dogStrength: 0,          
                dogSpeed: 0,             
                knifeThrow: 0, // New: Knife Throw upgrade level
                swordThrow: 0, // New: Sword Throw upgrade level
            },
            burstChargeCooldown: 5, 
            burstChargeTimer: 0, 
            burstCooldown: 1,
            burstTimer: 0,
            shotgunTimer: 0, 
            dualUziTimer: 0, 
            boomerangTimer: 0, 
            lastX: initialPlayerX,
            lastY: initialPlayerY,
            animationFrame: 0,
            isMoving: false,
            vx: 0, 
            vy: 0, 
            currentShootAngle: 0, 
            forcefieldTimer: 0,      
            forcefieldHitEnemies: new Set(), 
            leashWhipTimer: 0,       
            knifeThrowTimer: 0, // New: Timer for knife throw cooldown
            swordThrowTimer: 0, // New: Timer for sword throw cooldown
            invincible: false, // New: Player invincibility state
            invincibilityTimer: 0, // New: Duration of invincibility
            flashTimer: 0, // New: Timer for player flash effect
            isFlashing: false // New: Flag for flash effect
        };

        // Game control states
        let isPaused = false; 
        let isMenuOpen = false; 
        let isMusicMuted = false; 
        let lastUziSoundTime = 0; 
        const UZI_SOUND_COOLDOWN = 0.05; 
        let levelUpQueue = []; 

        // Level management
        let currentLevelId = 'hotel_lobby'; 
        let highestHotelLobbyScore = 0; 
        let highestTheParkScore = 0; // New: To track score for 'the_park'
        let currentCharacter = 'johnny';

if (currentCharacter === 'dixie') {
    player.level = 3;
    player.upgrades.dualUzi = 1;
    player.stats.dualUziActive = true;
    player.stats.dualUziFireRate = 15;
    player.stats.dualUziDamage = 6.5;
    player.stats.shotgunPellets = 5;
    player.stats.shotgunDamage = 15;
    player.upgrades.shotgun = 1;
    player.upgrades.combatDrone = 1;
    player.stats.droneCount = 1;
    player.stats.droneDamage = 15;
}
; 

        // Dog specific variables (for Dixie)
        let allyDogs = []; 
        let dogProjectileDamage = 0;
        let dogProjectileSpeed = 0;
        const DOG_LEASH_RADIUS = 40; // Dogs stay closer // Increased leash radius for dogs (CHANGED from 120)

        // Enemy and power-up configuration
        const ENEMY_TYPES = ['basic', 'fast', 'tank', 'elite', 'gunner', 'drone', 'car', 'ninja', 'enemyDog', 'enemyDrone', 'cobra', 'robotDrone', 'yellowSkull', 'enforcer']; 
        const MAX_UPGRADE_LEVEL = 8;
        const POWER_OPTIONS = [
{
    id: 'acidAura',
    name: 'Acid Aura',
    description: 'Releases a circular green acid pulse every second around the player.',
    level: () => player.upgrades.acidAura || 0,
    effect: () => {
        const lvl = player.upgrades.acidAura = (player.upgrades.acidAura || 0) + 1;
        player.stats.acidAuraDamage = 20 + lvl * 10;
        player.stats.acidAuraInterval = Math.max(0.4, 1 - lvl * 0.1);
    },
    next: () => `Boost acid pulse damage to ${20 + ((player.upgrades.acidAura || 0) + 1) * 10}. Interval: ${(Math.max(0.4, 1 - ((player.upgrades.acidAura || 0) + 1) * 0.1)).toFixed(1)}s.`,
    characters: ['johnny', 'dixie']
},

            { id: 'damage', name: 'Increase Damage', description: 'Increases projectile damage.',
              level: () => player.upgrades.damage,
              effect: () => player.stats.damage += 10,
              next: () => `Increase projectile damage by 10. (Lvl ${player.upgrades.damage + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'attackSpeed', name: 'Increase Attack Speed', description: 'Increases the number of projectiles fired per second.',
              level: () => player.upgrades.attackSpeed,
              effect: () => player.stats.attackSpeed += 2,
              next: () => `Increase fire rate by 2. (Lvl ${player.upgrades.attackSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'health', name: 'Increase Health', description: 'Increases max health and heals you.', 
              level: () => player.upgrades.health,
              effect: () => { player.maxHealth += 25; player.health = Math.min(player.health + 25, player.maxHealth); },
              next: () => `Increase max health by 25 and heal. (Lvl ${player.upgrades.health + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'speed', name: 'Increase Speed', description: 'Increases player movement speed.',
              level: () => player.upgrades.speed,
              effect: () => player.speed += 50,
              next: () => `Increase speed by 50. (Lvl ${player.upgrades.speed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'pierce', name: 'Pierce Shot', description: 'Your projectiles can hit multiple enemies.',
              level: () => player.upgrades.pierce,
              effect: () => player.stats.pierce++,
              next: () => `Projectiles can hit one more enemy. (Lvl ${player.upgrades.pierce + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'multiShot', name: 'Multi-shot', description: 'Fire multiple projectiles at once.', 
              level: () => player.upgrades.multiShot,
              effect: () => player.stats.multiShot++,
              next: () => `Fire one more projectile per shot. (Lvl ${player.upgrades.multiShot + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'healthRegen', name: 'Health Regen', description: 'Gain passive health regeneration.', 
              level: () => player.upgrades.healthRegen,
              effect: () => player.stats.healthRegen += 0.5,
              next: () => `Increase health regen by 0.5/s. (Lvl ${player.upgrades.healthRegen + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'magnet', name: 'Magnet Range', description: 'Increases the range for collecting XP.',
              level: () => player.upgrades.magnet,
              effect: () => player.stats.magnet += 20,
              next: () => `Increase magnet range by 20. (Lvl ${player.upgrades.magnet + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'bulletproofSuit', name: 'Bulletproof Suit', description: 'Reduces damage taken from all sources.',
              level: () => player.upgrades.bulletproofSuit,
              effect: () => {
                player.upgrades.bulletproofSuit++;
                player.stats.damageReduction = Math.min(0.8, player.upgrades.bulletproofSuit * 0.05); 
              },
              next: () => `Reduce damage taken by ${((player.upgrades.bulletproofSuit + 1) * 5).toFixed(0)}%. (Lvl ${player.upgrades.bulletproofSuit + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'burstCharge', name: 'Burst Charge', description: 'Unleashes a slow, wide arc of projectiles automatically.', 
              level: () => player.upgrades.burstCharge,
              effect: () => { 
                player.upgrades.burstCharge++;
                player.stats.burstChargeDamage = 50 + player.upgrades.burstCharge * 25; 
                player.stats.burstChargeProjectileCount = 5 + player.upgrades.burstCharge * 2;
                player.burstChargeCooldown = Math.max(1, 5 - player.upgrades.burstCharge * 0.5); 
                player.burstChargeTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.burstCharge + 1) * 2} projectiles in a wide arc. Cooldown: ${(Math.max(1, 5 - (player.upgrades.burstCharge + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.burstCharge + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'ultimateRecharge', name: 'Ultimate Recharge Speed', description: 'The ultimate ability recharges faster.',
              level: () => player.upgrades.ultimateRecharge,
              effect: () => ultimateChargePerHit += 0.2,
              next: () => `Ultimate charges faster per hit. (Lvl ${player.upgrades.ultimateRecharge + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'burstShot', name: 'Multi-shot Burst', description: 'Fires a burst of projectiles in a circle.',
              level: () => player.upgrades.burstShot,
              effect: () => {
                player.stats.burstDamage = 10 + player.upgrades.burstShot * 5;
                player.stats.burstProjectileCount = 8 + player.upgrades.burstShot * 2;
                player.burstCooldown = 1 - (player.upgrades.burstShot * 0.1);
              },
              next: () => `Fires a circle of projectiles. (Lvl ${player.upgrades.burstShot + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'spinningKnives', name: 'Spinning Knives', description: 'Summon knives that orbit you, damaging enemies.',
              level: () => player.upgrades.spinningKnives,
              effect: () => {
                player.upgrades.spinningKnives++;
                player.stats.spinningKnivesCount++;
                player.stats.spinningKnivesDamage = 25 + player.upgrades.spinningKnives * 10;
player.stats.spinningKnivesRange = 40 + player.upgrades.spinningKnives * 10;
                updateSpinningKnivesEffect();
              },
              next: () => `Summon ${player.upgrades.spinningKnives + 1} spinning knives (wider orbit). (Lvl ${player.upgrades.spinningKnives + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] 
            },
            { id: 'combatDrone', name: 'Combat Drone', description: 'Summon a drone that fires at enemies. Stacks.',
              level: () => player.upgrades.combatDrone,
              effect: () => {
                player.upgrades.combatDrone++;
                player.stats.droneCount = player.upgrades.combatDrone; 
                player.stats.droneDamage = 10 + player.upgrades.combatDrone * 5; 
                player.stats.droneAttackSpeed = 1 + player.upgrades.combatDrone * 0.2; 
                updateDronesEffect(); 
              },
              next: () => `Summon ${player.upgrades.combatDrone + 1} combat drone(s). (Lvl ${player.upgrades.combatDrone + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'shotgun', name: 'Shotgun', description: 'Fires a spray of powerful, short-range pellets.', 
              level: () => player.upgrades.shotgun,
              effect: () => {
                player.upgrades.shotgun++;
                player.stats.shotgunPellets = 5 + player.upgrades.shotgun * 2;
                player.stats.shotgunDamage = 15 + player.upgrades.shotgun * 5;
                player.stats.shotgunSpread = 0.3; 
                player.shotgunTimer = 0; 
              },
              next: () => `Fires ${5 + (player.upgrades.shotgun + 1) * 2} pellets with a short range. (Lvl ${player.upgrades.shotgun + 1}/${MAX_UPGRADE_LEVEL})`, 
              characters: ['johnny'] 
            },
            { id: 'dualUzi', name: 'Dual Uzis', description: 'Fires two continuous streams of bullets.',
              level: () => player.upgrades.dualUzi,
              effect: () => {
                player.upgrades.dualUzi++;
                player.stats.dualUziActive = true;
                player.stats.dualUziFireRate = 10 + player.upgrades.dualUzi * 5; // Increased fire rate (CHANGED)
                player.stats.dualUziDamage = 8 + player.upgrades.dualUzi * 4; // Increased damage (CHANGED)
                player.dualUziTimer = 0; 
              },
              next: () => `Fires two streams at ${10 + (player.upgrades.dualUzi + 1) * 5} bullets/s. (Lvl ${player.upgrades.dualUzi + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie'] // Added Dixie back here
            },
            { id: 'boomerang', name: 'Boomerang', description: 'Launches a spinning boomerang that hits enemies and returns.',
              level: () => player.upgrades.boomerang,
              effect: () => {
                player.upgrades.boomerang++;
                player.stats.boomerangCount = 1 + Math.floor(player.upgrades.boomerang / 2); 
                player.stats.boomerangDamage = 25 + player.upgrades.boomerang * 10;
                player.stats.boomerangCooldown = Math.max(1, 4 - player.upgrades.boomerang * 0.5); 
              },
              next: () => `Launch ${1 + Math.floor((player.upgrades.boomerang + 1) / 2)} boomerangs. Cooldown: ${(Math.max(1, 4 - (player.upgrades.boomerang + 1) * 0.5)).toFixed(1)}s. (Lvl ${player.upgrades.boomerang + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny'] 
            },
            { id: 'forcefield', name: 'Forcefield', description: 'Creates an energy shield that damages nearby enemies and protects you.',
              level: () => player.upgrades.forcefield,
              effect: () => {
                player.upgrades.forcefield++;
                player.stats.forcefieldActive = true; 
                player.stats.forcefieldDamage = 10 + player.upgrades.forcefield * 8; // Increased base damage and scaling (CHANGED)
                player.stats.forcefieldRadius = 70 + player.upgrades.forcefield * 15; // Increased base radius and scaling (CHANGED)
                player.stats.damageReduction = Math.min(0.8, player.stats.damageReduction + 0.02); 
                player.forcefieldTimer = 0; 
                player.forcefieldHitEnemies.clear(); 
              },
              next: () => `Creates a forcefield (Radius: ${70 + (player.upgrades.forcefield + 1) * 15}, Damage: ${10 + (player.upgrades.forcefield + 1) * 8}). Also increases damage reduction. (Lvl ${player.upgrades.forcefield + 1}/${MAX_UPGRADE_LEVEL})`, // Updated description
              characters: ['johnny', 'dixie'] 
            },
            { id: 'dogPack', name: 'Dog Pack', description: 'Summon an additional loyal dog ally.',
              level: () => player.upgrades.dogPack,
              effect: () => { player.upgrades.dogPack++; addAllyDog(); console.log(`[Dixie] Added dog. Total dogs: ${allyDogs.length}`); },
              next: () => `Summon another dog ally. (Lvl ${player.upgrades.dogPack + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogBones', name: 'Dog Bones', description: 'Your dog allies shoot bone projectiles.',
              level: () => player.upgrades.dogBones,
              effect: () => { 
                player.upgrades.dogBones++; 
                dogProjectileDamage = 10 + player.upgrades.dogBones * 5; 
                dogProjectileSpeed = 300 + player.upgrades.dogBones * 50; 
              },
              next: () => `Dogs shoot bones for ${10 + (player.upgrades.dogBones + 1) * 5} damage. (Lvl ${player.upgrades.dogBones + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'leashWhip', name: 'Leash Whip', description: 'Dixie performs a short-range whip attack.',
              level: () => player.upgrades.leashWhip,
              effect: () => { 
                player.upgrades.leashWhip++; 
                player.stats.leashWhipDamage = 20 + player.upgrades.leashWhip * 10; 
                player.leashWhipCooldown = Math.max(0.5, 2 - player.upgrades.leashWhip * 0.2); 
              },
              next: () => `Unleash a whip dealing ${20 + (player.upgrades.leashWhip + 1) * 10} damage. Cooldown: ${(Math.max(0.5, 2 - (player.upgrades.leashWhip + 1) * 0.2)).toFixed(1)}s. (Lvl ${player.upgrades.leashWhip + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogStrength', name: 'Dog Strength', description: 'Increases the damage of your dog allies.',
              level: () => player.upgrades.dogStrength,
              effect: () => { allyDogs.forEach(dog => dog.damage += 5); }, // Removed player.upgrades.dogStrength++ as it's not needed here
              next: () => `Increase dog melee damage by 5. (Lvl ${player.upgrades.dogStrength + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'dogSpeed', name: 'Dog Speed', description: 'Increases the movement speed of your dog allies.',
              level: () => player.upgrades.dogSpeed,
              effect: () => { allyDogs.forEach(dog => dog.speed += 20); }, // Removed player.upgrades.dogSpeed++ as it's not needed here
              next: () => `Increase dog movement speed by 20. (Lvl ${player.upgrades.dogSpeed + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie'] 
            },
            { id: 'knifeThrow', name: 'Knife Throw', description: 'Throws a sharp knife at the closest enemy.',
              level: () => player.upgrades.knifeThrow,
              effect: () => {
                player.upgrades.knifeThrow++;
                player.stats.knifeDamage = 20 + player.upgrades.knifeThrow * 10;
                player.stats.knifeCount = 1 + Math.floor(player.upgrades.knifeThrow / 2);
                player.stats.knifeCooldown = Math.max(0.5, 1.5 - player.upgrades.knifeThrow * 0.1);
              },
              next: () => `Throws ${1 + Math.floor((player.upgrades.knifeThrow + 1) / 2)} knives for ${20 + (player.upgrades.knifeThrow + 1) * 10} damage. Cooldown: ${(Math.max(0.5, 1.5 - (player.upgrades.knifeThrow + 1) * 0.1)).toFixed(1)}s. (Lvl ${player.upgrades.knifeThrow + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['johnny', 'dixie']
            },
            { id: 'swordThrow', name: 'Sword Throw', description: 'Throws a powerful, piercing sword.',
              level: () => player.upgrades.swordThrow,
              effect: () => {
                player.upgrades.swordThrow++;
                player.stats.swordDamage = 50 + player.upgrades.swordThrow * 20;
                player.stats.swordPierce = 1 + Math.floor(player.upgrades.swordThrow / 2);
                player.stats.swordCooldown = Math.max(1, 3 - player.upgrades.swordThrow * 0.2);
              },
              next: () => `Throws a sword that pierces ${1 + Math.floor((player.upgrades.swordThrow + 1) / 2)} enemies for ${50 + (player.upgrades.swordThrow + 1) * 20} damage. Cooldown: ${(Math.max(1, 3 - (player.upgrades.swordThrow + 1) * 0.2)).toFixed(1)}s. (Lvl ${player.upgrades.swordThrow + 1}/${MAX_UPGRADE_LEVEL})`,
              characters: ['dixie']
            }
        ];
        
        let shootTimer = 0;
        let spawnTimer = 0;
        let ultimateChargePerHit = 0.5; 
        let lastShotSoundTime = 0;
        let lastEnemyHitSoundTime = 0;
        const enemyHitSoundCooldown = 0.05;


        // Tone.js audio setup
        let playerSynth;
        let enemyHitSynth;
        let levelUpSynth;
        let ultimateSynth;
        let gameOverSynth;
        let backgroundMusicSynth;
        let backgroundMusicSequence;
        let bassSynth;
        let bassSequence;
        let explosionSound;

        // Music pattern variables
        const BACKGROUND_MUSIC_PATTERNS = [
            [["C3", "G3"], ["A#3", "F3"], ["C4", "G3"], ["D#4", "A#3"]],
            [["D3", "A3"], ["C4", "G3"], ["D4", "A3"], ["F4", "C4"]],
            [["E3", "B3"], ["D3", "A3"], ["E4", "B3"], ["G4", "D4"]]
        ];
        const BASS_MUSIC_PATTERNS = [
            ["C1", "G0", "C1", "F0"],
            ["D1", "A0", "D1", "G0"],
            ["E1", "B0", "E1", "A0"]
        ];
        let currentMusicPatternIndex = 0;
        let musicPatternTimer = 0;
        const MUSIC_PATTERN_CHANGE_INTERVAL = 20;

        // Helper function to calculate distance
        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // --- New Collision Resolution Functions ---

        // Resolves collision between two circles (e.g., player/enemy and pillar)
        function circleCircleCollideAndResolve(c1, c2) {
            let dx = c1.x - c2.x;
            let dy = c1.y - c2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = c1.size / 2 + c2.size / 2; // c2.size is diameter for pillar, so c2.size/2 is radius

            if (distance < minDistance) {
                if (distance === 0) { // Objects are exactly on top of each other, push randomly to prevent infinite loop
                    c1.x += Math.random() * 0.1 - 0.05;
                    c1.y += Math.random() * 0.1 - 0.05;
                    return true;
                }
                let overlap = minDistance - distance;
                let normalX = dx / distance;
                let normalY = dy / distance;

                // Push c1 out of c2
                c1.x += normalX * overlap;
                c1.y += normalY * overlap;

                // Slide along the surface (project velocity onto tangent)
                let dotProduct = c1.vx * normalX + c1.vy * normalY;
                if (dotProduct < 0) { // Only if moving towards the obstacle
                    c1.vx -= dotProduct * normalX;
                    c1.vy -= dotProduct * normalY;
                }
                return true;
            }
            return false;
        }

        // Resolves collision between a circle and a rectangle (e.g., player/enemy and desk/chair)
        function circleRectCollideAndResolve(circle, rect) {
            // Find the closest point on the rectangle to the center of the circle
            let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

            let dx = circle.x - closestX;
            let dy = circle.y - closestY;
            let distanceSquared = (dx * dx) + (dy * dy);
            let radius = circle.size / 2;

            if (distanceSquared < radius * radius) {
                let distance = Math.sqrt(distanceSquared); // Define distance here
                if (distance === 0) { // Circle center is inside rectangle
                    // Push out along the axis with least penetration
                    let overlapX = Math.min(Math.abs(circle.x - rect.x), Math.abs((rect.x + rect.width) - circle.x));
                    let overlapY = Math.min(Math.abs(circle.y - rect.y), Math.abs((rect.y + rect.height) - circle.y));

                    if (overlapX < overlapY) {
                        circle.x += (circle.x > rect.x + rect.width / 2 ? 1 : -1) * (radius - Math.abs(dx));
                    } else {
                        circle.y += (circle.y > rect.y + rect.height / 2 ? 1 : -1) * (radius - Math.abs(dy));
                    }
                } else {
                    let overlap = radius - distance;
                    let normalX = dx / distance;
                    let normalY = dy / distance;

                    // Push circle out of rectangle
                    circle.x += normalX * overlap;
                    circle.y += normalY * overlap;

                    // Slide along the surface
                    let dotProduct = circle.vx * normalX + circle.vy * normalY;
                    if (dotProduct < 0) { // Only if moving into the obstacle
                        circle.vx -= dotProduct * normalX;
                        circle.vy -= dotProduct * normalY;
                    }
                }
                return true;
            }
            return false;
        }

        // --- End Collision Resolution Functions ---

        // Function to play sound effects
        function playSound(type) {
            // Do not play sounds if music is muted
            if (isMusicMuted && (type === 'playerShot' || type === 'enemyHit' || type === 'levelUp' || type === 'ultimateActivate' || type === 'gameOver' || type === 'explosion')) {
                return;
            }

            switch(type) {
                case 'playerShot':
                    if (playerSynth) playerSynth.triggerAttackRelease("C4", "8n");
                    break;
                case 'enemyHit':
                    if (enemyHitSynth) enemyHitSynth.triggerAttackRelease("16n");
                    break;
                case 'levelUp':
                    if (levelUpSynth) levelUpSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
                    break;
                case 'ultimateActivate':
                    if (ultimateSynth) ultimateSynth.triggerAttackRelease("C3", "2n");
                    break;
                case 'gameOver':
                    if (gameOverSynth) gameOverSynth.triggerAttackRelease("C2", "8n");
                    break;
                case 'explosion':
                    if (explosionSound) explosionSound.triggerAttackRelease("C3", "0.5");
                    break;
            }
        }

        function setupAudio() {
            // Ensure Tone.js is started (audio context is active)
            Tone.start();
            Tone.Transport.bpm.value = 120;

            playerSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            playerSynth.volume.value = -15;

            enemyHitSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1
                }
            }).toDestination();
            enemyHitSynth.volume.value = -10;

            levelUpSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5
                }
            }).toDestination();
            levelUpSynth.volume.value = -5;

            ultimateSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.1, decay: 0.5, sustain: 0.3, release: 1
                }
            }).toDestination();
            ultimateSynth.volume.value = -5;

            gameOverSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth.volume.value = -5;

            backgroundMusicSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
                envelope: {
                    attack: 2, decay: 1, sustain: 0.8, release: 3
                },
                volume: -25.5 
            }).toDestination();

            bassSynth = new Tone.Synth({
                oscillator: { type: "fatsawtooth", count: 4, spread: 40 },
                envelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.8, release: 1.0
                },
                filter: {
                    type: 'lowpass', frequency: 300, Q: 1.5
                },
                filterEnvelope: {
                    attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5, baseFrequency: 200, octaves: 1
                },
                volume: -18.5 
            }).toDestination();

            explosionSound = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001, decay: 0.4, release: 0.2
                },
                harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
            }).toDestination();
            explosionSound.volume.value = -8;

            updateMusicPatterns(0);
        }

        function updateMusicPatterns(patternIndex) {
            // Only create sequences if synths are initialized
            if (!backgroundMusicSynth || !bassSynth) {
                console.warn("Synths not initialized for music patterns.");
                return;
            }

            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); 
                backgroundMusicSequence.dispose();
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); 
                bassSequence.dispose();
            }

            backgroundMusicSequence = new Tone.Sequence((time, note) => {
                backgroundMusicSynth.triggerAttackRelease(note, "2n", time);
            }, BACKGROUND_MUSIC_PATTERNS[patternIndex], "4n");
            backgroundMusicSequence.loop = true;
            backgroundMusicSequence.playbackRate = 1;
            backgroundMusicSequence.humanize = true;

            bassSequence = new Tone.Sequence((time, note) => {
                bassSynth.triggerAttackRelease(note, "2n", time);
            }, BASS_MUSIC_PATTERNS[patternIndex], "2n");
            bassSequence.loop = true;
            bassSequence.playbackRate = 1;
            bassSequence.humanize = true;

            // Only start transport if game is running and not muted/paused
            if (gameRunning && !isPaused && !isMenuOpen && !isMusicMuted) {
                backgroundMusicSequence.start(0);
                bassSequence.start(0);
                Tone.Transport.start(); // Start transport after sequences are set up
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Apply camera zoom to the context
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            
            drawBackground();
            drawObstacles();
            drawProjectiles();
            drawPowerups();
            drawChests(); 
            drawEnemies();
            drawPlayer();
            drawSpinningKnives(); 
            drawAllyDogs(); 
            drawDrones(); 
            drawBoomerangs(); 
            if (ultimateActive) {
                drawUltimateEffect();
            }
            // Draw Forcefield
            if (player.stats.forcefieldActive) {
                drawForcefield();
            }
            drawDamageNumbers();
            drawParticles(); 

            ctx.restore(); 
            drawUI();
            drawMiniMap(); 
        }
        
        function drawBackground() {
            let bgColor;
            let gridColor = '#222222';

            if (currentLevelId === 'hotel_lobby') {
                bgColor = '#101010'; // Dark grey for hotel lobby
            } else if (currentLevelId === 'the_park') {
                bgColor = '#225522'; // Green for park
                gridColor = '#336633';
            } else if (currentLevelId === 'desert_oasis') { // New desert theme
                bgColor = '#C2B280'; // Sandy beige
                gridColor = '#B09F6E'; // Slightly darker sand for grid
            } else {
                bgColor = '#101010'; // Default
            }

            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); 

            const patternSize = 50;
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            const startX = -camera.x % patternSize;
            const startY = -camera.y % patternSize;

            for (let x = startX; x < camera.width / camera.zoom; x += patternSize) {
                for (let y = startY; y < camera.height / camera.zoom; y += patternSize) {
                    ctx.beginPath();
                    ctx.rect(x, y, patternSize, patternSize);
                    ctx.stroke();
                }
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') { // Added cactus
                    ctx.beginPath();
                    ctx.arc(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Draw cactus spikes (simplified)
                    if (obstacle.type === 'cactus') {
                        ctx.fillStyle = '#6B8E23'; // Darker green for spikes
                        ctx.fillRect(obstacle.x - camera.x - obstacle.width * 0.4, obstacle.y - camera.y - obstacle.width * 0.4, obstacle.width * 0.1, obstacle.width * 0.1);
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.3, obstacle.y - camera.y - obstacle.width * 0.3, obstacle.width * 0.1, obstacle.width * 0.1);
                        ctx.fillRect(obstacle.x - camera.x - obstacle.width * 0.2, obstacle.y - camera.y + obstacle.width * 0.3, obstacle.width * 0.1, obstacle.width * 0.1);
                    }
                } else if (obstacle.type === 'desk' || obstacle.type === 'chair' || obstacle.type === 'bush' || obstacle.type === 'bench' || obstacle.type === 'old_car') { // Added old_car
                    ctx.fillRect(obstacle.x - camera.x, obstacle.y - camera.y, obstacle.width, obstacle.height);
                     // Draw car details (simplified)
                    if (obstacle.type === 'old_car') {
                        ctx.fillStyle = '#36454F'; // Dark grey for windows
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.2, obstacle.y - camera.y + obstacle.height * 0.2, obstacle.width * 0.2, obstacle.height * 0.6);
                        ctx.fillRect(obstacle.x - camera.x + obstacle.width * 0.6, obstacle.y - camera.y + obstacle.height * 0.2, obstacle.width * 0.2, obstacle.height * 0.6);
                        ctx.fillStyle = '#111111'; // Black for tires
                        ctx.beginPath();
                        ctx.arc(obstacle.x - camera.x + obstacle.width * 0.15, obstacle.y - camera.y + obstacle.height * 0.9, obstacle.width * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(obstacle.x - camera.x + obstacle.width * 0.85, obstacle.y - camera.y + obstacle.height * 0.9, obstacle.width * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        
        function drawPixelArt(ctx, x, y, spriteName, frame, size, isMoving) {
            const s = size;
            const screenX = x - camera.x;
            const screenY = y - camera.y;
            const currentCharacter = player.character || 'johnny'; // Assuming player.character holds 'johnny' or 'dixie'

            if (spriteName === 'player') {
                // If player is invincible, flash
                if (player.invincible && player.isFlashing) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // White flash
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);

                // Body
                ctx.fillStyle = player.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Legs - dynamic based on movement or character-specific idle pose
                if (isMoving) {
                    const legOffset = Math.sin(frame * 0.5) * s/4; 
                    ctx.fillStyle = player.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    // Acrobatic idle poses
                    ctx.fillStyle = player.color; 
                    if (currentCharacter === 'johnny') {
                        // Johnny's idle pose: one leg slightly bent, ready stance
                        const idleOffset = Math.sin(survivalTime * 2) * s * 0.05; // Subtle bob
                        ctx.fillRect(screenX - s/4, screenY + s + idleOffset, s/4, s); 
                        ctx.fillRect(screenX + s/4, screenY + s - idleOffset, s/4, s); 
                    } else {
                        // Default static pose
                        ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                        ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                    }
                }

                // Arms - dynamic, facing shoot direction
                let armLength = s * 0.8;
                let armWidth = s * 0.3;
                let shoulderXOffset = s * 0.4; 
                let shoulderYOffset = s * 0.5; 

                // Character specific arm adjustments
                if (currentCharacter === 'dixie') {
                    armLength = s * 1.5; 
                    armWidth = s * 0.2; 
                    shoulderXOffset = s * 0.5; 
                    shoulderYOffset = s * 0.6; 
                }

                ctx.fillStyle = player.color; 

                // Draw guns on the ends of arms for Johnny's pistol or Dixie's Uzis if active
                if ((currentCharacter === 'johnny') || (currentCharacter === 'dixie' && player.stats.dualUziActive)) { // Modified condition for Johnny
                    const gunSize = s * 0.4;
                    const gunBarrelLength = s * 0.6;
                    const armBaseOffset = s * 0.2; 
                    const currentArmLength = (currentCharacter === 'johnny' ? s * 0.8 : s * 1.5); // Use Johnny's arm length for his gun

                    // Calculate arm end points for guns
                    const armAngle = player.currentShootAngle;
                    
                    // Determine number of guns and their offsets
                    let gunOffsets = [];
                    if (currentCharacter === 'johnny') {
                        gunOffsets.push(0); // Single gun for Johnny
                    } else if (currentCharacter === 'dixie' && player.stats.dualUziActive) {
                        gunOffsets.push(-armBaseOffset); // Left Uzi
                        gunOffsets.push(armBaseOffset);  // Right Uzi
                    }

                    gunOffsets.forEach(offset => {
                        const armEndX = screenX + Math.cos(armAngle + Math.PI/2) * offset + Math.cos(armAngle) * currentArmLength;
                        const armEndY = screenY + Math.sin(armAngle + Math.PI/2) * offset + Math.sin(armAngle) * currentArmLength;

                        // Draw Arm (simple rect from shoulder to gun)
                        ctx.save();
                        ctx.translate(screenX + Math.cos(armAngle + Math.PI/2) * offset, screenY + Math.sin(armAngle + Math.PI/2) * offset);
                        ctx.rotate(armAngle);
                        ctx.fillRect(0, -armWidth / 2, currentArmLength, armWidth);
                        ctx.restore();

                        // Draw Gun
                        ctx.save();
                        ctx.translate(armEndX, armEndY);
                        ctx.rotate(armAngle);
                        ctx.fillStyle = '#444'; // Gun color
                        ctx.fillRect(0, -gunSize/4, gunBarrelLength, gunSize/2); // Barrel
                        ctx.fillRect(-gunSize/2, -gunSize/2, gunSize, gunSize); // Body of gun
                        ctx.restore();
                    });

                } else {
                    // Default arms if no guns are drawn (e.g., Dixie without Dual Uzis)
                    // Left Arm
                    ctx.save();
                    ctx.translate(screenX - shoulderXOffset, screenY - shoulderYOffset);
                    ctx.rotate(player.currentShootAngle);
                    ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                    ctx.restore();

                    // Right Arm
                    ctx.save();
                    ctx.translate(screenX + shoulderXOffset, screenY - shoulderYOffset);
                    ctx.rotate(player.currentShootAngle);
                    ctx.fillRect(0, -armWidth / 2, armLength, armWidth);
                    ctx.restore();
                }

            } else {
                ctx.fillStyle = '#d1d1d1';
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);
            }
        }

        function drawEnemyPixelArt(ctx, enemy) {
            const s = enemy.size;
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;

            // Draw glowing green aura for allied characters
            if (enemy.controlled) {
                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 
            }

            if (enemy.type === 'robotDrone') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s / 2, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(screenX - s * 0.4, screenY - s * 0.1, s * 0.8, s * 0.2); 
                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.4, s * 0.2, s * 0.8); 
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'yellowSkull') {
                ctx.fillStyle = enemy.color; 
                ctx.beginPath();
                ctx.arc(screenX, screenY - s * 0.5, s * 0.4, 0, Math.PI * 2); 
                ctx.fill();

                ctx.fillStyle = '#000000'; 
                ctx.beginPath();
                ctx.arc(screenX - s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(screenX + s * 0.15, screenY - s * 0.6, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillRect(screenX - s * 0.1, screenY - s * 0.3, s * 0.2, s * 0.1); 
                ctx.fillRect(screenX - s * 0.2, screenY - s * 0.1, s * 0.4, s * 0.05); 
            } else if (enemy.type === 'enforcer') {
                ctx.fillStyle = enemy.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2); 
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(screenX - s*0.6, screenY - s*0.5, s*1.2, s*0.2); 
                ctx.fillRect(screenX - s*0.1, screenY - s*0.8, s*0.2, s*0.4); 
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY - s*0.6, s*0.15, 0, Math.PI * 2); 
                ctx.fill();
            }
            else {
                // Head
                ctx.fillStyle = '#c79b69'; 
                ctx.fillRect(screenX - s/4, screenY - s*1.5, s/2, s/2);
                
                // Body
                ctx.fillStyle = enemy.color; 
                ctx.fillRect(screenX - s/2, screenY - s, s, s*2);

                // Arms (simplified, similar to player)
                ctx.fillRect(screenX - s/2 - s/4, screenY - s, s/4, s); 
                ctx.fillRect(screenX + s/2, screenY - s, s/4, s); 
                
                // Legs (animated, similar to player)
                const isEnemyMoving = Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0;
                if (isEnemyMoving) {
                    const legOffset = Math.sin(enemy.animationFrame * 0.5) * s/4; 
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s + legOffset, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s - legOffset, s/4, s); 
                } else {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/4, screenY + s, s/4, s); 
                    ctx.fillRect(screenX + s/4, screenY + s, s/4, s); 
                }

                if (enemy.type === 'tank') {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                } else if (enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone') { 
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(screenX + s/2, screenY - s/4, s, s/4);
                } else if (enemy.type === 'elite') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, s*0.75, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (enemy.type === 'car') {
                    ctx.fillStyle = '#663300'; 
                    ctx.fillRect(screenX - s/2, screenY - s/4, s, s/2);
                } else if (enemy.type === 'ninja') {
                    ctx.fillStyle = '#333333'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s*1.5);
                    ctx.fillStyle = '#1a1a1a'; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s/4);
                } else if (enemy.type === 'enemyDog') { 
                    drawDogPixelArt(ctx, enemy, screenX, screenY, s);
                } else if (enemy.type === 'enemyDrone') {
                    ctx.fillStyle = enemy.color; 
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    ctx.fillStyle = '#666666'; 
                    ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                    ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
                } else if (enemy.type === 'cobra') {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                    if (enemy.segmentIndex === 0) {
                        ctx.fillStyle = '#FFD700'; 
                        ctx.beginPath();
                        ctx.arc(screenX + s/2, screenY, s/4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw "A" above allied characters
            if (enemy.controlled) {
                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            }
        }

        // Function to draw dog pixel art (for both ally and enemy dogs)
        function drawDogPixelArt(ctx, dog, screenX, screenY, s) {
            ctx.fillStyle = dog.color; 
            ctx.beginPath();
            ctx.ellipse(screenX, screenY + s * 0.1, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(screenX + s * 0.4, screenY - s * 0.2, s * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(screenX + s * 0.3, screenY - s * 0.4);
            ctx.lineTo(screenX + s * 0.5, screenY - s * 0.6);
            ctx.lineTo(screenX + s * 0.6, screenY - s * 0.3);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(screenX - s * 0.6, screenY + s * 0.1);
            ctx.lineTo(screenX - s * 0.8, screenY - s * 0.1);
            ctx.lineTo(screenX - s * 0.7, screenY + s * 0.2);
            ctx.fill();

            ctx.fillRect(screenX - s * 0.4, screenY + s * 0.4, s * 0.15, s * 0.3);
            ctx.fillRect(screenX + s * 0.2, screenY + s * 0.4, s * 0.15, s * 0.3);
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            drawPixelArt(ctx, player.x, player.y, 'player', Math.floor(player.animationFrame), player.size, player.isMoving);

            const healthBarWidth = player.size * 2;
            const healthBarHeight = 3;
            const healthBarY = screenY - player.size - 15;
            const currentHealthWidth = (player.health / player.maxHealth) * healthBarWidth;

            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#ff3333';
            ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const s = enemy.size;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                const healthBarWidth = s * 1.5;
                const healthBarHeight = 2;
                const healthBarY = screenY - s - 10;
                const currentHealthWidth = (enemy.health / getEnemyStats(enemy.type).health) * healthBarWidth;

                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);

                ctx.fillStyle = enemy.controlled ? '#00ff66' : '#ff3333';
                ctx.fillRect(screenX - healthBarWidth / 2, healthBarY, currentHealthWidth, healthBarHeight);
                
                drawEnemyPixelArt(ctx, enemy);
            });
        }

        // Function to draw a bone-shaped projectile
        function drawBoneProjectile(ctx, x, y, size) {
            ctx.fillStyle = '#D2B48C'; // Bone color
            ctx.beginPath();
            // Main body of the bone (rectangle)
            ctx.ellipse(x, y, size * 1.5, size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ends of the bone (circles)
            ctx.beginPath();
            ctx.arc(x - size * 1.5, y, size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size * 1.5, y, size * 0.7, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                
                if (p.color === '#D2B48C') { // If it's a bone projectile
                    drawBoneProjectile(ctx, screenX, screenY, p.size);
                } else if (p.type === 'knife') {
                    // Draw a knife shape
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx)); // Orient knife with its direction
                    ctx.beginPath();
                    ctx.moveTo(-p.size, -p.size / 4);
                    ctx.lineTo(p.size, 0);
                    ctx.lineTo(-p.size, p.size / 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'sword') {
                    // Draw a sword shape
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.atan2(p.vy, p.vx)); // Orient sword with its direction
                    // Blade
                    ctx.fillRect(-p.size * 1.5, -p.size / 4, p.size * 3, p.size / 2);
                    // Hilt
                    ctx.fillStyle = '#8B4513'; // Brown hilt
                    ctx.fillRect(-p.size * 1.8, -p.size / 2, p.size * 0.5, p.size);
                    ctx.restore();
                }
                else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            enemyProjectiles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = '#FF0000'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();

                if (p.isAoE) {
                    const opacity = 0.5 * (1 - (p.lifetime / p.maxLifetime)); 
                    ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.aoeRadius * (1 - opacity), 0, Math.PI * 2); 
                    ctx.stroke();
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                if (p.type === 'xp') {
                    ctx.fillStyle = '#FFD700'; 
                    ctx.shadowColor = '#FFA500'; 
                    ctx.shadowBlur = 8; 
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2); 
                    ctx.fill();
                    ctx.shadowBlur = 0; 
                } else if (p.type === 'heart') {
                    ctx.fillStyle = '#FF0000'; 
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.moveTo(screenX + p.size * 0.5, screenY + p.size * 0.3);
                    ctx.bezierCurveTo(
                        screenX + p.size * 1.0, screenY - p.size * 0.7,
                        screenX + p.size * 1.5, screenY + p.size * 0.3,
                        screenX, screenY + p.size * 1.0
                    );
                    ctx.bezierCurveTo(
                        screenX - p.size * 1.5, screenY + p.size * 0.3,
                        screenX - p.size * 1.0, screenY - p.size * 0.7,
                        screenX - p.size * 0.5, screenY + p.size * 0.3
                    );
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        function drawChests() {
            chests.forEach(chest => {
                const screenX = chest.x - camera.x;
                const screenY = chest.y - camera.y;
                ctx.fillStyle = '#8B4513'; 
                ctx.fillRect(screenX - chest.size / 2, screenY - chest.size / 2, chest.size, chest.size);
                ctx.fillStyle = '#FFD700'; 
                ctx.fillRect(screenX - chest.size / 8, screenY - chest.size / 2, chest.size / 4, chest.size / 4);
            });
        }

        function drawSpinningKnives() {
            spinningKnives.forEach(knife => {
                const screenX = knife.x - camera.x;
                const screenY = knife.y - camera.y;
                ctx.fillStyle = '#AAAAAA'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, knife.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawAllyDogs() {
            allyDogs.forEach(dog => {
                const s = dog.size;
                const screenX = dog.x - camera.x;
                const screenY = dog.y - camera.y;

                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 255, 102, 0.8)'; 
                ctx.shadowBlur = 15; 
                ctx.fillStyle = '#00ff66'; 
                ctx.beginPath();
                ctx.arc(screenX, screenY, s * 0.7, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore(); 

                drawDogPixelArt(ctx, dog, screenX, screenY, s);

                ctx.fillStyle = '#00ff66'; 
                ctx.font = 'bold 16px Chakra Petch'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', screenX, screenY - s * 2); 
            });
        }

        function drawDrones() {
            drones.forEach(drone => {
                const s = drone.size;
                const screenX = drone.x - camera.x;
                const screenY = drone.y - camera.y;

                ctx.fillStyle = '#00FFFF'; 
                ctx.fillRect(screenX - s/2, screenY - s/2, s, s); 
                ctx.fillStyle = '#666666'; 
                ctx.fillRect(screenX - s, screenY - s/8, s*2, s/4); 
                ctx.fillRect(screenX - s/8, screenY - s, s/4, s*2); 
            });
        }

        function drawBoomerangs() {
            boomerangs.forEach(b => {
                const screenX = b.x - camera.x;
                const screenY = b.y - camera.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 8); 
                
                ctx.fillStyle = b.color; 
                const bananaWidth = b.size * 0.6; 
                const bananaLength = b.size * 2; 

                ctx.beginPath();
                ctx.moveTo(0, -bananaWidth / 2);
                ctx.bezierCurveTo(
                    bananaLength * 0.5, -bananaWidth * 1.5, 
                    bananaLength * 0.5, bananaWidth * 1.5,  
                    0, bananaWidth / 2                      
                );
                ctx.bezierCurveTo(
                    -bananaLength * 0.5, bananaWidth * 1.5, 
                    -bananaLength * 0.5, -bananaWidth * 1.5, 
                    0, -bananaWidth / 2                     
                );
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }
        
        function drawUltimateEffect() {
            ctx.beginPath();
            const pulseSize = player.size * (1 + 0.5 * Math.sin(survivalTime * 10));
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.arc(screenX, screenY, pulseSize * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 102, 0, ${0.5 * (ultimateDuration/3)})`; 
            ctx.lineWidth = 10;
            ctx.stroke();

            ctx.fillStyle = `rgba(255, 102, 0, ${0.1 * (ultimateDuration/3)})`; 
            ctx.fillRect(0, 0, canvas.width / camera.zoom, canvas.height / camera.zoom); 
        }

        // Draw Forcefield
        function drawForcefield() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            const pulse = 1 + 0.1 * Math.sin(survivalTime * 5); 
            const currentRadius = player.stats.forcefieldRadius * pulse;

            ctx.beginPath();
            ctx.arc(screenX, screenY, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.7 * (1 - Math.abs(Math.sin(survivalTime * 2)) * 0.2)})`; 
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = `rgba(0, 255, 255, ${0.1 * (1 - Math.abs(Math.sin(survivalTime * 2)) * 0.2)})`; 
            ctx.fill();
        }

        function drawUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            const minutes = Math.floor(survivalTime / 60);
            const seconds = Math.floor(survivalTime % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `Time: ${minutes}:${seconds}`;
            levelDisplay.textContent = `Level: ${player.level}`;
            xpBar.style.width = `${(player.xp / player.nextLevelXp) * 100}%`;
            ultimateBar.style.width = `${(ultimateCharge / ultimateMaxCharge) * 100}%`;

            if (ultimateCharge >= ultimateMaxCharge) {
                ultimateButton.classList.add('ready');
            } else {
                ultimateButton.classList.remove('ready');
            }

            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }
        
        function showDamageNumber(damage, x, y) {
            damageNumbers.push({
                x: x,
                y: y,
                text: Math.round(damage),
                lifetime: 1
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const screenX = d.x - camera.x;
                const screenY = d.y - camera.y;
                ctx.fillStyle = `rgba(255, 50, 50, ${d.lifetime})`;
                ctx.font = `14px 'Chakra Petch'`;
                ctx.textAlign = 'center';
                ctx.fillText(d.text, screenX, screenY);
            });
        }

        function drawParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }

        function drawMiniMap() {
            miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#1a1a1a';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.fillStyle = '#444444'; 
            obstacles.forEach(obstacle => {
                const miniX = obstacle.x * miniMapScale;
                const miniY = obstacle.y * miniMapScale;
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(miniX, miniY, obstacle.width / 2 * miniMapScale, 0, Math.PI * 2);
                    miniMapCtx.fill();
                } else {
                    miniMapCtx.fillRect(miniX, miniY, obstacle.width * miniMapScale, obstacle.height * miniMapScale);
                }
            });

            miniMapCtx.fillStyle = '#ff0000'; 
            enemies.forEach(enemy => {
                const miniX = enemy.x * miniMapScale;
                const miniY = enemy.y * miniMapScale;
                miniMapCtx.fillStyle = enemy.controlled ? '#00ff66' : '#ff0000'; 
                miniMapCtx.beginPath();
                miniMapCtx.arc(miniX, miniY, enemy.size / 2 * miniMapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            const miniPlayerX = player.x * miniMapScale;
            const miniPlayerY = player.y * miniMapScale;
            miniMapCtx.fillStyle = '#00ffff'; 
            miniMapCtx.beginPath();
            miniMapCtx.arc(miniPlayerX, miniPlayerY, player.size / 2 * miniMapScale, 0, Math.PI * 2);
            miniMapCtx.fill();

            // Draw chests as larger icons on the mini-map
            chests.forEach(chest => {
                const miniX = chest.x * miniMapScale;
                const miniY = chest.y * miniMapScale;
                const chestMiniSize = chest.size * miniMapScale * 1.5; 
                miniMapCtx.fillStyle = '#FFD700'; 
                miniMapCtx.fillRect(miniX - chestMiniSize / 2, miniY - chestMiniSize / 2, chestMiniSize, chestMiniSize);
            });

            // Draw hearts on the mini-map
            powerups.forEach(p => {
                if (p.type === 'heart') {
                    const miniX = p.x * miniMapScale;
                    const miniY = p.y * miniMapScale;
                    const heartMiniSize = p.size * miniMapScale * 1.5; 
                    miniMapCtx.fillStyle = '#FF0000';
                    miniMapCtx.beginPath();
                    miniMapCtx.moveTo(miniX + heartMiniSize * 0.5, miniY + heartMiniSize * 0.3);
                    miniMapCtx.bezierCurveTo(
                        miniX + heartMiniSize * 1.0, miniY - heartMiniSize * 0.7,
                        miniX + heartMiniSize * 1.5, miniY + heartMiniSize * 0.3,
                        miniX, miniY + heartMiniSize * 1.0 // Corrected from miniMapCtx.currentY
                    );
                    miniMapCtx.bezierCurveTo(
                        miniX - heartMiniSize * 1.5, miniY + heartMiniSize * 0.3,
                        miniX - heartMiniSize * 1.0, miniY - heartMiniSize * 0.7, // Corrected from miniMapCtx.currentY
                        miniX - heartMiniSize * 0.5, miniMapCtx.currentY + heartMiniSize * 0.3
                    );
                    ctx.closePath();
                    miniMapCtx.fill();
                }
            });
        }

        function showStartMenu() {
            startMenu.style.display = 'block';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; 
            characterSelectMenu.style.display = 'none'; 
            // Removed: displayHighScores('start-menu-high-scores-list'); // This call is now handled by onAuthStateChanged in initFirebase
        }
        
        function showGameOverMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'block';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; 
            characterSelectMenu.style.display = 'none'; 
        }

        function showLevelSelectMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none';
            messageBox.style.display = 'none';
            levelSelectMenu.style.display = 'block';
            characterSelectMenu.style.display = 'none'; 
            populateLevelOptions();
        }

        // Show Character Select Menu
        function showCharacterSelectMenu() {
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            gameMenu.style.display = 'none';
            messageBox.style.display = 'none';
            levelSelectMenu.style.display = 'none';
            characterSelectMenu.style.display = 'block';
        }

        function populateLevelOptions() {
            levelOptionsDiv.innerHTML = ''; 

            const levels = [
                { id: 'hotel_lobby', name: 'Hotel Lobby', unlockScore: 0, description: 'The classic battleground.' },
                { id: 'the_park', name: 'The Park', unlockScore: 0, description: 'A green oasis, full of danger.' },
                { id: 'desert_oasis', name: 'Desert Oasis', unlockScore: 5000, description: 'A scorching landscape with hidden dangers.' } // New level
            ];

            levels.forEach(level => {
                const card = document.createElement('div');
                card.className = 'level-card';
                card.innerHTML = `<h3>${level.name}</h3><p>${level.description}</p>`;

                let isLocked = false;
                if (level.id === 'the_park' && level.unlockScore > 0 && highestHotelLobbyScore < level.unlockScore) {
                    isLocked = true;
                    card.classList.add('locked');
                    const unlockInfo = document.createElement('p');
                    unlockInfo.className = 'unlock-info';
                    unlockInfo.textContent = `Unlock: ${level.unlockScore} Score in Hotel Lobby (Your Best: ${highestHotelLobbyScore})`;
                    card.appendChild(unlockInfo);
                } else if (level.id === 'desert_oasis' && level.unlockScore > 0 && Math.max(highestHotelLobbyScore, highestTheParkScore) < level.unlockScore) { // Changed unlock condition for Desert Oasis
                    isLocked = true;
                    card.classList.add('locked');
                    const unlockInfo = document.createElement('p');
                    unlockInfo.className = 'unlock-info';
                    unlockInfo.textContent = `Unlock: ${level.unlockScore} Score in Any Level (Your Best: ${Math.max(highestHotelLobbyScore, highestTheParkScore)})`; // Updated message
                    card.appendChild(unlockInfo);
                }

                if (!isLocked) {
                    card.addEventListener('click', () => {
                        currentLevelId = level.id;
                        showCharacterSelectMenu(); 
                    });
                }
                levelOptionsDiv.appendChild(card);
            });
        }
        
        function updatePlayer(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            player.isMoving = distance > 5;
            if (player.isMoving) {
                const angle = Math.atan2(dy, dx);
                const currentSpeed = player.speed * (ultimateActive ? playerSpeedModifier : 1);
                player.vx = Math.cos(angle) * currentSpeed;
                player.vy = Math.sin(angle) * currentSpeed;
            } else {
                player.vx = 0; 
                player.vy = 0; 
            }

            let newX = player.x + player.vx * effectiveDt;
            let newY = player.y + player.vy * effectiveDt;

            let tempPlayer = {
                x: newX,
                y: newY,
                size: player.size,
                vx: player.vx,
                vy: player.vy
            };
            
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') {
                    let obstacleCircle = {
                        x: obstacle.x,
                        y: obstacle.y,
                        size: obstacle.width 
                    };
                    circleCircleCollideAndResolve(tempPlayer, obstacleCircle);
                } else { 
                    circleRectCollideAndResolve(tempPlayer, obstacle);
                }
            });

            player.x = tempPlayer.x;
            player.y = tempPlayer.y;
            player.vx = tempPlayer.vx; 
            player.vy = tempPlayer.vy;

            player.x = Math.max(0, Math.min(gameWorld.width, player.x));
            player.y = Math.max(0, Math.min(gameWorld.height, player.y));
            
            if (player.isMoving) {
                player.animationFrame = (player.animationFrame + effectiveDt * 10) % 4;
            } else {
                player.animationFrame = 0;
            }
        
            player.health += player.stats.healthRegen * effectiveDt;
            player.health = Math.min(player.health + player.stats.healthRegen * effectiveDt, player.maxHealth);

            // Update player flash and invincibility
            if (player.invincible) {
                player.invincibilityTimer -= effectiveDt;
                player.flashTimer += effectiveDt;

                if (player.flashTimer >= 0.1) { // Flash every 0.1 seconds
                    player.isFlashing = !player.isFlashing;
                    player.flashTimer = 0;
                }

                if (player.invincibilityTimer <= 0) {
                    player.invincible = false;
                    player.isFlashing = false; // Ensure flashing stops
                    player.color = player.baseColor; // Restore original color
                }
            }
        
            if (player.upgrades.burstCharge > 0 && player.burstChargeTimer <= 0) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; 
                    const numProjectiles = player.stats.burstChargeProjectileCount;
                    const arcSpread = 0.8; 
                    const angleStep = arcSpread / (numProjectiles > 1 ? (numProjectiles - 1) : 1);
                    const startAngle = angle - arcSpread / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const projectileAngle = startAngle + i * angleStep;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            vy: Math.sin(projectileAngle) * player.stats.projectileSpeed * 0.5 * (ultimateActive ? projectileSpeedModifier : 1), 
                            size: 5, 
                            damage: ultimateActive ? player.stats.burstChargeDamage * 3 : player.stats.burstChargeDamage,
                            color: ultimateActive ? '#ff9933' : '#00ffff', 
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    player.burstChargeTimer = player.burstChargeCooldown;
                    playSound('playerShot'); 
                }
            }
        
            // Johnny's default attack (pistol)
            if (currentCharacter === 'johnny' && shootTimer >= 1 / player.stats.attackSpeed) {
                const closestEnemy = findClosestEnemy();
                
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                    player.currentShootAngle = angle; 
                    
                    let currentMultiShot = player.stats.multiShot;
                    let currentProjectileSpeed = player.stats.projectileSpeed;
                    let currentDamage = player.stats.damage;

                    if (temporaryPowerupType === 'spreadGun') {
                        currentMultiShot = 5; 
                        currentProjectileSpeed = 300; 
                        currentDamage = player.stats.damage * 0.75; 
                    }

                    for (let i = 0; i < currentMultiShot; i++) {
                        const spread = (i - (currentMultiShot - 1) / 2) * 0.1; 
                        const projectileAngle = angle + spread;
                        
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            vy: Math.sin(projectileAngle) * currentProjectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                            size: 3,
                            damage: ultimateActive ? currentDamage * 3 : currentDamage,
                            color: ultimateActive ? '#ff6600' : '#d1d1d1',
                            pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                            hits: 0
                        });
                    }
                    if (survivalTime - lastShotSoundTime >= 5) {
                        playSound('playerShot'); 
                        lastShotSoundTime = survivalTime;
                    }
                }
                
                shootTimer = 0;
            }

            if (player.stats.burstDamage > 0 && player.burstTimer >= player.burstCooldown) {
                const closestEnemy = findClosestEnemy();
                if (closestEnemy) {
                    player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); 
                }
                const numProjectiles = player.stats.burstProjectileCount;
                const angleStep = (Math.PI * 2) / numProjectiles;
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = i * angleStep;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        vy: Math.sin(angle) * player.stats.projectileSpeed * (ultimateActive ? projectileSpeedModifier : 1),
                        size: 3,
                        damage: player.stats.burstDamage,
                        color: ultimateActive ? '#ff6600' : '#d1d1d1',
                        pierce: ultimateActive ? player.stats.pierce + 1 : player.stats.pierce,
                        hits: 0
                    });
                }
                player.burstTimer = 0;
                if (survivalTime - lastShotSoundTime >= 5) {
                    playSound('playerShot'); 
                    lastShotSoundTime = survivalTime;
                }
            }

            if (player.upgrades.shotgun > 0) {
                player.shotgunTimer += effectiveDt;
                const shotgunCooldown = 0.8 / (1 + player.upgrades.shotgun * 0.1); 
                if (player.shotgunTimer >= shotgunCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy && dist(player, closestEnemy) < 200) { 
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; 
                        for (let i = 0; i < player.stats.shotgunPellets; i++) {
                            const spread = (i - (player.stats.shotgunPellets - 1) / 2) * player.stats.shotgunSpread;
                            const projectileAngle = angle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 300, 
                                vy: Math.sin(projectileAngle) * 300,
                                size: 5,
                                damage: player.stats.shotgunDamage,
                                color: '#FFA500', 
                                pierce: 0, 
                                hits: 0,
                                lifetime: 0.3, 
                                maxLifetime: 0.3 
                            });
                        }
                        playSound('playerShot'); 
                        player.shotgunTimer = 0;
                    }
                }
            }

            // Dual Uzi logic (for Johnny or Dixie if upgraded/default)
            if (player.stats.dualUziActive) {
                player.dualUziTimer += effectiveDt;
                const uziCooldown = 1 / player.stats.dualUziFireRate;
                if (player.dualUziTimer >= uziCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        player.currentShootAngle = angle; 
                        // Adjusted projectile spawn points to be at the end of the longer arms
                        const armBaseOffset = player.size * 0.2; // Offset from player body center to arm base
                        const armLengthOffset = player.size * 1.5; // Dixie's arm length

                        projectiles.push({
                            x: player.x + Math.cos(angle - Math.PI/2) * armBaseOffset + Math.cos(angle) * armLengthOffset,
                            y: player.y + Math.sin(angle - Math.PI/2) * armBaseOffset + Math.sin(angle) * armLengthOffset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        projectiles.push({
                            x: player.x + Math.cos(angle + Math.PI/2) * armBaseOffset + Math.cos(angle) * armLengthOffset,
                            y: player.y + Math.sin(angle + Math.PI/2) * armBaseOffset + Math.sin(angle) * armLengthOffset,
                            vx: Math.cos(angle) * 600,
                            vy: Math.sin(angle) * 600,
                            size: 2,
                            damage: player.stats.dualUziDamage,
                            color: '#00FF00', 
                            pierce: 0,
                            hits: 0
                        });
                        if (survivalTime - lastUziSoundTime >= UZI_SOUND_COOLDOWN) {
                            playSound('playerShot'); 
                            lastUziSoundTime = survivalTime;
                        }
                    }
                    player.dualUziTimer = 0;
                }
            }

            if (player.stats.boomerangCount > 0) {
                player.boomerangTimer += effectiveDt;
                if (player.boomerangTimer >= player.stats.boomerangCooldown) {
                    const closestEnemy = findClosestEnemy(); 
                    if (closestEnemy) {
                        player.currentShootAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x); 
                    }
                    const numBoomerangs = player.stats.boomerangCount;
                    const angleStep = (Math.PI * 2) / numBoomerangs; 
                    for (let i = 0; i < numBoomerangs; i++) {
                        const initialAngle = Math.random() * Math.PI * 2; 
                        boomerangs.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(initialAngle) * player.stats.boomerangSpeed,
                            vy: Math.sin(initialAngle) * player.stats.boomerangSpeed,
                            size: 15, 
                            damage: player.stats.boomerangDamage,
                            color: '#FFFF00', 
                            distanceTraveled: 0,
                            returning: false,
                            hitEnemies: new Set(), 
                            maxOutwardDistance: player.stats.boomerangRange,
                            speed: player.stats.boomerangSpeed
                        });
                    }
                    player.boomerangTimer = 0;
                }
            }

            // Leash Whip ability for Dixie
            if (currentCharacter === 'dixie' && player.upgrades.leashWhip > 0) {
                player.leashWhipTimer += effectiveDt;
                if (player.leashWhipTimer >= player.leashWhipCooldown) {
                    const enemiesInWhipRange = enemies.filter(enemy => 
                        !enemy.controlled && dist(player, enemy) < (player.size / 2 + 50 + enemy.size / 2) 
                    );
                    if (enemiesInWhipRange.length > 0) {
                        enemiesInWhipRange.forEach(enemy => {
                            const damageDealt = player.stats.leashWhipDamage;
                            enemy.health -= damageDealt;
                            ultimateCharge += ultimateChargePerHit;
                            showDamageNumber(damageDealt, enemy.x, enemy.y);
                            if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                playSound('enemyHit');
                                lastEnemyHitSoundTime = survivalTime;
                            }
                            spawnParticles(enemy.x, enemy.y, {r: 150, g: 75, b: 0}); 
                        });
                        playSound('playerShot'); 
                    }
                    player.leashWhipTimer = 0;
                }
            }

            // Knife Throw Logic
            if (player.upgrades.knifeThrow > 0) {
                player.knifeThrowTimer += effectiveDt;
                if (player.knifeThrowTimer >= player.stats.knifeCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        for (let i = 0; i < player.stats.knifeCount; i++) {
                            const spread = (i - (player.stats.knifeCount - 1) / 2) * 0.1; // Small spread for multiple knives
                            const projectileAngle = angle + spread;
                            projectiles.push({
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(projectileAngle) * 500, // Fixed speed for knives
                                vy: Math.sin(projectileAngle) * 500,
                                size: 8,
                                damage: ultimateActive ? player.stats.knifeDamage * 3 : player.stats.knifeDamage,
                                color: '#A9A9A9', // Dark gray for knife
                                pierce: 0, // Knives don't pierce by default
                                hits: 0,
                                type: 'knife' // New type for drawing
                            });
                        }
                        playSound('playerShot');
                        player.knifeThrowTimer = 0;
                    }
                }
            }

            // Sword Throw Logic (Dixie only)
            if (currentCharacter === 'dixie' && player.upgrades.swordThrow > 0) {
                player.swordThrowTimer += effectiveDt;
                if (player.swordThrowTimer >= player.stats.swordCooldown) {
                    const closestEnemy = findClosestEnemy();
                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 600, // Fixed speed for swords
                            vy: Math.sin(angle) * 600,
                            size: 12,
                            damage: ultimateActive ? player.stats.swordDamage * 3 : player.stats.swordDamage,
                            color: '#ADD8E6', // Light blue for sword
                            pierce: ultimateActive ? player.stats.swordPierce + 1 : player.stats.swordPierce,
                            hits: 0,
                            type: 'sword' // New type for drawing
                        });
                        playSound('playerShot');
                        player.swordThrowTimer = 0;
                    }
                }
            }
        }

        function findClosestEnemy() {
            let closest = null;
            let minDistance = Infinity;

            enemies.forEach(enemy => {
                const distance = dist(player, enemy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function activateUltimate() {
            ultimateActive = true;
            ultimateDuration = 1.5; 
            if (currentCharacter === 'johnny') { 
                player.color = '#ff6600'; 
            } else if (currentCharacter === 'dixie') {
                player.color = player.baseColor; // Dixie remains pink
            }
            ultimateCharge = 0;
            playSound('ultimateActivate');

            gameSpeedMultiplier = 0.25; 
            playerSpeedModifier = 3; 
            projectileSpeedModifier = 3;
            if (!isMusicMuted) Tone.Transport.playbackRate = 0.5; 
        }
        
        function updateEnemies(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                // New logic for spawning 'enforcer' every 5 minutes
                if (timeInMinutes >= 5 && Math.floor(timeInMinutes) % 5 === 0 && Math.random() < 0.1) { 
                    enemyType = 'enforcer';
                } else if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra'; 
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        
            enemies = enemies.filter(enemy => {
                let angle;

                const prevX = enemy.x;
                const prevY = enemy.y;

                if (enemy.controlled) {
                    const closestEnemy = enemies
                        .filter(e => !e.controlled)
                        .sort((a, b) => dist(enemy, a) - dist(enemy, b))[0];
                    if (closestEnemy) {
                        angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - closestEnemy.x);
                    } else {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    }
                } else if (enemy.type === 'cobra') {
                    if (enemy.segmentIndex === 0) { 
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed; 
                    } else { 
                        const prevSegment = enemies.find(e => e.snakeId === enemy.snakeId && e.segmentIndex === enemy.segmentIndex - 1);
                        if (prevSegment) {
                            const dx = prevSegment.x - enemy.x;
                            const dy = prevSegment.y - enemy.y;
                            const segmentDistance = Math.sqrt(dx*dx + dy*dy);
                            const minSegmentDistance = enemy.size * 1.2; 
                            
                            if (segmentDistance > minSegmentDistance) {
                                angle = Math.atan2(dy, dx);
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0;
                                enemy.vy = 0;
                            }
                        } else {
                            enemy.vx = 0;
                            enemy.vy = 0;
                        }
                    }
                } else if (enemy.type === 'robotDrone') {
                    angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2 + 10)) { 
                        explodeRobotDrone(enemy);
                        return false; 
                    }
                } else if (enemy.type === 'enforcer') {
                    const distance = dist(player, enemy);
                    if (distance < enemy.attackRange) {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        enemy.shootTimer += effectiveDt;
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            const attackAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            const numProjectiles = 5; 
                            const coneSpread = Math.PI / 4; 
                            for (let i = 0; i < numProjectiles; i++) {
                                const spread = (i - (numProjectiles - 1) / 2) * (coneSpread / numProjectiles);
                                const projectileAngle = attackAngle + spread;
                                enemyProjectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(projectileAngle) * enemy.projectileSpeed,
                                    vy: Math.sin(projectileAngle) * enemy.projectileSpeed,
                                    size: enemy.projectileSize,
                                    damage: enemy.projectileDamage,
                                    color: enemy.projectileColor,
                                    isAoE: false, 
                                    lifetime: 0.2, 
                                    maxLifetime: 0.2,
                                    sourceEnemy: enemy 
                                });
                            }
                            playSound('playerShot'); 
                            enemy.shootTimer = 0;
                        }
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.vx = Math.cos(angle) * enemy.speed;
                        enemy.vy = Math.sin(angle) * enemy.speed;
                    }
                } else { 
                    const distance = dist(player, enemy);
                    if ((enemy.type === 'gunner' || enemy.type === 'fast' || enemy.type === 'drone' || enemy.type === 'enemyDrone') && distance < enemy.attackRange) {
                        angle = Math.atan2(player.y - enemy.y, player.x - player.x);
                        enemy.shootTimer += effectiveDt; 
                        if (enemy.shootTimer >= 1 / enemy.attackSpeed) {
                            const isBazooka = survivalTime > 300 || player.level > 5; 
                            
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * enemy.projectileSpeed,
                                vy: Math.sin(angle) * enemy.projectileSpeed,
                                size: isBazooka ? 15 : enemy.projectileSize, 
                                damage: isBazooka ? enemy.projectileDamage * 2 : enemy.projectileDamage, 
                                color: '#FF0000', 
                                hits: 0,
                                isAoE: isBazooka, 
                                aoeRadius: isBazooka ? 70 : 0, 
                                lifetime: isBazooka ? 1 : 0, 
                                maxLifetime: isBazooka ? 1 : 0,
                                sourceEnemy: enemy 
                            });
                            enemy.shootTimer = 0;
                        }
                        enemy.vx = 0; 
                        enemy.vy = 0;
                        return enemy.x > -100 && enemy.x < gameWorld.width + 100 &&
                               enemy.y > -100 && enemy.y < gameWorld.height + 100;
                    } else {
                        angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        
                        if (enemy.type !== 'gunner' && Math.random() < 0.01) { 
                            enemy.flankAngle = (Math.random() - 0.5) * Math.PI / 2;
                        }
                        if (enemy.flankAngle !== undefined) {
                            angle += enemy.flankAngle;
                        }
                    }
                }

                if (enemy.type !== 'cobra' || enemy.segmentIndex === 0) { 
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                }
                

                let tempEnemy = {
                    x: enemy.x + enemy.vx * effectiveDt, 
                    y: enemy.y + enemy.vy * effectiveDt, 
                    size: enemy.size,
                    vx: enemy.vx,
                    vy: enemy.vy
                };

                if (!enemy.ghostModeActive) {
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') {
                            let obstacleCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempEnemy, obstacleCircle);
                        } else {
                            circleRectCollideAndResolve(tempEnemy, obstacle);
                        }
                    });
                }


                enemy.x = tempEnemy.x;
                enemy.y = tempEnemy.y;
                enemy.vx = tempEnemy.vx; 
                enemy.vy = tempEnemy.vy;

                const movedDistance = dist({x: prevX, y: prevY}, {x: enemy.x, y: enemy.y});
                const stuckThreshold = 1; 

                if (movedDistance < stuckThreshold) {
                    enemy.stuckTimer += effectiveDt;
                    if (enemy.stuckTimer >= 2 && !enemy.ghostModeActive) { 
                        enemy.ghostModeActive = true;
                        enemy.ghostModeTimer = 1; 
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} entered ghost mode!`);
                    }
                } else {
                    enemy.stuckTimer = 0; 
                }

                if (enemy.ghostModeActive) {
                    enemy.ghostModeTimer -= effectiveDt;
                    if (enemy.ghostModeTimer <= 0) {
                        enemy.ghostModeActive = false;
                        enemy.stuckTimer = 0; 
                        console.log(`Enemy ${enemy.type} exited ghost mode.`);
                    }
                }

                if (Math.abs(enemy.vx) > 0 || Math.abs(enemy.vy) > 0) {
                    enemy.animationFrame = (enemy.animationFrame + effectiveDt * 10) % 4;
                } else {
                    enemy.animationFrame = 0;
                }

                enemy.x = Math.max(-100, Math.min(gameWorld.width + 100, enemy.x)); 
                enemy.y = Math.max(-100, Math.min(gameWorld.height + 100, enemy.y));
        
                return enemy.x > -150 && enemy.x < gameWorld.width + 150 && 
                       enemy.y > -150 && enemy.y < gameWorld.height + 150;
            });

            const cobraIds = new Set(enemies.filter(e => e.type === 'cobra').map(e => e.snakeId));
            cobraIds.forEach(id => {
                let segments = enemies.filter(e => e.snakeId === id).sort((a, b) => a.segmentIndex - b.segmentIndex);
                segments.forEach((segment, index) => {
                    segment.segmentIndex = index; 
                });
            });
        }
        
        function updateProjectiles(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            projectiles = projectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.lifetime !== undefined) {
                    p.lifetime -= effectiveDt;
                }
                
                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && p.hits <= p.pierce && (p.lifetime === undefined || p.lifetime > 0); 
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.x += p.vx * effectiveDt; 
                p.y += p.vy * effectiveDt; 

                if (p.isAoE || p.lifetime !== undefined) { 
                    p.lifetime -= effectiveDt;
                }

                return p.x > -100 && p.x < gameWorld.width + 100 && p.y > -100 && p.y < gameWorld.height + 100 && (!p.isAoE && p.lifetime === undefined || p.lifetime > 0);
            });
        }
        
        function updatePowerups(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            powerups = powerups.filter(p => {
                const distance = dist(player, p);
                if (distance < player.stats.magnet) {
                    const angle = Math.atan2(player.y - p.y, player.x - p.x);
                    p.x += Math.cos(angle) * p.speed * effectiveDt; 
                    p.y += Math.sin(angle) * p.speed * effectiveDt; 
                }
                return true;
            });
        }

        function updateChests(dt) {
            chests = chests.filter(chest => {
                return true;
            });
        }
        
        function updateDamageNumbers(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 
            damageNumbers = damageNumbers.filter(d => {
                d.y -= 20 * effectiveDt; 
                d.lifetime -= effectiveDt; 
                return d.lifetime > 0;
            });
        }

        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha -= dt * 2; 
                p.size -= dt * 5; 
                return p.alpha > 0 && p.size > 0;
            });
        }

        function updateSpinningKnivesEffect() {
            spinningKnives = [];
            const numKnives = player.stats.spinningKnivesCount;
            const radius = player.size * 2; 
            const knifeSize = 5;
            const knifeDamage = player.stats.spinningKnivesDamage;
            const rotationSpeed = 5; 

            for (let i = 0; i < numKnives; i++) {
                spinningKnives.push({
                    angle: (Math.PI * 2 / numKnives) * i, 
                    radius: radius,
                    size: knifeSize,
                    damage: knifeDamage,
                    rotationSpeed: rotationSpeed,
                    hitEnemies: new Set() 
                });
            }
        }

        function updateAllyDogs(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            const leashRadius = DOG_LEASH_RADIUS; 
            const attackRadius = 400; 

            // Create a set of enemies already targeted by other dogs in this frame
            const targetedEnemies = new Set();
            allyDogs.forEach(dog => {
                if (dog.currentTarget) {
                    targetedEnemies.add(dog.currentTarget);
                }
            });

            allyDogs.forEach(dog => {
                let intendedVx = 0;
                let intendedVy = 0;
                let closestEnemyInAttackRange = null;
                let minDistanceToEnemy = Infinity;

                // Find the closest untargeted enemy within attack range
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !targetedEnemies.has(enemy)) { // Ensure enemy is not controlled and not already targeted
                        const distToEnemy = dist(dog, enemy);
                        if (distToEnemy < attackRadius && distToEnemy < minDistanceToEnemy) {
                            minDistanceToEnemy = distToEnemy;
                            closestEnemyInAttackRange = enemy;
                        }
                    }
                });

                // If only one enemy on screen and it's already targeted, allow this dog to target it too.
                // This prevents dogs from doing nothing if there's only one enemy left and another dog has it.
                if (!closestEnemyInAttackRange && enemies.filter(e => !e.controlled).length === 1) {
                    closestEnemyInAttackRange = enemies.find(e => !e.controlled);
                }
                
                dog.currentTarget = closestEnemyInAttackRange; // Store the current target

                if (closestEnemyInAttackRange) {
                    // Move towards the closest enemy
                    const angleToEnemy = Math.atan2(closestEnemyInAttackRange.y - dog.y, closestEnemyInAttackRange.x - dog.x);
                    intendedVx = Math.cos(angleToEnemy) * dog.speed;
                    intendedVy = Math.sin(angleToEnemy) * dog.speed;
                } else {
                    // Orbit the player if no enemies in range
                    dog.orbitAngle = (dog.orbitAngle + effectiveDt * 0.8) % (Math.PI * 2); 
                    const targetX = player.x + Math.cos(dog.orbitAngle) * dog.orbitRadius;
                    const targetY = player.y + Math.sin(dog.orbitAngle) * dog.orbitRadius;

                    // Move towards the target orbit position
                    const dx = targetX - dog.x;
                    const dy = targetY - dog.y;
                    const distToOrbit = Math.sqrt(dx * dx + dy * dy);
                    if (distToOrbit > 5) { 
                        const angleToOrbit = Math.atan2(dy, dx);
                        intendedVx = Math.cos(angleToOrbit) * dog.speed;
                        intendedVy = Math.sin(angleToOrbit) * dog.speed;
                    }
                }

                // Store current position for stuck detection
                const prevX = dog.x;
                const prevY = dog.y;

                // Temporary object for collision resolution with intended velocity
                let tempDog = {
                    x: dog.x + intendedVx * effectiveDt, 
                    y: dog.y + intendedVy * effectiveDt, 
                    size: dog.size,
                    vx: intendedVx, 
                    vy: intendedVy
                };
                
                if (!dog.ghostModeActive) {
                    obstacles.forEach(obstacle => {
                        if (obstacle.type === 'pillar' || obstacle.type === 'tree' || obstacle.type === 'cactus') {
                            let obstacleCircle = { x: obstacle.x, y: obstacle.y, size: obstacle.width };
                            circleCircleCollideAndResolve(tempDog, obstacleCircle);
                        } else {
                            circleRectCollideAndResolve(tempDog, obstacle);
                        }
                    });
                }

                dog.x = tempDog.x;
                dog.y = tempDog.y;
                dog.vx = tempDog.vx; 
                dog.vy = tempDog.vy;

                // Stuck detection and ghost mode for dogs
                const movedDistance = dist({x: prevX, y: prevY}, {x: dog.x, y: dog.y});
                const stuckThreshold = 1; 

                if (movedDistance < stuckThreshold) {
                    dog.stuckTimer += effectiveDt;
                    if (dog.stuckTimer >= 1 && !dog.ghostModeActive) { // Shorter stuck time for dogs (1 second)
                        dog.ghostModeActive = true;
                        dog.ghostModeTimer = 0.5; // Shorter ghost mode for dogs (0.5 seconds)
                        dog.stuckTimer = 0; 
                        console.log(`Ally dog entered ghost mode!`);
                    }
                } else {
                    dog.stuckTimer = 0; 
                }

                if (dog.ghostModeActive) {
                    dog.ghostModeTimer -= effectiveDt;
                    if (dog.ghostModeTimer <= 0) {
                        dog.ghostModeActive = false;
                        dog.stuckTimer = 0; 
                        console.log(`Ally dog exited ghost mode.`);
                    }
                }

                // Dog melee attack
                if (closestEnemyInAttackRange && dist(dog, closestEnemyInAttackRange) < (dog.size / 2 + closestEnemyInAttackRange.size / 2) && (survivalTime - dog.lastAttackTime >= dog.attackCooldown)) {
                    closestEnemyInAttackRange.health -= dog.damage;
                    showDamageNumber(dog.damage, closestEnemyInAttackRange.x, closestEnemyInAttackRange.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                    dog.lastAttackTime = survivalTime; 
                }

                // Dog shooting bones (Dixie's specific upgrade)
                if (currentCharacter === 'dixie' && player.upgrades.dogBones > 0 && closestEnemyInAttackRange) {
                    dog.shootTimer += effectiveDt;
                    if (dog.shootTimer >= 1 / dog.attackSpeed) {
                        const angleToEnemy = Math.atan2(closestEnemyInAttackRange.y - dog.y, closestEnemyInAttackRange.x - dog.x);
                        projectiles.push({
                            x: dog.x,
                            y: dog.y,
                            vx: Math.cos(angleToEnemy) * dogProjectileSpeed,
                            vy: Math.sin(angleToEnemy) * dogProjectileSpeed,
                            size: 8, 
                            damage: dogProjectileDamage,
                            color: '#D2B48C', // Bone color
                            pierce: 0,
                            hits: 0
                        });
                        playSound('playerShot'); 
                        dog.shootTimer = 0;
                    }
                }
            });
        }

        // Function to add a single dog ally
        function addAllyDog() {
            const numDogs = allyDogs.length + 1;
            const baseOrbitRadius = DOG_LEASH_RADIUS; // Base distance from player (now uses the constant)
            const orbitSpread = 20; // How much each dog's radius varies
            const initialAngleOffset = Math.random() * Math.PI * 2; // Random starting angle for the first dog

            // Recalculate positions for all dogs (existing + new) to ensure even spread
            for (let i = 0; i < numDogs; i++) {
                const angle = initialAngleOffset + (Math.PI * 2 / numDogs) * i;
                const radius = baseOrbitRadius + (i % 2) * orbitSpread; // Alternate radius for spreading
                
                if (i < allyDogs.length) {
                    // Update existing dog's orbit properties
                    allyDogs[i].orbitAngle = angle;
                    allyDogs[i].orbitRadius = radius;
                } else {
                    // Add new dog
                    allyDogs.push({
                        x: player.x + Math.cos(angle) * radius, 
                        y: player.y + Math.sin(angle) * radius,
                        size: 20,
                        color: '#8B4513', 
                        speed: 200 + player.upgrades.dogSpeed * 20, 
                        damage: 10 + player.upgrades.dogStrength * 5, 
                        lastAttackTime: 0, 
                        attackCooldown: 0.5,
                        shootTimer: 0, 
                        attackSpeed: 1,
                        orbitAngle: angle,        // New: Store orbit angle
                        orbitRadius: radius,       // New: Store orbit radius
                        vx: 0, // Initialize vx
                        vy: 0, // Initialize vy
                        stuckTimer: 0, // New: for stuck detection
                        ghostModeActive: false, // New: for temporary ghost mode
                        ghostModeTimer: 0, // New: duration of ghost mode
                        currentTarget: null // New: to track which enemy this dog is targeting
                    });
                }
            }
            console.log(`[Dixie] Dog added. Current dog count: ${allyDogs.length}`);
        }

        function updateDrones(dt) {
            const effectiveDt = dt * gameSpeedMultiplier;
            drones.forEach(drone => {
                const closestEnemy = enemies.find(e => !e.controlled); 
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                    if (dist(drone, player) > 150) { 
                        drone.x += Math.cos(angle) * drone.speed * effectiveDt;
                        drone.y += Math.sin(angle) * drone.speed * effectiveDt;
                    } else {
                        drone.orbitAngle += effectiveDt * 2; 
                        drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                        drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                    }

                    drone.shootTimer += effectiveDt;
                    if (drone.shootTimer >= 1 / drone.attackSpeed) {
                        projectiles.push({
                            x: drone.x,
                            y: drone.y,
                            vx: Math.cos(angle) * 500, 
                            vy: Math.sin(angle) * 500,
                            size: 4,
                            damage: drone.damage,
                            color: '#00FFFF', 
                            pierce: 0,
                            hits: 0
                        });
                        drone.shootTimer = 0;
                    }
                } else {
                    drone.orbitAngle += effectiveDt * 2; 
                    drone.x = player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
                    drone.y = player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
                }
            });
        }

        function updateDronesEffect() {
            while (drones.length < player.stats.droneCount) {
                const newDrone = {
                    x: player.x,
                    y: player.y,
                    size: 10,
                    speed: 200, 
                    damage: player.stats.droneDamage,
                    attackSpeed: player.stats.droneAttackSpeed,
                    shootTimer: 0,
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitRadius: 50 + drones.length * 10 
                };
                drones.push(newDrone);
            }
            drones.forEach(drone => {
                drone.damage = player.stats.droneDamage;
                drone.attackSpeed = player.stats.droneAttackSpeed;
            });
        }

        function updateBoomerangs(dt) {
            boomerangs = boomerangs.filter(b => {
                if (!b.returning) {
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.distanceTraveled += b.speed * dt;

                    if (b.distanceTraveled >= b.maxOutwardDistance) {
                        b.returning = true;
                    }
                } else {
                    const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                    b.vx = Math.cos(angleToPlayer) * b.speed;
                    b.vy = Math.sin(angleToPlayer) * b.speed;
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;

                    if (dist(player, b) < player.size / 2 + b.size / 2) {
                        return false; 
                    }
                }
                return b.x > -100 && b.x < gameWorld.width + 100 && b.y > -100 && b.y < gameWorld.height + 100;
            });
        }
        
        function checkCollisions() {
            enemies.forEach(enemy => {
                if (!enemy.controlled) {
                    if (dist(player, enemy) < (player.size / 2 + enemy.size / 2) && 
                        (enemy.type === 'basic' || enemy.type === 'tank' || enemy.type === 'car' || enemy.type === 'ninja' || enemy.type === 'enemyDog' || enemy.type === 'cobra' || enemy.type === 'yellowSkull' || enemy.type === 'enforcer')) { 
                        
                        // Apply damage only if not invincible
                        if (!player.invincible) {
                            let damageTaken = enemy.damage;
                            damageTaken = damageTaken * (1 - player.stats.damageReduction);
                            
                            if (ultimateActive) {
                                damageTaken *= 0.5;
                            }
                            damageTaken = Math.max(0, damageTaken); 
                            player.health -= damageTaken;
                            
                            // Activate invincibility frames
                            player.invincible = true;
                            player.invincibilityTimer = 0.5; // 0.5 seconds of invincibility
                            player.flashTimer = 0; // Reset flash timer
                            player.isFlashing = true; // Start flashing immediately
                            player.color = 'rgba(255,255,255,0.7)'; // Flash white

                            if (player.health <= 0) {
                                gameOver();
                            }
                        }
                    }
                }
            });
        
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    if (!enemy.controlled && dist(p, enemy) < (p.size + enemy.size / 2)) {
                        if (enemy.type === 'robotDrone') {
                            explodeRobotDrone(enemy);
                            enemies.splice(j, 1); 
                            j--; 
                            projectileRemoved = true; 
                            break;
                        }
                        
                        const damageDealt = p.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        // Add particle effect for knife hits
                        if (p.type === 'knife' || p.type === 'sword') {
                            spawnParticles(enemy.x, enemy.y, {r: 200, g: 200, b: 200}); 
                        } else {
                            spawnParticles(enemy.x, enemy.y, enemy.color);
                        }

                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit'); 
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        p.hits++;
        
                        if (p.hits > p.pierce) {
                            projectiles.splice(i, 1);
                            projectileRemoved = true;
                            break; 
                        }
                    }
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (dist(player, p) < (player.size / 2 + p.size / 2)) { 
                    // Apply damage only if not invincible
                    if (!player.invincible) {
                        let damageTaken = p.damage;
                        damageTaken = damageTaken * (1 - player.stats.damageReduction);

                        if (ultimateActive) {
                            damageTaken *= 0.5;
                        }
                        damageTaken = Math.max(0, damageTaken); 
                        player.health -= damageTaken;

                        // Activate invincibility frames
                        player.invincible = true;
                        player.invincibilityTimer = 0.5; 
                        player.flashTimer = 0;
                        player.isFlashing = true;
                        player.color = 'rgba(255,255,255,0.7)'; // Flash white

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }

                    if (p.isAoE) {
                        enemies.forEach(otherEnemy => {
                            // Ensure the AoE only damages hostile enemies that are not the source of the projectile
                            if (otherEnemy !== p.sourceEnemy && !otherEnemy.controlled && dist(p, otherEnemy) < p.aoeRadius + otherEnemy.size / 2) {
                                otherEnemy.health -= p.damage * 0.5; 
                                showDamageNumber(p.damage * 0.5, otherEnemy.x, otherEnemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                            }
                        });
                        playSound('explosion'); 
                        spawnParticles(p.x, p.y, {r: 255, g: 100, b: 0}); 
                    }
                    enemyProjectiles.splice(i, 1); 
                    i--; 
                }
            }

            spinningKnives.forEach(knife => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !knife.hitEnemies.has(enemy) && dist(knife, enemy) < (knife.size + enemy.size / 2)) {
                        const damageDealt = knife.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        knife.hitEnemies.add(enemy); 
                    }
                });
                knife.hitEnemies.clear();
            });

            boomerangs.forEach(b => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && !b.hitEnemies.has(enemy) && dist(b, enemy) < (b.size + enemy.size / 2)) {
                        const damageDealt = b.damage;
                        enemy.health -= damageDealt;
                        ultimateCharge += ultimateChargePerHit;
                        showDamageNumber(damageDealt, enemy.x, enemy.y);
                        if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                            playSound('enemyHit');
                            lastEnemyHitSoundTime = survivalTime;
                        }
                        b.hitEnemies.add(enemy); 
                    }
                });
            });
        
            allyDogs.forEach(dog => {
                enemies.forEach(enemy => {
                    if (!enemy.controlled && dist(dog, enemy) < (dog.size / 2 + enemy.size / 2)) {
                        if (survivalTime - dog.lastAttackTime >= dog.attackCooldown) {
                            enemy.health -= dog.damage;
                            showDamageNumber(dog.damage, enemy.x, enemy.y);
                            if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                playSound('enemyHit');
                                lastEnemyHitSoundTime = survivalTime;
                            }
                            dog.lastAttackTime = survivalTime; 
                        }
                    }
                });
            });
        
            powerups.forEach(p => {
                if (dist(player, p) < (player.size / 2 + p.size / 2)) {
                    if (p.type === 'xp') {
                        gainXp(p.xpValue);
                    } else if (p.type === 'heart') {
                        player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.5);
                        console.log("Health restored! Current health:", player.health);
                    }
                    powerups = powerups.filter(item => item !== p);
                }
            });

            for (let i = chests.length - 1; i >= 0; i--) {
                const chest = chests[i];
                if (dist(player, chest) < (player.size / 2 + chest.size / 2)) {
                    activateTemporaryPowerup();
                    chests.splice(i, 1);
                }
            }
        
            enemies = enemies.filter(enemy => {
                if (enemy.health <= 0) {
                    gainXp(enemy.xp);
                    score += 10;
                    spawnParticles(enemy.x, enemy.y, enemy.color);
                    // Always spawn powerup (coin) when enemy dies
                    spawnPowerup(enemy.x, enemy.y, 'xp'); 
                    // Guaranteed treasure drop for 'enforcer'
                    if (enemy.type === 'enforcer') {
                        spawnChestAtLocation(enemy.x, enemy.y);
                    }
                    return false; 
                }
                return true; 
            });
        }
        
        function spawnEnemy() {
            const minSpawnInterval = 0.05; 
            const maxSpawnInterval = 0.8; 
            const spawnRateFactor = Math.min(1, survivalTime / 600); 
            let spawnInterval = maxSpawnInterval - (maxSpawnInterval - minSpawnInterval) * spawnRateFactor;

            if (survivalTime < 60) {
                spawnInterval *= 0.33; 
            }

            if (spawnTimer >= spawnInterval) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
            
                switch (side) {
                    case 0: 
                        x = Math.random() * gameWorld.width;
                        y = Math.max(0, camera.y - 50);
                        break;
                    case 1: 
                        x = Math.min(gameWorld.width, camera.x + camera.width / camera.zoom + 50);
                        y = Math.random() * gameWorld.height;
                        break;
                    case 2: 
                        x = Math.random() * gameWorld.width;
                        y = Math.min(gameWorld.height, camera.y + camera.height / camera.zoom + 50);
                        break;
                    case 3: 
                        x = Math.max(0, camera.x - 50);
                        y = Math.random() * gameWorld.height;
                        break;
                }
            
                let enemyType = 'basic';
                const timeInMinutes = survivalTime / 60;

                // New logic for spawning 'enforcer' every 5 minutes
                if (timeInMinutes >= 5 && Math.floor(timeInMinutes) % 5 === 0 && Math.random() < 0.1) { 
                    enemyType = 'enforcer';
                } else if (timeInMinutes < 0.5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.7) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 2) { 
                    const rand = Math.random();
                    if (rand < 0.4) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'enemyDog';
                    else if (rand < 0.85) enemyType = 'enemyDrone';
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 5) { 
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic'; 
                    else if (rand < 0.7) enemyType = 'tank'; 
                    else if (rand < 0.8) enemyType = 'car'; 
                    else if (rand < 0.9) enemyType = 'cobra'; 
                    else enemyType = 'robotDrone'; 
                } else if (timeInMinutes < 8) { 
                    const rand = Math.random();
                    if (rand < 0.1) enemyType = 'basic';
                    else if (rand < 0.25) enemyType = 'fast'; 
                    else if (rand < 0.4) enemyType = 'gunner'; 
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'drone'; 
                    else if (rand < 0.75) enemyType = 'car';
                    else if (rand < 0.85) enemyType = 'elite';
                    else if (rand < 0.95) enemyType = 'cobra';
                    else enemyType = 'robotDrone'; 
                } else { 
                    const rand = Math.random();
                    if (rand < 0.05) enemyType = 'basic';
                    else if (rand < 0.15) enemyType = 'fast'; 
                    else if (rand < 0.25) enemyType = 'gunner'; 
                    else if (rand < 0.35) enemyType = 'tank';
                    else if (rand < 0.45) enemyType = 'drone'; 
                    else if (rand < 0.55) enemyType = 'car';
                    else if (rand < 0.65) enemyType = 'elite';
                    else if (rand < 0.75) enemyType = 'ninja'; 
                    else if (rand < 0.85) enemyType = 'cobra';
                    else if (rand < 0.95) enemyType = 'robotDrone'; 
                    else enemyType = 'yellowSkull'; 
                }

                if (enemyType === 'cobra') {
                    spawnCobra(x, y);
                } else {
                    const newEnemy = {
                        x: x,
                        y: y,
                        type: enemyType,
                        controlled: false,
                        shootTimer: 0,
                        flankAngle: (Math.random() - 0.5) * Math.PI / 4,
                        vx: 0, 
                        vy: 0, 
                        animationFrame: 0, 
                        stuckTimer: 0, 
                        ghostModeActive: false, 
                        ghostModeTimer: 0, 
                        lastX: x, 
                        lastY: y, 
                        ...getEnemyStats(enemyType)
                    };
                    enemies.push(newEnemy);
                }
                spawnTimer = 0;
            }
        }

        function spawnCobra(x, y) {
            const numSegments = 5 + Math.floor(Math.random() * 3); 
            const segmentSize = 25;
            const snakeId = Date.now(); 

            for (let i = 0; i < numSegments; i++) {
                const segmentX = x - i * segmentSize * 1.5; 
                const segmentY = y;
                enemies.push({
                    x: segmentX,
                    y: segmentY,
                    type: 'cobra',
                    controlled: false, 
                    snakeId: snakeId,
                    segmentIndex: i,
                    stuckTimer: 0, 
                    ghostModeActive: false, 
                    ghostModeTimer: 0, 
                    lastX: segmentX, 
                    lastY: segmentY, 
                    ...getEnemyStats('cobra')
                });
            }
        }
        
        function getEnemyStats(type) {
            const base = {
                size: 25, speed: 30, health: 50, damage: 10, xp: 10,
                projectileSize: 8, projectileDamage: 15, projectileSpeed: 100, projectileColor: '#FF0000', attackRange: 250, attackSpeed: 0.8
            };
        
            switch (type) {
                case 'basic':
                    base.color = '#777777';
                    break;
                case 'fast':
                    base.size = 20; base.speed = 50; base.health = 30; base.xp = 15; base.color = '#ff4444';
                    base.attackRange = 200; base.attackSpeed = 2; base.projectileSpeed = 150; 
                    break;
                case 'tank':
                    base.size = 30; 
                    base.speed = 15; base.health = 200; base.xp = 50; base.color = '#9966ff';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'elite':
                    base.size = 30; base.speed = 40; base.health = 500; base.damage = 20; base.xp = 200; base.color = '#ff0000';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'gunner':
                    base.size = 25; base.speed = 20; base.health = 40; base.damage = 0; base.xp = 20; base.color = '#3399ff';
                    base.attackRange = 400; base.attackSpeed = 1; base.projectileSpeed = 100; 
                    break;
                case 'drone':
                    base.size = 15; base.speed = 40; base.health = 20; base.xp = 12; base.color = '#888888';
                    base.attackRange = 150; base.attackSpeed = 2.5; base.projectileSpeed = 125; base.projectileSize = 5; base.projectileColor = '#FF0000'; 
                    break;
                case 'car':
                    base.size = 35; 
                    base.speed = 70; base.health = 300; base.damage = 25 * 0.8; base.xp = 75; base.color = '#663300'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'ninja':
                    base.size = 22; base.speed = 80; base.health = 60; base.damage = 15; base.xp = 30; base.color = '#333333';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
                case 'enemyDog':
                    base.size = 20; base.speed = 60; base.health = 35; base.damage = 12; base.xp = 18; base.color = '#A0522D'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'enemyDrone':
                    base.size = 15; base.speed = 45; base.health = 25; base.damage = 0; base.xp = 15; base.color = '#4682B4'; 
                    base.attackRange = 200; base.attackSpeed = 1.5; base.projectileSpeed = 110; base.projectileSize = 6; base.projectileColor = '#FF0000'; 
                    break;
                case 'cobra':
                    base.size = 25; base.speed = 40; base.health = 70; base.damage = 15; base.xp = 25; base.color = '#228B22'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'robotDrone': 
                    base.size = 18; base.speed = 70; base.health = 20; base.damage = 25; base.xp = 15; base.color = '#808080'; 
                    base.explosionRadius = 70; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'yellowSkull': 
                    base.size = 35; 
                    base.speed = 10; 
                    base.health = 400; 
                    base.damage = 15; 
                    base.xp = 100; 
                    base.color = '#FFFF00'; 
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0; 
                    break;
                case 'enforcer': 
                    base.size = 40; 
                    base.speed = 10; 
                    base.health = 1000; 
                    base.damage = 30; 
                    base.xp = 500; 
                    base.color = '#8B0000'; 
                    base.attackRange = 80; 
                    base.attackSpeed = 0.5; 
                    base.projectileSize = 20; 
                    base.projectileDamage = 40; 
                    base.projectileSpeed = 100; 
                    base.projectileColor = '#FF4500'; 
                    break;
                default: 
                    base.color = '#777777';
                    base.attackRange = 0; base.attackSpeed = 0; base.projectileSpeed = 0;
                    break;
            }
            
            const healthScale = 1 + Math.pow(survivalTime / 60, 0.5); 
            const damageScale = 1 + Math.pow(survivalTime / 90, 0.4); 
            let speedScale = 1 + Math.min(survivalTime / 180, 1.5); 

            if (survivalTime >= 120) { 
                speedScale *= 1.15;
            }

            base.health *= healthScale;
            base.damage *= damageScale;
            base.speed *= speedScale;
            base.xp = Math.floor(base.xp * ((healthScale + damageScale) / 2) * 0.5); 

            if (type === 'gunner' || type === 'fast' || type === 'drone' || type === 'enemyDrone' || type === 'enforcer') { 
                base.projectileDamage *= damageScale;
                base.attackSpeed *= (1 + Math.min(survivalTime / 180, 1));
            }

            if (type === 'basic' && survivalTime < 60) {
                base.health *= 0.75; 
            }

            return base;
        }

        function explodeRobotDrone(drone) {
            playSound('explosion');
            spawnParticles(drone.x, drone.y, {r: 255, g: 100, b: 0}); 

            if (dist(player, drone) < (player.size / 2 + drone.explosionRadius)) {
                // Apply damage only if not invincible
                if (!player.invincible) {
                    let damageTaken = drone.damage;
                    damageTaken = damageTaken * (1 - player.stats.damageReduction);
                    if (ultimateActive) {
                        damageTaken *= 0.5;
                    }
                    damageTaken = Math.max(0, damageTaken); 
                    player.health -= damageTaken;

                    // Activate invincibility frames
                    player.invincible = true;
                    player.invincibilityTimer = 0.5; 
                    player.flashTimer = 0;
                    player.isFlashing = true;
                    player.color = 'rgba(255,255,255,0.7)'; // Flash white

                    if (player.health <= 0) {
                        gameOver();
                    }
                    showDamageNumber(damageTaken, player.x, player.y);
                }
            }

            enemies.forEach(otherEnemy => {
                if (otherEnemy !== drone && !otherEnemy.controlled && dist(drone, otherEnemy) < (drone.explosionRadius + otherEnemy.size / 2)) {
                    otherEnemy.health -= drone.damage * 0.5; 
                    showDamageNumber(drone.damage * 0.5, otherEnemy.x, otherEnemy.y);
                    if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                        playSound('enemyHit');
                        lastEnemyHitSoundTime = survivalTime;
                    }
                }
            });
        }
        
        function spawnPowerup(x, y, type) {
            if (type === 'xp') {
                powerups.push({
                    x: x, y: y, size: 10, color: '#ffff00', speed: 300, 
                    xpValue: 25, 
                    type: 'xp'
                });
            } else if (type === 'heart') {
                 powerups.push({
                    x: x, y: y, size: 15, color: '#FF0000', speed: 300, 
                    type: 'heart'
                });
            }
        }

        function spawnChestAtLocation(x, y) {
            chests.push({
                x: x, y: y, size: 30, type: 'chest'
            });
        }

        function activateTemporaryPowerup() {
            // This function is now only for Johnny's temporary powerups
            if (currentCharacter === 'dixie') return; 

            const powerupChoices = ['spreadGun']; 
            const chosenPowerup = powerupChoices[Math.floor(Math.random() * powerupChoices.length)];

            temporaryPowerupType = chosenPowerup;

            if (survivalTime >= 300 && survivalTime < 900) { 
                temporaryPowerupDuration = 10;
            } else { 
                temporaryPowerupDuration = 5;
            }
            
            temporaryPowerupActive = true; 

            switch (chosenPowerup) {
                case 'spreadGun':
                    console.log("Spread Gun Activated!");
                    break;
            }
        }

        function deactivateTemporaryPowerup() {
            if (!temporaryPowerupActive) return;

            switch (temporaryPowerupType) {
                case 'spreadGun':
                    console.log("Spread Gun Deactivated!");
                    break;
            }
            temporaryPowerupActive = false;
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
        }
        
        function gainXp(amount) {
            const wasMessageBoxHidden = messageBox.style.display !== 'block'; 
            player.xp += amount;
            console.log(`[XP Gain] XP gained: ${amount}, Current XP: ${player.xp}, Next Level XP: ${player.nextLevelXp}`);
            while (player.xp >= player.nextLevelXp) {
                levelUpQueue.push(true);
                player.xp -= player.nextLevelXp;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5); 
                player.maxHealth += 10;
                player.health = Math.min(player.health + 10, player.maxHealth);
                player.level++;
                playSound('levelUp');
                console.log(`[LEVEL UP] New Level: ${player.level}, XP remaining: ${player.xp}, Next Level XP: ${player.nextLevelXp}. Queue size: ${levelUpQueue.length}`);
            }
            if (levelUpQueue.length > 0 && wasMessageBoxHidden) {
                console.log(`[Show Power] Calling showPowerSelection from gainXp. Queue size: ${levelUpQueue.length}, wasMessageBoxHidden: ${wasMessageBoxHidden}`);
                showPowerSelection();
            }
        }
        
        function showPowerSelection() {
            gameRunning = false;
            isPaused = true; 
            Tone.Transport.stop(Tone.now()); 
            messageBox.style.display = 'block';
            powerSelectionDiv.innerHTML = '';
            console.log("[Show Power] showPowerSelection called.");
        
            const numOptions = 4; 
            // Filter powers based on current character
            const availablePowers = POWER_OPTIONS.filter(p => 
                p.level() < MAX_UPGRADE_LEVEL && p.characters.includes(currentCharacter)
            ); 
            const selectedPowers = [];
        
            let tempAvailablePowers = [...availablePowers];

            while (selectedPowers.length < numOptions && tempAvailablePowers.length > 0) {
                const randomIndex = Math.floor(Math.random() * tempAvailablePowers.length);
                selectedPowers.push(tempAvailablePowers[randomIndex]);
                tempAvailablePowers.splice(randomIndex, 1); 
            }
        
            selectedPowers.forEach(power => {
                const card = document.createElement('div');
                card.className = 'power-card';
                card.innerHTML = `
                    <h4>${power.name} <span>Lvl ${power.level() + 1}</span></h4>
                    <p>${power.next()}</p>
                `;
                card.addEventListener('click', () => selectPower(power));
                powerSelectionDiv.appendChild(card);
            });
        }
        
        function selectPower(power) {
            power.effect();
            console.log(`[Power Select] Power selected: ${power.name}. Before shift, queue size: ${levelUpQueue.length}`);
            
            messageBox.style.display = 'none'; 
            
            if (levelUpQueue.length > 0) {
                levelUpQueue.shift(); 
                console.log(`[Power Select] After shift, queue size: ${levelUpQueue.length}. Calling showPowerSelection again.`);
                showPowerSelection(); 
            } else {
                console.log(`[Power Select] No more level ups pending. Resuming game.`);
                gameRunning = true;
                isPaused = false; 
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function resetGame() {
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            powerups.length = 0;
            damageNumbers.length = 0;
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            allyDogs = []; // Ensure dogs are cleared on full game reset
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            
            survivalTime = 0;
            shootTimer = 0;
            spawnTimer = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; 
            randomHeartSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; // Reset temporary powerup state
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
            lastUziSoundTime = 0;

            // Reset forcefield specific stats
            player.stats.forcefieldActive = false;
            player.stats.forcefieldDamage = 0;
            player.stats.forcefieldRadius = 0;
            player.forcefieldTimer = 0;
            player.forcefieldHitEnemies.clear();
            player.stats.leashWhipDamage = 0; 
            player.leashWhipCooldown = 0;    
            player.leashWhipTimer = 0;       

            dogProjectileDamage = 0; 
            dogProjectileSpeed = 0;  

            // Reset new stats/upgrades
            player.stats.knifeDamage = 0;
            player.stats.knifeCount = 0;
            player.stats.knifeCooldown = 1.5;
            player.stats.swordDamage = 0;
            player.stats.swordPierce = 0;
            player.stats.swordCooldown = 3;

            player.upgrades.knifeThrow = 0;
            player.upgrades.swordThrow = 0;

            player.knifeThrowTimer = 0;
            player.swordThrowTimer = 0;

            // Reset player invincibility state
            player.invincible = false;
            player.invincibilityTimer = 0;
            player.flashTimer = 0;
            player.isFlashing = false;

            updateMusicPatterns(currentMusicPatternIndex);
        }

        function handleRetry() {
            startGame();
        }

        function backToMainMenu() {
            resetGame();
            gameRunning = false;
            isPaused = false;
            isMenuOpen = false;
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now());
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now());
            }
            Tone.Transport.stop(Tone.now());
            showStartMenu();
        }

        function updateCamera() {
            camera.x = player.x - (camera.width / camera.zoom) / 2;
            camera.y = player.y - (camera.height / camera.zoom) / 2;

            camera.x = Math.max(0, Math.min(camera.x, gameWorld.width - (camera.width / camera.zoom)));
            camera.y = Math.max(0, Math.min(camera.y, gameWorld.height - (camera.height / camera.zoom)));
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused || isMenuOpen) return; 
        
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            survivalTime += deltaTime;
        
            update(deltaTime);
            draw();
        
            requestAnimationFrame(gameLoop);
        }
        
        function update(dt) {
            const effectiveDt = dt * gameSpeedMultiplier; 

            shootTimer += effectiveDt;
            spawnTimer += effectiveDt;
            musicPatternTimer += effectiveDt;
            randomChestSpawnTimer += effectiveDt; 
            randomHeartSpawnTimer += effectiveDt;

            if (randomChestSpawnTimer >= RANDOM_CHEST_SPAWN_INTERVAL) {
                if (Math.random() < RANDOM_CHEST_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnChestAtLocation(x, y);
                }
                randomChestSpawnTimer = 0;
            }

            // New heart spawn logic
            if (survivalTime >= HEART_SPAWN_START_TIME && randomHeartSpawnTimer >= HEART_SPAWN_INTERVAL) {
                if (Math.random() < HEART_SPAWN_CHANCE) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    spawnPowerup(x, y, 'heart');
                }
                randomHeartSpawnTimer = 0;
            }

            if (musicPatternTimer >= MUSIC_PATTERN_CHANGE_INTERVAL) {
                musicPatternTimer = 0;
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * BACKGROUND_MUSIC_PATTERNS.length);
                } while (newIndex === currentMusicPatternIndex);
                currentMusicPatternIndex = newIndex;
                updateMusicPatterns(currentMusicPatternIndex);
            }

            if (player.upgrades.burstCharge > 0) {
                player.burstChargeTimer -= effectiveDt;
            }

            if (player.stats.burstDamage > 0) {
                player.burstTimer += effectiveDt;
            }
            if (player.upgrades.shotgun > 0) { 
                player.shotgunTimer += effectiveDt;
            }
            if (player.stats.dualUziActive) { 
                player.dualUziTimer += effectiveDt;
            }
            if (player.stats.boomerangCount > 0) { 
                player.boomerangTimer += effectiveDt;
            }
            if (currentCharacter === 'dixie' && player.upgrades.leashWhip > 0) { 
                player.leashWhipTimer += effectiveDt;
            }
            if (player.upgrades.knifeThrow > 0) { // New: Update knife throw timer
                player.knifeThrowTimer += effectiveDt;
            }
            if (player.upgrades.swordThrow > 0) { // New: Update sword throw timer
                player.swordThrowTimer += effectiveDt;
            }


            spinningKnives.forEach(knife => {
                knife.angle += knife.rotationSpeed * effectiveDt;
                knife.x = player.x + Math.cos(knife.angle) * knife.radius;
                knife.y = player.y + Math.sin(knife.angle) * knife.radius;
            });

            // Forcefield damage application
            if (player.stats.forcefieldActive) {
                player.forcefieldTimer += effectiveDt;
                const forcefieldTickInterval = 0.5; 
                if (player.forcefieldTimer >= forcefieldTickInterval) {
                    enemies.forEach(enemy => {
                        if (!enemy.controlled && dist(player, enemy) < player.stats.forcefieldRadius + enemy.size / 2) {
                            if (!player.forcefieldHitEnemies.has(enemy)) {
                                const damageDealt = player.stats.forcefieldDamage;
                                enemy.health -= damageDealt;
                                ultimateCharge += ultimateChargePerHit;
                                showDamageNumber(damageDealt, enemy.x, enemy.y);
                                if (survivalTime - lastEnemyHitSoundTime >= enemyHitSoundCooldown) {
                                    playSound('enemyHit');
                                    lastEnemyHitSoundTime = survivalTime;
                                }
                                player.forcefieldHitEnemies.add(enemy);
                            }
                        }
                    });
                    player.forcefieldTimer = 0;
                    player.forcefieldHitEnemies.clear(); 
                }
            }

            if (ultimateActive) {
                ultimateDuration -= effectiveDt;
                if (ultimateDuration <= 0) {
                    ultimateActive = false;
                    player.color = player.baseColor; 
                    ultimateCharge = 0;
                    gameSpeedMultiplier = 1; 
                    playerSpeedModifier = 1; 
                    projectileSpeedModifier = 1; 
                    if (!isMusicMuted) Tone.Transport.playbackRate = 1; 
                }
            } else if (ultimateCharge < ultimateMaxCharge) {
                ultimateCharge += effectiveDt * 5 * (1 + player.upgrades.ultimateRecharge * 0.2); 
                ultimateCharge = Math.min(ultimateCharge, ultimateMaxCharge);
            }

            // Removed temporary powerup logic from here as it's no longer needed for Dixie
            // If Johnny activates a temporary powerup, it will still function as before.
            if (temporaryPowerupActive) {
                temporaryPowerupDuration -= dt; 
                if (temporaryPowerupDuration <= 0) {
                    deactivateTemporaryPowerup();
                }
            }

            updatePlayer(effectiveDt);
            updateCamera();
            updateEnemies(effectiveDt);
            updateProjectiles(effectiveDt);
            updatePowerups(effectiveDt);
            updateChests(effectiveDt); 
            updateAllyDogs(effectiveDt); 
            updateDrones(effectiveDt); 
            updateBoomerangs(effectiveDt); 
            checkCollisions();
            updateDamageNumbers(effectiveDt);
            updateParticles(effectiveDt); 
        }
        
        async function gameOver() {
            gameRunning = false;
            isPaused = true; 
            playSound('gameOver');
            
            if (backgroundMusicSequence) {
                backgroundMusicSequence.stop(Tone.now()); 
            }
            if (bassSequence) {
                bassSequence.stop(Tone.now()); 
            }
            Tone.Transport.stop(Tone.now()); 

            // Save user's personal best score for the current level
            if (window.saveUserLevelScore) {
                await window.saveUserLevelScore(currentLevelId, score);
            }

            showGameOverMenu();
            document.getElementById('final-score').textContent = `Score: ${score}`;
            document.getElementById('final-time').textContent = `Time Survived: ${survivalTime.toFixed(1)}s`;
            document.getElementById('final-level').textContent = `Level Reached: ${player.level}`;

            const currentHighScores = await window.getHighScoresFirebase();
            const isHighScore = currentHighScores.length < 10 || score > Math.min(...currentHighScores.map(s => s.score));

            if (isHighScore) {
                highScoreModal.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                displayHighScores('high-scores-list'); // Display high scores on game over menu
            }
        }

        async function saveAndDisplayHighScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                console.log(`[High Score Modal] Player name entered: "${playerName}"`);
                if (window.saveHighScoreFirebase) {
                    await window.saveHighScoreFirebase(playerName, score, survivalTime.toFixed(1), player.level, currentLevelId);
                }
                highScoreModal.style.display = 'none';
                displayHighScores('high-scores-list'); // Display high scores on game over menu
            } else {
                console.warn("Please enter a name to save your high score.");
            }
        }

        async function displayHighScores(targetElementId) {
            const highScores = await window.getHighScoresFirebase();
            const targetList = document.getElementById(targetElementId);
            if (!targetList) {
                console.error(`Target element with ID ${targetElementId} not found.`);
                return;
            }
            targetList.innerHTML = '';
            console.log(`[Display High Scores for ${targetElementId}] High scores to display:`, highScores);
            
            if (highScores.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No high scores yet. Be the first!';
                targetList.appendChild(li);
                return;
            }

            highScores.forEach((s, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${index + 1}. ${s.name}</span>
                    <span>Score: ${s.score} | Time: ${s.survivalTime}s | Lvl: ${s.level} (${s.levelId === 'hotel_lobby' ? 'Hotel' : (s.levelId === 'the_park' ? 'Park' : 'Desert')})</span>
                `;
                targetList.appendChild(li);
                console.log(`[Display High Scores for ${targetElementId}] Displaying score: ${s.name}, ${s.score}`);
            });
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = 'Resume';
                Tone.Transport.stop(Tone.now()); 
            } else {
                pauseButton.textContent = 'Pause';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            if (isMenuOpen) {
                gameMenu.style.display = 'block';
                Tone.Transport.stop(Tone.now()); 
            } else {
                gameMenu.style.display = 'none';
                if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop); 
            }
        }

        function toggleMusic() {
            isMusicMuted = !isMusicMuted;
            Tone.Destination.mute = isMusicMuted; 
            muteMusicButton.textContent = isMusicMuted ? 'Unmute Music' : 'Mute Music';
        }

        function spawnParticles(x, y, colorInput) {
            let r, g, b;

            if (typeof colorInput === 'object' && colorInput !== null) {
                r = colorInput.r;
                g = colorInput.g;
                b = colorInput.b;
            } else if (typeof colorInput === 'string') {
                if (colorInput.startsWith('#')) {
                    const hex = colorInput.substring(1);
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                } else if (colorInput.startsWith('rgba')) {
                    const parts = colorInput.match(/\d+/g).map(Number);
                    if (parts.length >= 3) {
                        r = parts[0];
                        g = parts[1];
                        b = parts[2];
                    }
                }
            } else {
                r = 255; g = 255; b = 255;
            }

            const numParticles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50; 
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3, 
                    alpha: 1,
                    color: { r: r, g: g, b: b } 
                });
            }
        }
        
        function init() {
            // Start Tone.js audio context immediately
            Tone.start().then(() => {
                setupAudio(); 
                updateMusicPatterns(0); 
            }).catch(e => console.error("Error starting Tone.js audio context:", e));


            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;

            // Set mini-map canvas dimensions to match container for square shape
            miniMapCanvas.width = miniMapContainer.clientWidth;
            miniMapCanvas.height = miniMapContainer.clientHeight;
            miniMapScale = miniMapCanvas.width / gameWorld.width; 

            window.addEventListener('resize', () => {
                canvas.width = gameContainer.clientWidth;
                canvas.height = gameContainer.clientHeight;
                camera.width = canvas.width / camera.zoom; 
                camera.height = canvas.height / camera.zoom; 

                // Adjust mini-map canvas dimensions on resize
                miniMapCanvas.width = miniMapContainer.clientWidth;
                miniMapCanvas.height = miniMapContainer.clientHeight;
                miniMapScale = miniMapCanvas.width / gameWorld.width;

                if (!gameRunning) {
                    showStartMenu();
                }
            });
        
            document.getElementById('startButton').addEventListener('click', () => {
                showCharacterSelectMenu(); 
            });
            document.getElementById('restartButton').addEventListener('click', handleRetry);
            saveScoreButton.addEventListener('click', saveAndDisplayHighScore);
            backToMainMenuButtonGameOver.addEventListener('click', backToMainMenu); // Event listener for new button

            pauseButton.addEventListener('click', togglePause);
            menuButton.addEventListener('click', toggleMenu);
            muteMusicButton.addEventListener('click', toggleMusic);
            resumeFromMenuButton.addEventListener('click', toggleMenu); 

            // New level select button and its event listeners
            levelSelectButton.addEventListener('click', showLevelSelectMenu);
            backToMainMenuButton.addEventListener('click', showStartMenu);
            backToMainMenuButtonFromGame.addEventListener('click', backToMainMenu); 

            // Character selection listeners
            document.querySelectorAll('.character-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    currentCharacter = e.currentTarget.dataset.character;
                    startGame(); 
                });
            });
            backToStartMenuFromCharSelect.addEventListener('click', showStartMenu);

            canvas.addEventListener('mousedown', handlePointerEvent);
            canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
            
            function handlePointerEvent(e) {
                e.preventDefault();
                if (!gameRunning || isPaused || isMenuOpen) return; 

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const inputX = (clientX - rect.left) / camera.zoom;
                const inputY = (clientY - rect.top) / camera.zoom;
                
                player.targetX = camera.x + inputX;
                player.targetY = camera.y + inputY;
            }

            ultimateButton.addEventListener('click', () => {
                if (ultimateCharge >= ultimateMaxCharge && !ultimateActive) {
                    activateUltimate();
                }
            });
        
            // Initial obstacle generation based on default level
            generateObstacles();
        
            showStartMenu();

            if (typeof window.initFirebase === 'function') {
                window.initFirebase();
            } else {
                console.error("Firebase initialization function not found.");
            }
        }

        let enemies = []; 
        let projectiles = []; 
        let enemyProjectiles = []; 
        let powerups = []; 
        let obstacles = []; 

        function generateObstacles() {
            obstacles = []; 

            if (currentLevelId === 'hotel_lobby') {
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 50, height: 50, color: '#3c3c3c', type: 'pillar'
                    });
                }

                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 200, height: 50, color: '#4d4d4d', type: 'desk'
                    });
                }

                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 30, height: 30, color: '#2d2d2d', type: 'chair'
                    });
                }
            } else if (currentLevelId === 'the_park') {
                // Trees (circular, larger)
                for (let i = 0; i < 25; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 70, height: 70, color: '#006400', type: 'tree' 
                    });
                }
                // Bushes (rectangular, smaller)
                for (let i = 0; i < 35; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 40, height: 40, color: '#008000', type: 'bush' 
                    });
                }
                // Park Benches (rectangular, longer)
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 100, height: 30, color: '#8B4513', type: 'bench' 
                    });
                }
            } else if (currentLevelId === 'desert_oasis') { // New desert obstacles
                // Cactuses (circular)
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 60, height: 60, color: '#32CD32', type: 'cactus' 
                    });
                }
                // Old Dead Cars (rectangular)
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * gameWorld.width;
                    const y = Math.random() * gameWorld.height;
                    obstacles.push({
                        x: x, y: y, width: 150, height: 60, color: '#696969', type: 'old_car' 
                    });
                }
            }
        }
        
        function startGame() {
            gameRunning = true;
            isPaused = false;
            isMenuOpen = false;
            score = 0;
            survivalTime = 0;
            ultimateCharge = 0;
            player.xp = 0;
            player.level = 1;
            player.nextLevelXp = 100;
            player.x = initialPlayerX;
            player.y = initialPlayerY;
            player.targetX = player.x;
            player.targetY = player.y;
            player.vx = 0; 
            player.vy = 0; 

            // Reset player stats and upgrades based on selected character
            player.stats = {
                damage: 20, attackSpeed: 10, projectileSpeed: 400, pierce: 0, multiShot: 1, 
                healthRegen: 0.1, magnet: 160, damageReduction: 0, 
                spinningKnivesDamage: 0, spinningKnivesCount: 0, 
                burstDamage: 0, burstProjectileCount: 0,
                droneCount: 0, droneDamage: 0, droneAttackSpeed: 0,
                shotgunPellets: 0, shotgunDamage: 0, shotgunSpread: 0,
                dualUziActive: false, dualUziFireRate: 0, dualUziDamage: 0,
                boomerangDamage: 0, boomerangCount: 0, boomerangCooldown: 4, boomerangRange: 150, boomerangSpeed: 400,
                burstChargeDamage: 0, burstChargeProjectileCount: 0,
                forcefieldActive: false, 
                forcefieldDamage: 0,
                forcefieldRadius: 0,
                leashWhipDamage: 0, 
                knifeDamage: 0, // New: Knife damage
                knifeCount: 0,  // New: Number of knives thrown
                knifeCooldown: 1.5, // New: Cooldown for knife throw
                swordDamage: 0, // New: Sword damage
                swordPierce: 0, // New: Sword pierce
                swordCooldown: 3, // New: Cooldown for sword throw
            };
            player.upgrades = {
                damage: 0, attackSpeed: 0, health: 0, speed: 0, pierce: 0, multiShot: 0, 
                healthRegen: 0, magnet: 0, bulletproofSuit: 0, 
                ultimateRecharge: 0, burstShot: 0,
                spinningKnives: 0, 
                combatDrone: 0, shotgun: 0, dualUzi: 0,
                boomerang: 0, burstCharge: 0,
                forcefield: 0,
                dogPack: 0,       
                dogBones: 0,      
                leashWhip: 0,     
                dogStrength: 0,   
                dogSpeed: 0,      
                knifeThrow: 0, // New: Knife Throw upgrade level
                swordThrow: 0, // New: Sword Throw upgrade level
            };
            player.burstChargeCooldown = 5; 
            player.burstChargeTimer = 0; 
            player.burstCooldown = 1;
            player.burstTimer = 0;
            player.shotgunTimer = 0; 
            player.dualUziTimer = 0; 
            player.boomerangTimer = 0; 
            player.currentShootAngle = 0; 
            ultimateChargePerHit = 0.5; 
            lastShotSoundTime = 0;
            lastEnemyHitSoundTime = 0;
            lastUziSoundTime = 0; 
            player.forcefieldTimer = 0; 
            player.forcefieldHitEnemies.clear(); 
            player.leashWhipTimer = 0; 
            player.knifeThrowTimer = 0; // New: Reset knife throw timer
            player.swordThrowTimer = 0; // New: Reset sword throw timer

            dogProjectileDamage = 0; 
            dogProjectileSpeed = 0;  

            // Character specific initializations
            player.character = currentCharacter; // Set the current character on the player object
            if (currentCharacter === 'johnny') {
                player.health = 100;
                player.maxHealth = 100;
                player.color = '#6A808C'; 
                player.baseColor = '#6A808C';
                allyDogs = []; // Ensure dogs are cleared for Johnny
                // Johnny always has his pistol (default weapon)
            } else if (currentCharacter === 'dixie') {
                player.health = 120; // Increased base health for Dixie
                player.maxHealth = 120; // Increased max health for Dixie
                player.color = '#FF69B4'; 
                player.baseColor = '#FF69B4'; 
                allyDogs = []; // Clear any existing dogs before adding new ones
                addAllyDog(); // Dixie starts with 1 dog ally
                player.stats.dualUziActive = true; 
                player.stats.dualUziFireRate = 10; // Base dual uzi fire rate (CHANGED)
                player.stats.dualUziDamage = 4; // Base dual uzi damage (CHANGED)
            }

            currentMusicPatternIndex = 0;
            musicPatternTimer = 0;
            randomChestSpawnTimer = 0; 
            randomHeartSpawnTimer = 0; 
            gameSpeedMultiplier = 1; 
            playerSpeedModifier = 1; 
            projectileSpeedModifier = 1; 
            bulletTimeActive = false; 
            bulletTimeDuration = 0; 
            temporaryPowerupActive = false; 
            temporaryPowerupDuration = 0;
            temporaryPowerupType = '';
            
            player.invincible = false;
            player.invincibilityTimer = 0;
            player.flashTimer = 0;
            player.isFlashing = false;


            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerups = [];
            damageNumbers = [];
            particles = []; 
            spinningKnives = []; 
            chests = []; 
            drones = []; 
            boomerangs = []; 
            levelUpQueue = []; 
            shootTimer = 0;
            spawnTimer = 0;
            ultimateActive = false;
            ultimateDuration = 0;
            
            startMenu.style.display = 'none';
            gameOverMenu.style.display = 'none';
            messageBox.style.display = 'none';
            highScoreModal.style.display = 'none';
            gameMenu.style.display = 'none'; 
            levelSelectMenu.style.display = 'none'; 
            characterSelectMenu.style.display = 'none'; 

            // Generate obstacles for the selected level
            generateObstacles();
            
            updateMusicPatterns(currentMusicPatternIndex);
            if (!isMusicMuted) Tone.Transport.start(Tone.now()); 
        
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    
// Ensure dogs target different enemies
function assignUniqueDogTargets(dogs, enemies) {
    const usedEnemies = new Set();
    dogs.forEach(dog => {
        let target = enemies.find(e => !usedEnemies.has(e));
        if (target) {
            dog.target = target;
            usedEnemies.add(target);
        }
    });
}

function applyInstantMagnetEffect() {
    xpOrbs.forEach(orb => {
        orb.x = player.x;
        orb.y = player.y;
    });
}

function collectChest(chest) {
    score += 100;
    applyInstantMagnetEffect();
    playSound('explosion');
}
</script>
<script>
function handleLevelUp() {
    isPaused = true;
    Tone.Speak && Tone.Speak('Level up!');
    setTimeout(() => {
        messageBox.style.display = 'block';
        drawPowerUpOptions();
    }, 1000);
}
</script><script>
function saveScoreLocally(score) {
    const scores = JSON.parse(localStorage.getItem("localHighScores") || "[]");
    scores.push(score);
    localStorage.setItem("localHighScores", JSON.stringify(scores));
}
</script></body>
</html>
